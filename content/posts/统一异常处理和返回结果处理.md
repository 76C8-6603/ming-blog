---
    title: "统一异常处理和返回结果处理"
    date: 2018-03-05
    tags: ["spring","java"]
    
---

# 1. 问题背景

```java
@RestController
public class TestController{
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/user/all")
    public ResultEntity getAllUser(){
        try{
            ResultEntity resultEntity = new ResultEntity();
            List<User> users = userService.getAll();
            resultEntity.setCode(200);
            resultEntity.setMessage("success");
            resultEntity.setData(users);
            return resultEntity;  
        }catch(UserException e){
            ResultEntity resultEntity = new ResultEntity();
            resultEntity.setCode(666);
            resultEntity.setMessage(e.getMessage());
            return resultEntity;
        }catch (Exception e){
            ResultEntity resultEntity = new ResultEntity();
            resultEntity.setCode(888);
            resultEntity.setMessage("前端问题");
            return resultEntity; 
        }
    }
}
```

写那么多，其实就是为了解决两个问题：一是返回值包装，二是异常信息包装。核心的也就是那句service，其余代码基本都是冗余的。  

# 2. 统一异常处理
```java
@RestController
public class TestController{
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/user/all")
    public ResultEntity getAllUser(){
        try{
            ResultEntity resultEntity = new ResultEntity();
            List<User> users = userService.getAll();
            resultEntity.setCode(200);
            resultEntity.setMessage("success");
            resultEntity.setData(users);
            return resultEntity;  
        }catch(UserException e){
            //包含特定异常信息，直接抛出
            throw e;
        }catch(Exception e){
            //默认异常信息
            throw new UserException();
        }
    }
}
@Service
public class UserServiceImpl implements UserService{
    public List<User> getAll(){
        throw new UserException("还没写了");
        try{
        }catch (Exception e){
            throw new UserException("前端有问题",e);
        }
    }
}
```
这个调整的结果，意味着在controller不需要再去封装异常的ResultEntity，直接抛出对应异常即可。并且异常的code和默认message都和`UserException`绑定，当然你也可以返回同一个code，不同的具体错误信息，像上面`servie`的操作  

下面是对异常的统一处理：  
`BusinessException`自定义Exception父类：
```java
public abstract class BusinessException extends RuntimeException {

    private int code;
    private String projectMsg;

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getProjectMsg() {
        return projectMsg;
    }

    public void setProjectMsg(String projectMsg) {
        this.projectMsg = projectMsg;
    }

    public BusinessException() {
        setDefaultCodeAndMessage();
    }

    public BusinessException(String projectMsg) {
        super(projectMsg);
        setDefaultCodeAndMessage();
        if (StringUtils.isNotEmpty(projectMsg)) {
            this.projectMsg = projectMsg;
        }
    }

    public BusinessException(String projectMsg, Throwable cause) {
        super(projectMsg, cause);
        setDefaultCodeAndMessage();
        if (StringUtils.isNotEmpty(projectMsg)) {
            this.projectMsg = projectMsg;
        }
    }

    public BusinessException(Throwable cause) {
        super(cause);
        setDefaultCodeAndMessage();
    }

    public BusinessException(String projectMsg, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(projectMsg, cause, enableSuppression, writableStackTrace);
        setDefaultCodeAndMessage();
        if (StringUtils.isNotEmpty(projectMsg)) {
            this.projectMsg = projectMsg;
        }
    }

    public abstract ResultEnum getResultEnum();

    private void setDefaultCodeAndMessage() {
        ResultEnum resultEnum = getResultEnum();
        this.code = resultEnum.getCode();
        this.projectMsg = resultEnum.getMessage();
    }
}
```

`UserException`自定义Exception子类：
```java
public class UserException extends BusinessException {

    private static final ResultEnum resultEnum = ResultEnum.USER_EXCEPTION;

    @Override
    public ResultEnum getResultEnum() {
        return resultEnum;
    }

    public ModelplanException() {
    }

    public ModelplanException(String projectMsg) {
        super(projectMsg);
    }

    public ModelplanException(String projectMsg, Throwable cause) {
        super(projectMsg, cause);
    }

    public ModelplanException(Throwable cause) {
        super(cause);
    }

    public ModelplanException(String projectMsg, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(projectMsg, cause, enableSuppression, writableStackTrace);
    }


}
```
一般来说一个模块对应一个Exception子类，子类继承BusinessException，然后重写`getResultEnum`方法。这个方法就是为了返回每个异常子类绑定的code和message信息    

`ResultEnum`统一维护code和message：
```java
public enum ResultEnum {

    SUCCESS(1000, "success"),
    // 异常
    EXCEPTION(1, "环境问题"),

    //1001开头
    USER_EXCEPTION(1001, "用户操作有问题");

    private Integer code;

    private String message;

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    ResultEnum(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

`ResponseResultBodyAdvice`统一的异常处理：
```java
@Slf4j
@RestControllerAdvice
public  class ResponseResultBodyAdvice{
    @ExceptionHandler(Exception.class)
    public final ResultEntity exceptionHandler(Exception ex, WebRequest request) {
        log.error("ExceptionHandler:{}", ex);
        if (e instanceof UserException) {
            return new ResultEntity(ResultEnum.USER_EXCEPTION, null);
        }
        return new ResultEntity(ResultEnum.EXCEPTION, null);
    }
}
```

`ResultEntity`统一的返回信息包装：
```java
@Data
@AllArgsConstructor
public class ResultEntity<T>{
    private int code;
    private String msg;
    private T data;

    public ResultEntity(ResultEnum resultEnum, T data) {
        this.code = resultEnum.getCode();
        this.msg = resultEnum.getMsg();
        this.data = data;
    }
}
```

# 3. 统一返回值包装
```java
@RestController
public class TestController{
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/user/all")
    public List<User> getAllUser(){
        try{
            return userService.getAll();
        }catch(UserException e){
            //包含特定异常信息，直接抛出
            throw e;
        }catch(Exception e){
            //默认异常信息
            throw new UserException();
        }
    }
}
```
只需要调整一下之前的异常处理类  
`ResponseResultBodyAdvice`统一返回值包装：
```java
@Slf4j
@RestControllerAdvice
public  class ResponseResultBodyAdvice implements ResponseBodyAdvice<Object> {
    //要包装返回值的目标方法，目前设定是被@ResponseBody注解修饰的方法(也就是所有controller类的方法)。
    //如果只想局部调整，不想影响全局controller，可以自定义一个注解
    private static final Class<? extends Annotation> ANNOTATION_TYPE = ResponseBody.class;

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(),ANNOTATION_TYPE);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class<? extends HttpMessageConverter<?>> selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        if (body instanceof ResultEntity) {
            return body;
        }
        return new ResultEntity(ResultEnum.SUCCESS, body);
    }


    @ExceptionHandler(Exception.class)
    public final ResultEntity exceptionHandler(Exception ex, WebRequest request) {
        log.error("ExceptionHandler:{}", ex);
        if (e instanceof UserException) {
            return new ResultEntity(ResultEnum.USER_EXCEPTION, null);
        }
        return new ResultEntity(ResultEnum.EXCEPTION, null);
    }
}
```




