<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
        Spring集成测试 - Ming Blog
      </title>
        <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    
    <meta name="theme-color" content="#000000" />
    
    <meta http-equiv="window-target" content="_top" />
    
    
    <meta name="description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成" />
    <meta name="generator" content="Hugo 0.74.3 with theme pure" />
    <title>Spring集成测试 - Ming Blog</title>
    
    
    <link rel="stylesheet" href="http://www.mingaccount.com/css/style.min.7dc20efbc53647d41aa9ddea0c48e59300223d084e66ea0cbe7c30bd88903acc.css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css" async>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" async>
    <meta property="og:title" content="Spring集成测试" />
<meta property="og:description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.mingaccount.com/2017/09/spring%E6%B5%8B%E8%AF%95/" />
<meta property="article:published_time" content="2017-09-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-09-15T00:00:00+00:00" />
<meta itemprop="name" content="Spring集成测试">
<meta itemprop="description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成">
<meta itemprop="datePublished" content="2017-09-15T00:00:00+00:00" />
<meta itemprop="dateModified" content="2017-09-15T00:00:00+00:00" />
<meta itemprop="wordCount" content="22389">



<meta itemprop="keywords" content="spring,unit-test," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring集成测试"/>
<meta name="twitter:description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成"/>

    <!--[if lte IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
      <![endif]-->

    <!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
      <![endif]-->
  </head>

  
  

  <body class="main-center theme-green" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="" target="_blank">
            <img class="img-circle img-rotate" src="http://www.mingaccount.com/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">Ming</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">tianshiming5@outlook.com</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>BeiJing, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="Type something..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts/">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories/">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags/">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>

<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title"> Categories</h3>
    <div class="widget-body">
        <ul class="category-list">
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> Tags</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/design-pattern/" class="tag-list-link">design-pattern</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/druid/" class="tag-list-link">druid</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/ehcache/" class="tag-list-link">ehcache</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/git/" class="tag-list-link">git</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/hadoop/" class="tag-list-link">hadoop</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/hive/" class="tag-list-link">hive</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/jackson/" class="tag-list-link">jackson</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">30</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/jooq/" class="tag-list-link">jooq</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/lombok/" class="tag-list-link">lombok</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/markdown/" class="tag-list-link">markdown</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/maven/" class="tag-list-link">maven</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/mybatis/" class="tag-list-link">mybatis</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/mysql/" class="tag-list-link">mysql</a><span
                    class="tag-list-count">16</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/npm/" class="tag-list-link">npm</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/oracle/" class="tag-list-link">oracle</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/redis/" class="tag-list-link">redis</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/regexp/" class="tag-list-link">regexp</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/scala/" class="tag-list-link">scala</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/spark/" class="tag-list-link">spark</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/spring/" class="tag-list-link">spring</a><span
                    class="tag-list-count">21</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/unit-test/" class="tag-list-link">unit-test</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/website-build/" class="tag-list-link">website-build</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="http://www.mingaccount.com/tags/windows/" class="tag-list-link">windows</a><span
                    class="tag-list-count">4</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="http://www.mingaccount.com/2020/10/windowspngquantfailedtobuild/" class="title">Windows CMD 错误pngquant failed to build, make sure that libpng-dev is installed</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-10-18 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-10-18</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="http://www.mingaccount.com/2020/08/win10/" class="title">WIN10 UBUNTU 异常：sleep: cannot read realtime clock: Invalid argument</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-10 13:37:30 &#43;0800 CST" itemprop="datePublished">2020-08-10</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="http://www.mingaccount.com/2020/07/oracleextract%E5%87%BD%E6%95%B0%E6%8F%90%E5%8F%96%E6%97%B6%E5%88%86%E7%A7%92%E7%9A%84%E9%97%AE%E9%A2%98/" class="title">Oracle extract函数提取时分秒的问题</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-07-30 17:42:55 &#43;0800 CST" itemprop="datePublished">2020-07-30</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="http://www.mingaccount.com/2020/07/jooq%E9%BB%98%E8%AE%A4schema/" class="title">JOOQ默认schema</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-07-14 11:16:55 &#43;0800 CST" itemprop="datePublished">2020-07-14</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="http://www.mingaccount.com/2020/06/druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E6%97%A0%E9%99%90%E5%B0%9D%E8%AF%95%E9%97%AE%E9%A2%98/" class="title">Druid数据库连接失败，无限尝试问题</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-06-16 15:38:20 &#43;0800 CST" itemprop="datePublished">2020-06-16</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <h4 class="toc-title">Catalogue</h4>
    <nav id="toc" class="js-toc toc">

    </nav>
  </div>
</aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2017/09/spring%E6%B5%8B%E8%AF%95/"
    >Spring集成测试</a
  >
</h1>

      <div class="article-meta">
        
<span class="article-date">
  <i class="icon icon-calendar-check"></i>&nbsp;
<a href="http://www.mingaccount.com/2017/09/spring%E6%B5%8B%E8%AF%95/" class="article-date">
  <time datetime="2017-09-15 00:00:00 &#43;0000 UTC" itemprop="datePublished">2017-09-15</time>
</a>
</span>
  
  <span class="article-tag">
    <i class="icon icon-tags"></i>&nbsp;
    <a class="article-tag-link" href="/tags/spring/"> spring </a>
    <a class="article-tag-link" href="/tags/unit-test/"> unit-test </a>
  </span>

        <span class="post-comment"><i class="icon icon-comment"></i>&nbsp;<a href="/2017/09/spring%E6%B5%8B%E8%AF%95/#comments"
            class="article-comment-link">Comments</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 22389words</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 45minutes </span>
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <h1 id="1-概览">1. 概览</h1>
<p>一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成测试，那么将会极大的缩短测试时间。比如通过ORM框架访问数据库的时候，想确定sql的正确性，或者对象实例映射的正确性</p>
<p>介绍Spring的测试框架，第一个就离不开<code>org.springframework.test</code>包，他对Spring容器集成测试有很大的价值，并且它不依赖于任何其他的部署环境或者应用服务。虽然他比纯粹的单元测试慢，但是比任何等同于<code>Selenium</code>的测试，或者需要依赖于部署应用服务的测试都快</p>
<p>Spring TestContext框架是以注解为驱动支持单元和集成测试的。这个<code>TestContext</code>不管实际使用的是什么测试框架，在Junit，TestNG，以及其他测试框架环境中都能进行测试</p>
<h1 id="2-集成测试的目标">2. 集成测试的目标</h1>
<p>Spring集成测试主要有下面几个主要目标：</p>
<ul>
<li>在测试之间管理Spring IoC容器的缓存</li>
<li>为测试的资源实例提供依赖注入</li>
<li>提供适合集成测试的事务管理</li>
<li>提供Spring指定的基础类以帮助开发者写集成测试</li>
</ul>
<p>接下来的子章节是对上面几个目标的详细描述</p>
<h2 id="21-上下文管理和缓存">2.1. 上下文管理和缓存</h2>
<p>Spring TestContext框架提供了<code>ApplicationContext</code>实例和<code>WebApplicationContext</code>实例的一致性加载，以及这些上下文对象的缓存。支持缓存和加载这些上下文对象是非常重要的，因为启动时间是个很严重的问题，这个时间的消费并不是Spring容器自身消耗的，而是对象实例化需要时间。举个例子，一个项目有50到100个Hibernate的映射文件，那么将要花费10到20秒的时间去加载这些映射文件,如果每次测试都有这个花费，那么会拖慢整个测试进度，减少开发者的产出。</p>
<p>典型的测试类申明要么是xml的资源位置数组或者Groovy的配置源数据（一般在classpath目录下），又或者是配置应用的成员类数组。这些位置或者类跟<code>web.xml</code>中的申明基本类似</p>
<p>默认情况下，一旦加载，每次测试都复用的一个<code>ApplicationContext</code>。  因此，一个测试套件（test suite)只会有一次初始化应用的过程，每次子测试可以节省大量时间。这里说的测试套件(test suite)术语代表在一个JVM里面运行的所有测试-比如说，一个由Ant，Maven，或者Gradle构建的项目中运行的所有测试。在极少情况下，<code>ApplicationContext</code>会被污染需要重新加载（举个例子，通过修改bean的定义或者应用对象的状态）TestContext框架可以通过配置重载配置信息，并在执行下次测试之前重新构建<code>ApplicationContext</code>。下文中有详细操作。</p>
<h2 id="22-测试资源的依赖注入">2.2. 测试资源的依赖注入</h2>
<p>当<code>TestContext</code>框架加载你的<code>ApplicationContext</code>时，他可以通过依赖注入添加任意的配置到你的测试实例。他提供了一个简明的机制，通过<code>ApplicationContext</code>中的预配置bean来构建你测试所需要的资源环境。他的最大好处是每个测试场景都可以共用一个<code>ApplicationContext</code>，避免一次测试起一次环境</p>
<p>现在假如我们有一个类<code>HibernateTitleRepository</code>，他实现了<code>Title</code>领域实体（domain entity)的数据访问逻辑。我们想写一个集成测试以测试下面几个方面：</p>
<ul>
<li>Spring的配置：所有<code>HibernateTitleRepository</code>相关的配置是否正确关联和展示？</li>
<li>Hibernate的映射文件配置：映射是否正确并且延迟加载的配置是否到位？</li>
<li><code>HibernateTitleRepository</code>的逻辑：该类配置实例的运行是否符合预期？</li>
</ul>
<p>依赖注入的详细内容后面会讲到</p>
<h2 id="23-事务管理">2.3. 事务管理</h2>
<p>在测试中访问真实数据库的一个常见问题是测试对持久性存储状态的影响。即使你使用的是开发数据库，更改状态也可能会影响到进一步的测试。还有许多操作例如插入或者修改持久数据，没有事务都是不能运行的</p>
<p><code>TestContext</code>框架解决了这个问题。默认情况下，框架会为每次测试创建和回滚事务。你可以在假定有事务的前提下写测试代码。如果你在测试中调用事务的代理对象，根据他们配置的事务语句，决定他们是否能正常运转。另外，如果一个测试方法在事务管理的范围内删除了选中表的内容，默认情况下事务会回滚，数据库会返回到执行测试之前的状态。为测试提供的事务支持是由<code>PlatformTransactionManager</code>bean来提供的</p>
<p>如果你想提交一个事务（一般来说不会，在你想填充或者修改数据库的时候有用），你可以通过TestContext框架来提交事务以代替使用<code>@Commit</code>注解的回滚</p>
<p>详细内容后面会讲到</p>
<h2 id="24-集成测试的支持类">2.4. 集成测试的支持类</h2>
<p><code>TestContext</code>框架提供了多个抽象支持类，他们简化了集成测试的编写。这些基础测试类为测试框架提供了定义明确的钩子和方便的实例参数和方法，他们能让你访问：</p>
<ul>
<li><code>ApplicationContext</code>，用于执行显式的bean查找或者测试整个上下文的状态。</li>
<li><code>JdbcTemplate</code>，用于执行sql表达式。你可以查询数据库相关应用代码执行前后的数据库状态，并且Spring确保这些查询都在同一个事务中。党和ORM框架配合使用时，需要确保避免<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tx-false-positives">false positives</a></li>
</ul>
<p>另外你可能想创建你自定义的支持类，更多信息可以参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-framework">TestContext framework</a></p>
<h1 id="3-jdbc测试的支持">3. JDBC测试的支持</h1>
<p>JDBC相关的工具方法在类<code>JdbcTestUtils</code>类中，他在<code>org.springframework.test.jdbc</code>包下。它简化了标准的数据库测试场景。<code>JdbcTestUtils</code>提供了以下静态的工具方法：</p>
<ul>
<li><code>countRowsInTable(..)</code>:计算指定表有多少行数据</li>
<li><code>countRowsInTableWhere(..)</code>:计算指定表有多少行数据通过提供的where条件进行限制</li>
<li><code>deleteFromTables(..)</code>:删除指定表的所有行</li>
<li><code>deleteFromTableWhere(..)</code>:删除指定表的数据行通过提供的where条件进行限制</li>
<li><code>dropTables(..)</code>:Drop指定表</li>
</ul>
<blockquote>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code>和<code>AbstractTransactionalTestNGSpringContextTests</code>代理了前面提及的<code>JdbcTestUtils</code>类的方法。<br>
<code>spring-jdbc</code>模块支持配置和启动一个集成的数据库，你可以用它进行集成测试。更多细节，参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-embedded-database-support">Embedded Database Support</a> 和 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-embedded-database-dao-testing"> Testing Data Access Logic with an Embedded Database</a></p>
</blockquote>
<h1 id="4-注解">4. 注解</h1>
<p>这个章节介绍你在测试Spring应用时可以用的注解。它包含如下几个主题：</p>
<ul>
<li>Spring 测试注解</li>
<li>标准注解支持</li>
<li>Spring JUnit 4 测试注解</li>
<li>Spring JUnit Jupiter 测试注解</li>
<li>测试元注解</li>
</ul>
<h2 id="41-spring-测试注解">4.1. Spring 测试注解</h2>
<p>Spring框架提供了如下Spring特有的注解，你可以使用他们在你的单元和集成测试中。查看他们对应的javadoc以查找更多信息，包括默认的属性值，属性别名，和其他细节。</p>
<p>Spring测试注解包括：</p>
<ul>
<li><code>@BootstrapWith</code></li>
<li><code>@ContextConfiguration</code></li>
<li><code>@WebAppConfiguration</code></li>
<li><code>@ContextHierarchy</code></li>
<li><code>@ActiveProfiles</code></li>
<li><code>@TestPropertySource</code></li>
<li><code>@DynamicPropertySource</code></li>
<li><code>@DirtiesContext</code></li>
<li><code>@TestExecutionListeners</code></li>
<li><code>@Commit</code></li>
<li><code>@Rollback</code></li>
<li><code>@BeforeTransaction</code></li>
<li><code>@AfterTransaction</code></li>
<li><code>@Sql</code></li>
<li><code>@SqlConfig</code></li>
<li><code>@SqlMergeMode</code></li>
<li><code>@SqlGroup</code></li>
</ul>
<h3 id="boostrapwith"><code>@BoostrapWith</code></h3>
<p><code>@BootstrapWith</code>是一个类级别的注解，你可以使用它配置Spring TestContext框架是怎样引导启动的。具体可以使用<code>@BootstrapWith</code>去指定一个自定的<code>TestContextBootstrapper</code>。查看<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-bootstrapping">bootstrapping the TestContext framework</a> 以获取详细信息</p>
<h3 id="contextconfiguration"><code>@ContextConfiguration</code></h3>
<p><code>@ContextConfiguration</code> 定义类级别的源数据，常用来决定集成测试如何加载和配置一个<code>ApplicationContext</code>。具体的，可以使用<code>@ContextConfiguration</code>声明应用上下文的资源位置，或者用于加载上下文的组件类</p>
<p>资源位置，一般来说就是在classpath路径下的XML的配置文件或者Groovy的脚本，而组件类一般来说是<code>@Configuration</code>注解的类。但是，资源位置可以引用文件系统中的文件和脚本，并且组件类可以是<code>@Component</code>类，<code>@Service</code>类，其他等等。更多参照<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-javaconfig-component-classes">Component Classes</a></p>
<p>下面的例子<code>@ContextConfiguration</code>注解指向了一个XML文件：</p>
<pre><code class="language-java">@ContextConfiguration(&quot;/test-config.xml&quot;)
class XmlApplicationContextTests{}
</code></pre>
<p>下面的例子<code>@ContextConfiguration</code>指向一个类：</p>
<pre><code class="language-java">@ContextConfiguration(classes = TestConfig.class)
class ConfigClassApplicationContextTests{}
</code></pre>
<p>另外还可以使用<code>@ContextConfiguration</code>声明<code>ApplicationContextInitializer</code>类，这种方法也可以声明资源位置和组件类：</p>
<pre><code class="language-java">@ContextConfiguration(initializers = CustomContextIntializer.class)
class ContextInitializerTests{}
</code></pre>
<p>你也可以选择<code>ContextConfiguration</code>申明<code>ContextLoader</code>的方式也行。注意，你通常不需要显式的配置loader，因为默认的loader支持<code>initializers</code>和资源位置或组件类。<br>
下面的例子同时声明了一个资源位置和一个loader:</p>
<pre><code class="language-java">@ContextConfiguration(locations=&quot;/test-context.xml&quot;,loader=CustomContextLoader.class)
class CustomLoaderXmlApplicationContextTests{}
</code></pre>
<blockquote>
<p><code>@ContextConfigurtion</code>对继承资源位置或者配置类提供了支持，还有由父类或者封闭类声明的context initializers</p>
</blockquote>
<p>详情参考 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management">Context Management</a> ,<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration</a> 以及<code>@ContextConfiguration</code>的API文档</p>
<h3 id="webappconfiguration"><code>@WebAppConfiguration</code></h3>
<p><code>@WebAppConfiguration</code>是一个类级别的注解，它能将为集成测试声明的<code>ApplicationContext</code>指定为<code>WebApplicationContext</code>。<code>WebAppConfiguration</code>注解仅仅在测试类上存在，为确保<code>WebApplicationContext</code>是为测试加载，使用默认值<code>file:src/main/webapp</code>作为web应用的根路径（资源仓库路径）。资源仓库路径用于在后台创建<code>MockServletContext</code>，它被用作<code>WebApplicationContext</code>的<code>ServletContext</code></p>
<p>下面是如何使用<code>@WebAppConfiguration</code>注解：</p>
<pre><code class="language-java">@ContextConfiguration
@WebAppConfiguration
class WebAppTests{}
</code></pre>
<p>如果你的资源仓库路径不是默认的<code>file:src/main/webapp</code>，你可以指定你自己的资源仓库路径，使用默认的<code>value</code>属性。可以支持<code>classpath:</code>和<code>file:</code>资源前缀。如果没有提供资源前缀，这个路径会被假定位文件系统资源。下面的例子展示了怎样指定一个classpath资源：</p>
<pre><code class="language-java">@ContextConfiguration
@WebAppConfiguration(&quot;classpath:test-web-resources&quot;)
class WebAppTests{}
</code></pre>
<p>注意<code>WebAppConfiguration</code>必须与<code>ContextConfiguration</code>配合使用，不管在单个测试类还是一个测试类的层次结构中。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html">@WebAppConfiguration</a> API文档</p>
<h3 id="contexthierarchy"><code>@ContextHierarchy</code></h3>
<p>它是一个类级别的注解，为集成测试定义<code>ApplicationContext</code>实例的层次结构。<code>@ContextHierarchy</code>应该由一个<code>@ContextConfiguration</code>的实例集合来申明，其中每一个都定义context层级关系中的一级。下面的例子展示了<code>@ContextHierarchy</code>在单个测试类中的的使用（它也可以用在一个测试类的层次结构中）</p>
<pre><code class="language-java">@ContextHierarchy({
    @ContextConfiguration(&quot;/parent-config.xml&quot;),
    @ContextConfiguration(&quot;/child-config.xml&quot;)
})
class ContextHierarchyTests{}
</code></pre>
<pre><code class="language-java">@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests{}
</code></pre>
<p>如果你需要在测试类的层次结构中对指定层级的配置进行合并或者重写，那么需要一个别名值来对应层级，在设置<code>@ContextHierarchy</code>的每个<code>@ContextConfiguration</code>层级时，需要给他们指明参数<code>name</code>的值。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/ContextHierarchy.html"> @ContextHierarchy</a> api文档</p>
<h3 id="activeprofiles"><code>@ActiveProfiles</code></h3>
<p>它是类级别的注解，当为继承测试加载<code>ApplicationContext</code>时用来声明启用哪些bean定义配置文件</p>
<p>下面的例子表示启用了<code>dev</code>配置文件：</p>
<pre><code class="language-java">@ContextConfiguration
@ActiveProfiles(&quot;dev&quot;)
class DeveloperTests{}
</code></pre>
<p>下面的例子表示<code>dev</code>和<code>integration</code>配置文件都应该启用：</p>
<pre><code class="language-java">@ContextConfiguration
@ActiveProfiles({&quot;dev&quot;,&quot;integration&quot;})
class DeveloperIntegrationTests{}
</code></pre>
<blockquote>
<p>默认情况下<code>@ActiveProfiles</code>是支持继承父类或者封闭类的配置信息的。你可以完全自定义解析激活配置文件通过实现<code>ActiveProfilesResolver</code>，并使用<code>@ActiveProfiles</code>的属性<code>resolver</code>来注册。</p>
</blockquote>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a> ,<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration</a> ,以及<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/ActiveProfiles.html">@ActiveProfiles</a></p>
<h3 id="testpropertysource"><code>@TestPropertySource</code></h3>
<p>它是一个类级别的注解，你可以使用它来配置属性文件和内联属性的位置，最后添加到<code>PropertySources</code>集合中，这个集合在<code>ApplicationContext</code>的<code>Environment</code>中。</p>
<p>下面的例子展示了怎样声明一个来自classpath的属性文件:</p>
<pre><code class="language-java">@ContextConfiguration
@TestPropertySource(&quot;/test.properties&quot;)
class MyIntegrationTests{}
</code></pre>
<p>下面的例子展示怎样声明内联属性：</p>
<pre><code class="language-java">@ContextConfiguraiton
@TestPropertySource(properties = {&quot;timezone = GMT&quot;, &quot;port: 4242&quot;})
class MyIntegrationTests{}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></p>
<h3 id="dynamicpropertysource"><code>@DynamicPropertySource</code></h3>
<p>它是一个方法级别的注解，他可以注册动态属性，跟<code>@TestPropertySource</code>一样，也是添加到<code>PropertySources</code>集合中。当你不能提前判断属性值时，可以通过动态属性来设置-举个例子，如果属性是交由外部资源管理的，比如通过<a href="https://www.testcontainers.org/">TestContainers</a> 来进行的容器管理。</p>
<p>下面的例子展示了如何注册一个动态属性：</p>
<pre><code class="language-java">@ContextConfiguration
class MyIntegrationTests{
    static MyExternalServer server = // ...

    @DynamicPropertySource
    static void dynamicProperties(DynamicPropertyRegistry registry){
        registry.add(&quot;server.port&quot;,server::getPort);
    }
}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a></p>
<h3 id="dirtiescontext"><code>@DirtiesContext</code></h3>
<p>这个注解表示底层的Spring<code>ApplicationContext</code>在执行测试的时候被污染了（意思就是，测试的时候以某种方式修改或者污染了<code>ApplicationContext</code>-比如说，改变单例bean的状态），并且需要关闭这个context。当一个应用上下文被dirty标记，会被测试框架从缓存中移除并关闭。在最后，如果还有其他测试需要这个context，Spring容器会重新构建。</p>
<p>你可以使用该注解在类级别或者方法级别，在同一个类中或者类的层次结构中。你可以标记<code>ApplicationContext</code>是在方法前后还是在类前后被污染的，通过<code>methodMode</code>和<code>classMode</code>来配置。</p>
<p>下面的例子展示了几个不同场景的使用方案：</p>
<ul>
<li>在当前的测试类之前，通过声明<code>classMode</code>为<code>BEFORE_CLASS</code></li>
</ul>
<pre><code class="language-java">@DirtiesContext(classMode = BEFORE_CLASS)
class FetchContextTests{}
</code></pre>
<ul>
<li>在当前的测试类之后，通过声明<code>classMode</code>为<code>AFTER_CLASS</code>(默认的classMode)</li>
</ul>
<pre><code class="language-java">@DirtiesContext
class FetchContextTests{}
</code></pre>
<ul>
<li>在当前测试类的每个测试方法之前，通过声明<code>classMode</code>为<code>BEFORE_EACH_TEST_METHOD</code></li>
</ul>
<pre><code class="language-java">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD)
class FreshContextTests{
}
</code></pre>
<ul>
<li>在当前测试类的每个测试方法执行后，通过声明<code>classMode</code>为<code>AFTER_EACH_TEST_METHOD</code></li>
</ul>
<pre><code class="language-java">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD)
class ContextDirtyingTests{}
</code></pre>
<ul>
<li>在当前测试之前，通过在方法上申明<code>methodMode</code>为<code>BEFORE_METHOD</code></li>
</ul>
<pre><code class="language-java">@Test
@DirtiesContext(methodMode = BEFORE_METHOD)
void testProcessWhichRequiresFreshAppCtx(){}
</code></pre>
<ul>
<li>在当前测试之后，通过在方法上声明<code>methodMode</code>为<code>AFTER_METHOD</code>(默认的方法模式)</li>
</ul>
<pre><code class="language-java">@DirtiesContext
@Test
void testProcessWhichDirtiesAppCtx(){}
</code></pre>
<p>如果<code>@DirtiesContext</code>注解修饰的测试context，是<code>@ContextHierarchy</code>注解层次结构中的一部分，你可以使用<code>hierarchyMode</code>属性去控制context缓存如何清除。默认情况下，一个详尽的算法会用来清除context缓存，包括的不仅是当前层级，还有所有其他共享了同一个父类context的子层级，子层级的所有<code>ApplicationContext</code>实例都会从缓存中移除并关闭。在某些情况下，如果你觉得默认的算法清楚的范围太广，你可以指定更简单的当前层级算法：</p>
<pre><code class="language-java">@ContextHierarchy({
    @ContextConfiguration(&quot;/parent-config.xml&quot;),
    @ContextConfiguration(&quot;/child-config.xml&quot;)
})
class BaseTest{}

class ExtendedTests extends BaseTest{
    @Test
    @DirtiesContext(hierarchyMode=CURRENT_LEVEL)
    void test(){}
}
</code></pre>
<p>更多关于<code>EXHAUSTIVE</code>和<code>CURRENT_LEVEL</code>算法的问题，可以参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html">DirtiesContext.HierarchyMode</a></p>
<h3 id="testexecutionlisteners"><code>@TestExecutionListeners</code></h3>
<p>它定义了用来配置<code>TestExecutionListener</code>实现的类级别元数据(<code>TestExecutionListener</code>实现是由<code>TestContextManager</code>来注册的)。一般来说都是配合<code>@ContextConfiguration</code>来使用。</p>
<p>下面的例子展示了如何注册两个<code>TestExecutionListener</code>实现</p>
<pre><code class="language-java">@ContextConfiguration
@TestExecutionListeners({CustonTestExecutionListener.class,AnotherTestExecutionListerner.class})
class CustomTestExecutionListenerTests {}
</code></pre>
<p>默认情况下，<code>@TestExecutionListeners</code>是支持从父类继承的，或者内部类从外部封闭类继承。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">@TestExecutionListeners javadoc</a></p>
<h3 id="commit"><code>@Commit</code></h3>
<p><code>@Commit</code>代表测试方法的事务会在测试方法完成后提交。你可以将<code>@Commit</code>替换为<code>@Rollback(false)</code>。<code>@Commit</code>和<code>@Rollback</code>相似，都可以声明在类或方法上。</p>
<p>使用实例：</p>
<pre><code class="language-java">@Commit
@Test
void testProcessWithoutRollback(){
}
</code></pre>
<h3 id="rollback"><code>@Rollback</code></h3>
<p><code>@Rollback</code>代表测试方法执行完后，是否回滚事务。为true则回滚，否则事务会提交（跟<code>@Commit</code>一样）。该注解的默认值为true，就算没有声明该注解，事务默认也会回滚。</p>
<p>当申明在类上时，<code>@Rollback</code>注解将会影响类的所有测试方法，当申明在方法时，只会影响指定方法，并会覆盖类上的全局<code>@Rollback</code>或<code>@Commit</code>配置</p>
<p>使用实例：</p>
<pre><code class="language-java">@Test
@Rollback(false)
void testProcessWithoutRollback(){
}
</code></pre>
<h3 id="beforetransaction"><code>@BeforeTransaction</code></h3>
<p>它代表注解的<code>void</code>方法应该在事务启动之前运行，对测试方法来说，它已经被配置好了在一个事务中运行，是通过使用Spring的<code>@Transactional</code>注解来实现的。<code>@BeforeTransaction</code>方法是不需要<code>public</code>修饰的，并且可以声明在java8的接口默认方法上。</p>
<p>使用实例：</p>
<pre><code class="language-java">@BeforeTransaction
void beforeTransaction(){}
</code></pre>
<h3 id="aftertransaction"><code>@AfterTransaction</code></h3>
<p>它代表注解的<code>void</code>方法应该在事务结束后运行，对测试方法来说，它已经被配置好了在一个事务中运行，是通过使用Spring的<code>@Transactional</code>注解来实现的。<code>@AfterTransaction</code>方法是不需要<code>public</code>修饰的，并且可以声明在java8的接口默认方法上。</p>
<pre><code class="language-java">@AfterTransaction
void afterTransaction(){}
</code></pre>
<h3 id="sql"><code>@Sql</code></h3>
<p>它是用来配置测试类或者方法需要的sql脚本的。</p>
<pre><code class="language-java">@Test
@Sql({&quot;/test-schema.sql&quot;,&quot;/test-user-data.sql&quot;})
void userTest(){}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a></p>
<h3 id="sqlconfig"><code>@SqlConfig</code></h3>
<p>它用来配置如何解析和执行<code>@Sql</code>注解配置的脚本。</p>
<pre><code class="language-java">@Test
@Sql(
    scripts = &quot;/test-user-data.sql&quot;,
    config = @SqlConfig(commentPrefix = &quot;`&quot;, separator = &quot;@@&quot;)
)
void userTest(){}
</code></pre>
<h3 id="sqlmergemode"><code>@SqlMergeMode</code></h3>
<p>它是用来设置<code>@Sql</code>注解的方法和类的sql脚本是否融合在一起。如果类和方法上都没有<code>@SqlMergeMode</code>注解，那么默认的<code>OVERRIDE</code>模式将会被使用。在<code>OVERRIDE</code>模式下，方法上声明的<code>@Sql</code>会覆盖掉类上的<code>@Sql</code>声明。</p>
<p>注意方法上的<code>@SqlMergeMode</code>声明会覆盖类上的声明。</p>
<p>作用在类上：</p>
<pre><code class="language-java">@SpringJunitConfig(TestConfig.class)
@Sql(&quot;/test-schema.sql&quot;)
@SqlMergeMode
class UserTests{
    @Test
    @Sql(&quot;/user-test-data-001.sql&quot;)
    void standardUserProfile(){
    }
}
</code></pre>
<p>作用在方法上：</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
@Sql(&quot;/test-schema.sql&quot;)
class UserTests{
    @Test
    @Sql(&quot;/user-test-data-001.sql&quot;)
    @SqlMergeMode(MERGE)
    void standardUserProfile(){}
}
</code></pre>
<h3 id="sqlgroup"><code>@SqlGroup</code></h3>
<p>它是一个容器注解，内部集成了多个<code>@Sql</code>注解。你可以使用<code>@SqlGroup</code>直接声明多个集成的<code>@Sql</code>，或者你可以配合java8对重复注解的支持来使用，<code>@Sql</code>可以在同一个类和方法上声明多次，隐式的生成注解容器。</p>
<pre><code class="language-java">@Test
@SqlGroup({
    @Sql(scripts = &quot;/test-schema.sql&quot;,config = @SqlConfig(commentPrefix = &quot;`&quot;)),
    @Sql(&quot;/test-user-data.sql&quot;)
})
void userTest(){}
</code></pre>
<h2 id="42-标准注解支持">4.2. 标准注解支持</h2>
<p>下面的注解在任何配置的Spring TestContext框架的标准语法中都支持。注意这些注解并不是专门用来测试的，在Spring框架的任何地方都可以使用。</p>
<ul>
<li><code>@Autowired</code></li>
<li><code>@Qualifier</code></li>
<li><code>@Value</code></li>
<li><code>@Resource</code>(javax.annotation)如果JSR-250存在</li>
<li><code>@ManagedBean</code>(javax.annotation)如果JSR-250存在</li>
<li><code>@Inject</code>(javax.inject)如果JSR-330存在</li>
<li><code>@Named</code>(javax.inject)如果JSR-330存在</li>
<li><code>@PersistenceContext</code>(javax.persistence)如果JPA存在</li>
<li><code>@PersistenceUnit</code>(javax.persistence)如果JPA存在</li>
<li><code>@Required</code></li>
<li><code>@Transactional</code>(org.springframework.transaction.annotation)<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tx-attribute-support">部分属性支持</a></li>
</ul>
<blockquote>
<p>JSR-250生命周期注解<br>
在Spring TestContext框架中，你可以在<code>ApplicationContext</code>内部配置的任何应用组件上以标准语法使用<code>@PostConstruct</code>和<code>@PreDestroy</code>。但是在实际测试类中，这些生命周期注解还是有使用限制的。</p>
<p>如果一个方法在测试类中，并且被注解<code>@PostConstruct</code>修饰，那么这个方法会在底层测试框架的所有before方法之前执行（举个例子，任何被JUnit Jupiter的<code>@BeforeEach</code>注解修饰的方法），并且他会被应用在测试类中的每个测试方法上。另一方面，如果一个方法在测试类中被<code>@PreDestroy</code>注解修饰，那么这个方法永远不会运行。所以，在一个测试类中，我们推荐使用来自测试框架的生命周期的回调函数，而不是<code>@PostConstruct</code>和<code>@PreDestroy</code>。</p>
</blockquote>
<h2 id="43-spring-junit-4-测试注解">4.3. Spring JUnit 4 测试注解</h2>
<p>下面的注解仅在与 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit4-runner">SpringRunner</a> ，<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit4-rules">Spring&rsquo;s JUnit 4 rules</a> ,或者<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-support-classes-junit4">Spring’s JUnit 4 support classes</a> 配合使用时才有效：</p>
<ul>
<li><code>@IfProfileValue</code></li>
<li><code>@ProfileValueSourceConfiguration</code></li>
<li><code>@Timed</code></li>
<li><code>@Repeat</code></li>
</ul>
<h3 id="ifprofilevalue"><code>IfProfileValue</code></h3>
<p>它代表注解修饰的测试只在指定测试环境生效。如果<code>ProfileValueSource</code>的属性<code>value</code>跟<code>name</code>的值匹配，这个测试才生效。否则，这个测试不会启用。</p>
<p>你可以声明<code>IfProfileValue</code>在类或者方法上。类级别的使用优先于方法级别的使用，特别是针对类下的所有方法或者所有子类的时候。要启用一个测试，他的类和方法都要是启用状态，但是在默认没有声明<code>IfProfileValue</code>的情况下，就代表着启用状态。JUnit4的<code>@Ignore</code>注解跟它类似，除了<code>@Ignore</code>只能用来屏蔽测试。</p>
<p>使用实例：</p>
<pre><code class="language-java">@IfProfileValue(name = &quot;java.vendor&quot;, value=&quot;Oracle Corporation&quot;)
@Test
public void testProcessWithRunsOnlyOnOracleJvm(){}
</code></pre>
<p>另外，你可以为<code>@IfProfileValue</code>配置一个<code>values</code>集合，就像TestNG在JUnit4环境支持测试组一样：</p>
<pre><code class="language-java">@Test
@IfProfileValue(name = &quot;test-groups&quot;, values={&quot;unit-tests&quot;,&quot;integration-tests&quot;})
public void testProcessWhichRunsForUnitOrIntegrationTestGroups(){}
</code></pre>
<h3 id="profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></h3>
<p>它是一个类级别的注解，它指定了当通过<code>@IfProfileValue</code>注解检索配置值的时候该使用什么类型的<code>ProfileValueSource</code>。如果该注解没有在测试上声明，<code>SystemProfileValueSource</code>会被作为默认值。</p>
<p>使用实例：</p>
<pre><code class="language-java">@Test
@ProfileValueSourceConfiguration(CustomProfileValueSource.class)
public class CustomProfileValueSourceTests(){}
</code></pre>
<h3 id="timed"><code>@Timed</code></h3>
<p><code>@Timed</code>代表备注接的测试方法必须在指定的时间段内完成（微秒）。如果测试时间超过了指定的时间段，则测试失败。</p>
<p>这个时间段包括运行测试方法自身的时间，以及重复测试的时间（<code>@Repeat</code>)，也包括其他测试资源的安装和卸载时间。</p>
<pre><code class="language-java">@Timed(millis = 1000)
public void testProcessWithOneSecondTimeout(){
}
</code></pre>
<p>Spring的<code>@Timed</code>语法跟JUnit4的语法<code>@Test(timeout=...)</code>不同，是因为JUnit4处理测试执行超时的处理方式（在单独的一个分支执行测试方法），如果测试超时<code>@Test(timeout=...)</code>会立即让测试失败。但Spring的<code>@Timed</code>不同，在标识失败之前，他会让测试方法先走完。</p>
<h3 id="repeat"><code>@Repeat</code></h3>
<p>它代表注解的测试方法必定会重复执行。重复执行的次数需要指定在注解参数中</p>
<p>除了重复执行测试方法本身，测试资源的安装和卸载也会被重复执行。</p>
<pre><code class="language-java">@Repeat(10)
@Test
public void testProcessRepeatedly(){}
</code></pre>
<h2 id="44-spring-junit-jupiter-测试注解">4.4. Spring JUnit Jupiter 测试注解</h2>
<p>下面的注解只在配合<code>SpringExtension</code>和JUnit Jupiter(也就是JUnit5的编程模型)使用时才可用</p>
<ul>
<li><code>@SpringJUnitConfig</code></li>
<li><code>@SpringJUnitWebConfig</code></li>
<li><code>@TestConstructor</code></li>
<li><code>@NestedTestConfiguration</code></li>
<li><code>@EnabledIf</code></li>
<li><code>@DisabledIf</code></li>
</ul>
<h3 id="springjunitconfig"><code>@SpringJUnitConfig</code></h3>
<p>它是一个集成的注解，他是由来自JUnit Jupiter的<code>@ExtendWith(SpringExtension.class)</code>和来自Spring TestContext框架的<code>@ContextConfiguration</code>组成的。他可以作用在类上以替代<code>@ContextConfiguration</code>。关于配置选项，<code>@ContextConfiguration</code>和<code>@SpringJUnitConfig</code>唯一的区别是在<code>@SpringJUnitConfig</code>可以用<code>value</code>属性声明组件类。</p>
<p>下面的例子展示了如何使用<code>@SpringJUnitConfig</code>注解指定一个配置类：</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
class ConfigurationClassJUnitJupiterSpringTests{
}
</code></pre>
<p>下面的例子展示了如何使用<code>@SpringJUnitConfig</code>注解指定一个配置文件的位置：</p>
<pre><code class="language-java">@SpringJUnitConfig(locations = &quot;/test-config.xml&quot;)
class XmlJUnitJupiterSpringTests{
}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management">Context Management</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html">@SpringJUnitConfig</a> ，<code>@ContextConfiguration</code>的API文档</p>
<h3 id="springjunitwebconfig"><code>@SpringJUnitWebConfig</code></h3>
<p>它是一个复合注解，是由来自JUnit Jupiter的<code>@ExtendWith(SprintExtension.class)</code>与来自Spring TestContext框架的<code>ContextConfiguration</code>、<code>@WebAppConfiguration</code>构成。你可以将他申明在类上，它可以用来代替<code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code>。关于配置选项，<code>@ContextConfiguration</code>和<code>@SpringJUnitWebConfig</code>的唯一区别是<code>@SpringJUnitWebConfig</code>可以同使用<code>value</code>属性来声明组件类。另外你可以覆盖<code>@WebAppConfiguration</code>的<code>value</code>属性，通过<code>@SpringJUnitWebConfig</code>的<code>resourcePath</code>属性。</p>
<p>下面的例子展示了如何指定一个配置类：</p>
<pre><code class="language-java">@SpringJUnitWebConfig(TestConfig.class)
class ConfigurationClassJUnitJupiterSpringWebTests{}
</code></pre>
<p>下面的例子展示了如何指定一个配置文件的路径：</p>
<pre><code class="language-java">@SpringJUnitWebConfig(locations = &quot;/test-config.xml&quot;)
class XmlJUnitJupiterSpringWebTests{}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management">Context Management</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html">@SpringJUnitWebConfig</a> ，<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/ContextConfiguration.html">@ContextConfiguration</a> ，<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html">@WebAppConfiguration</a></p>
<h3 id="testconstructor">TestConstructor</h3>
<p>它是一个类级别的注解，用来配置如何将测试的<code>ApplicationContext</code>组件参数装配到测试类构造方法的参数中。</p>
<p>如果<code>@TestConstructor</code>不存在，那么会有一个默认的装配模式被使用。下面的提示展示了如何改变默认模式。注意，如果构造器上有一个<code>@Autowired</code>注解，那么<code>@TestConstructor</code>和默认模式都会被覆盖。</p>
<blockquote>
<p><strong>改变测试构造方法的默认装配模式</strong>
要改变默认的装配模式可以通过设置<code>spring.test.constructor.autowire.mode</code>JVM 系统属性为<code>all</code>。还可以通过设置<code>SpringProperties</code>机制来完成。</p>
<p>在Spring Framework 5.3，默认模式可以设置为一个<a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-config-params">JUnit Platform configuration parameter</a></p>
<p>如果<code>spring.test.constructor.autowire.mode</code>属性没有设置，那么测试类的构造函数将不会自动装配</p>
</blockquote>
<blockquote>
<p>在Spring Framework 5.2，在使用JUnit Jupiter时<code>TestConstructor</code>只能和<code>SpringExtension</code>配合使用。注意在大多数境况下，<code>SpringExtension</code>已经为你自动注册完成了-比如在用了<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>或者各种来自Spring Boot测试相关的注解时</p>
</blockquote>
<h3 id="nestedtestconfiguration"><code>@NestedTestConfiguration</code></h3>
<p>它是一个类级别的注解，被用来设置Spring测试配置注解如何在内部测试类中运行。</p>
<p>如果它没有在测试类显性申明，在他的父类结构，或者在他的封闭类结构中，默认的封闭配置继承模型会被使用。下面的提示展示如何修改默认模式。</p>
<blockquote>
<p><strong>改变默认的封闭配置继承模式</strong><br>
默认的封闭配置继承模式是<code>INHERIT</code>，要改变默认的模式可以通过设置<code>spring.test.enclosing.configuration</code>JVM系统属性为<code>OVERRIDE</code>.还可以通过<code>SpringProperties</code>机制来改变</p>
</blockquote>
<p>支持<code>@NestedTestConfiguration</code>语法的Spring测试框架注解：</p>
<ul>
<li><code>@BootstrapWith</code></li>
<li><code>@ContextConfiguration</code></li>
<li><code>@WebAppConfiguration</code></li>
<li><code>@ContextHierarchy</code></li>
<li><code>@ActiveProfiles</code></li>
<li><code>@TestPropertySource</code></li>
<li><code>@DiritesContext</code></li>
<li><code>@TestExecutionListeners</code></li>
<li><code>@Transactional</code></li>
<li><code>@Commit</code></li>
<li><code>@Rollback</code></li>
<li><code>@Sql</code></li>
<li><code>@SqlConfig</code></li>
<li><code>@SqlMergeMode</code></li>
<li><code>@TestContructor</code></li>
</ul>
<blockquote>
<p>通常情况下<code>@NestedTestConfiguration</code>注解需要和<code>@Nested</code>注解结合使用在JUnit Jupiter中才有意义；但是可能有其他Spring支持的测试框架和继承测试类使用了该注解。</p>
</blockquote>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration </a></p>
<h3 id="enabledif"><code>@EnabledIf</code></h3>
<p>它表示它修饰的JUnit Jupiter类或者测试方法是否启用，由提供的<code>expression</code>结果决定。具体来说，如果一个表达式的计算结果是<code>Boolean.TRUE</code>或者一个<code>String</code>equal为<code>true</code>(忽略大小写)，这个测试就是启用的。当应用于类级别时，所有在该类中的测试方法都会默认启用。</p>
<p>以下的表达式都可用：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions">Spring Expression Language</a> 。举个例子：<code>@EnabledIf(&quot;#{systemProperties\['os.name'].toLowerCase().contains('mac')}&quot;)</code></li>
<li>Spring <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment">Environment</a> 中可用的属性占位符。举个例子：<code>@EnabledIf(&quot;${smoke.tests.enabled}&quot;)</code></li>
<li>文本。比如：<code>@EnabledIf(&quot;true&quot;)</code></li>
</ul>
<p>注意文本表达式如果不是动态的属性占位符的解析结果，那将没有任何意义，因为<code>@EnableIf(&quot;false&quot;)</code>等于<code>@Disabled</code>，并且<code>@EnabledIf(&quot;true&quot;)</code>也没有任何意义。</p>
<p>你可以将<code>@EnabledIf</code>作为一个元注解去创建自定义的复合注解。比如，你可以创建一个自定义的<code>@EnabledOnMac</code>注解：</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = &quot;#{systemProperties['os.name'].toLowerCase().contains('mac')}&quot;,
    reason = &quot;Enabled on Mac OS&quot;
)
public @interface EnabledOnMac{}
</code></pre>
<h3 id="disabledif"><code>@DisabledIf</code></h3>
<p>它表示它修饰的JUnit Jupiter类或者测试方法是否弃用，由提供的<code>expression</code>结果决定。具体来说，如果一个表达式的计算结果是<code>Boolean.TRUE</code>或者一个<code>String</code>equal为<code>true</code>(忽略大小写)，这个测试就是弃用的。当应用于类级别时，所有在该类中的测试方法都会默认弃用。</p>
<p>以下的表达式都可用：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions">Spring Expression Language</a> 。举个例子：<code>@DisabledIf(&quot;#{systemProperties\['os.name'].toLowerCase().contains('mac')}&quot;)</code></li>
<li>Spring <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment">Environment</a> 中可用的属性占位符。举个例子：<code>@DisabledIf(&quot;${smoke.tests.enabled}&quot;)</code></li>
<li>文本。比如：<code>@DisabledIf(&quot;true&quot;)</code></li>
</ul>
<p>注意文本表达式如果不是动态的属性占位符的解析结果，那将没有任何意义，因为<code>@DisabledIf(&quot;true&quot;)</code>等于<code>@Disabled</code>，并且<code>@EnabledIf(&quot;false&quot;)</code>也没有任何意义。</p>
<p>你可以将<code>@DisabledIf</code>作为一个元注解去创建自定义的复合注解。比如，你可以创建一个自定义的<code>@DisabledOnMac</code>注解：</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = &quot;#{systemProperties['os.name'].toLowerCase().contains('mac')}&quot;,
    reason = &quot;Disabled on Mac OS&quot;
)
public @interface DisabledOnMac {}
</code></pre>
<h2 id="45-测试元注解">4.5. 测试元注解</h2>
<p>你可以使用大多数测试相关的注解作为元注解去创建自定义的复合注解，那样可以减少测试套件的重复配置。</p>
<p>你可以使用下面任何一个注解作为元注解：</p>
<ul>
<li>@BootstrapWith</li>
<li>@ContextConfiguration</li>
<li>@ContextHierarchy</li>
<li>@ActiveProfiles</li>
<li>@TestPropertySource</li>
<li>@DirtiesContext</li>
<li>@WebAppConfiguration</li>
<li>@TestExecutionListeners</li>
<li>@Transactional</li>
<li>@BeforeTransaction</li>
<li>@AfterTransaction</li>
<li>@Commit</li>
<li>@Rollback</li>
<li>@Sql</li>
<li>@SqlConfig</li>
<li>@SqlMergeMode</li>
<li>@SqlGroup</li>
<li>@Repeat (only supported on JUnit 4)</li>
<li>@Timed (only supported on JUnit 4)</li>
<li>@IfProfileValue (only supported on JUnit 4)</li>
<li>@ProfileValueSourceConfiguration (only supported on JUnit 4)</li>
<li>@SpringJUnitConfig (only supported on JUnit Jupiter)</li>
<li>@SpringJUnitWebConfig (only supported on JUnit Jupiter)</li>
<li>@TestConstructor (only supported on JUnit Jupiter)</li>
<li>@NestedTestConfiguration (only supported on JUnit Jupiter)</li>
<li>@EnabledIf (only supported on JUnit Jupiter)</li>
<li>@DisabledIf (only supported on JUnit Jupiter)</li>
</ul>
<p>考虑下面的例子：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@ContextConfiguration({&quot;/app-config.xml&quot;,&quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public class OrderRepositoryTests{}

@RunWith(SpringRunner.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public class UserRepositoryTests{}
</code></pre>
<p>观察上面的Spring测试注解配置基本都是重复的，可以通过自定义注解合并他们：</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public @interface TransactionalDevTestConfig {}
</code></pre>
<p>然后你就可以直接使用这个自定义注解去简化JUnit4为基础的测试类：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class OrderRepositoryTests{}

@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class UserRepositoryTests {}
</code></pre>
<p>如果我们使用JUnit Jupiter进行测试类编写，那么可以进一步减少重复代码，因为JUnit 5的注解同样可以作为元注解：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
class OrderRepositoryTest{}

@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
class UserRepositoryTests{}
</code></pre>
<p>观察上面的Spring测试注解配置基本都是重复的，可以通过自定义注解合并他们：</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public @interface TransactionalDevTestConfig { }
</code></pre>
<p>然后你就可以直接使用这个自定义注解去简化JUnit5为基础的测试类：</p>
<pre><code class="language-java">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }
</code></pre>
<p>因为JUnit Jupiter支持<code>@Test</code>,<code>@RepeatedTest</code>,<code>ParameterizedTest</code>等等作为源注解，所以你也可以创建基于方法级别的自定义复合注解，比如我们创建一个注解它结合了来自JUnit Jupiter的<code>@Test</code>，<code>@Tag</code>和来自Spring的<code>@Transactional</code>：</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Tag(&quot;integration-test&quot;) // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
public @interface TransactionalIntegrationTest {
}
</code></pre>
<p>然后我们可以在任何JUnit Jupiter测试方法上使用它们：</p>
<pre><code class="language-java">@TransactionalIntegrationTest
void saveOrder() { }

@TransactionalIntegrationTest
void deleteOrder() { }
</code></pre>
<p>详情参考<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a></p>
<h1 id="5-spring-testcontext-framework">5. Spring TestContext Framework</h1>
<p>Spring TestContext Framework(在<code>org.springframework.test.context</code>包下)，提供了通用的，注解驱动的单元和集成测试，并且不跟你的测试框架耦合。TestContext framework更看重约定而不是配置，有合理的默认值，并且你可以通过注解参数来修改它。</p>
<p>另外对于常见的测试架构：JUnit 4，JUnit Jupiter(JUnit 5)，和TestNG，TestContext framework提供了特定的支持。对于JUnit4和TestNG，spring提供了<code>abstract</code>支持类。此外，Spring为JUnit4提供了自定义JUnit<code>Runner</code>和自定义JUnit<code>Rules</code>，并且为JUnit Jupiter提供了自定义的<code>Extension</code>，它们可以让你编写所谓的POJO测试类。POJO测试类就是测试类不需要继承一个特定的类结构，比如<code>abstarct</code>父类。</p>
<p>下面的章节提供了一个TestContext framework的概览。如果你只对使用框架有兴趣，对扩展自定义监听或者自定义加载器不感兴趣的话，可以直接跳过这个章节。</p>
<h2 id="51-关键抽象概念">5.1. 关键抽象概念</h2>
<p>框架的核心是由<code>TestContextManager</code>、<code>TestContext</code>、<code>TestExecutionListener</code>、和<code>SmartContextLoader</code>接口组成。每个测试类都会创建一个<code>TestContextManager</code>。反过来，<code>TestContextManger</code>管理着一个<code>TestContext</code>，这个<code>TestContext</code>保存着当前测试的上下文参数。在测试进行中<code>TestContextManger</code>同时也更新<code>TestContext</code>的状态，并且委托给<code>TestExecutionListener</code>的实现，它会通过依赖注入来检测实际测试的运行，管理事务等等。一个<code>SmartContextLoader</code>负责为一个给定的测试类加载<code>ApplicationContext</code>。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/package-summary.html">javadoc</a></p>
<h3 id="testcontext"><code>TestContext</code></h3>
<p><code>TestContext</code>封装了测试运行所在的上下文（忽略具体的测试框架）并为其所负责的测试实例提供上下文管理和缓存支持。<code>TestContext</code>还能委托<code>SmarkContextLoader</code>去加载<code>ApplicationContext</code>。</p>
<h3 id="testcontextmanager"><code>TestContextManager</code></h3>
<p><code>TestContextManger</code>是Spring TestContext Framework的主要切入点，它负责管理一个单独的<code>TestContext</code>并且给每个已经注册的<code>TestExcutionListener</code>在以下定义良好的测试执行点发送信号：</p>
<ul>
<li>在任何&quot;before class&quot;或者&quot;before all&quot;方法之前</li>
<li>测试实例的后期处理</li>
<li>在任何&quot;before&quot;或者&quot;before each&quot;方法之前</li>
<li>在测试方法执行之前但在测试初始化之后</li>
<li>在测试方法执行之后但在测试销毁之前</li>
<li>在任何&quot;after&quot;或者&quot;after each&quot;方法执行之后</li>
<li>在任何&quot;after class&quot;或者&quot;after all&quot;方法执行之后</li>
</ul>
<h3 id="testexecutionlistener"><code>TestExecutionListener</code></h3>
<p><code>TestExecutionListener</code>定义了一系列测试监听API，它们又<code>TestContextManager</code>注册和发布。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tel-config">TestExecutionListener Configuration</a></p>
<h3 id="contextloaders"><code>ContextLoaders</code></h3>
<p><code>ContextLoaders</code>是一个策略接口为一个Spring TestContext Framework管理的集成测试加载一个<code>ApplicationContext</code>。要提供组件类，激活bean定义配置，测试属性资源，上下文结构，和<code>WebApplicationContext</code>的支持你应该实现<code>SmartContextLoader</code>而不是这个接口。</p>
<p><code>SmartContextLoader</code>是<code>ContextLoader</code>接口的扩展，它接替了原始<code>ContextLoader</code>极少的SPI。具体来说，一个<code>SmartContextLoader</code>可以选择去处理资源位置，组件类，或者上下文初始化。其次，一个<code>SmartContextLoader</code>可以设置启用bean定义配置和上下文加载的测试属性资源。</p>
<p>Spring提供了下面的实现：</p>
<ul>
<li><code>DelegatingSmartContextLoader</code>：两个默认加载器之一，它委托给内部的一个<code>AnnotationConfigContextLoader</code>，一个<code>GenericXmlContextLoader</code>，或者一个<code>GenericGroovyXmlContextLoader</code>，取决于测试类的配置声明，或者存在的默认位置或者默认配置类。Groovy支持只在classpath目录下有Groovy时才可用。</li>
<li><code>WebDelegatingSmartContextLoader</code>:两个默认加载器之一,它委托给内部的一个<code>AnnotationConfigWebContextLoader</code>，一个<code>GenericXmlWebContextLoader</code>，或者一个<code>GenericGroovyXmlWebContextLoader</code>，取决于测试类的配置声明，或者存在的默认位置或者默认配置类。只有在测试类上有<code>@WebAppConfiguration</code>存在时，才能使用web<code>ContextLoader</code>。Groovy支持只在classpath目录下有Groovy时才可用。</li>
<li><code>AnnotationConfigContextLoader</code>:用组件类加载一个标准的<code>ApplicationContext</code></li>
<li><code>AnnotationConfigWebContextLoader</code>:用组件类加载一个<code>WebApplicationContext</code></li>
<li><code>GenericGroovyXmlContextLoader</code>:用Groovy脚本或者XML配置文件加载一个标准的<code>ApplicationContext</code></li>
<li><code>GenericGroovyXmlWebContextLoader</code>:用Groovy脚本或者XML配置文件加载一个<code>WebApplicationContext</code></li>
<li><code>GenericXmlContextLoader</code>:用XML资源地址加载一个标准的<code>ApplicationContext</code></li>
<li><code>GenericXmlWebContextLoader</code>:用XML资源地址加载一个<code>WepApplicationContext</code></li>
</ul>
<h2 id="52-引导testcontext-framework">5.2. 引导TestContext Framework</h2>
<p>Spring TestContext Framework内部的默认配置对于一般的使用情况已经足够了。但是，有时开发团队或者第三方框架想改变默认的<code>ContextLoader</code>，实现自定义的<code>TestContext</code>或者<code>ContextCache</code>，增加默认的<code>ContextCustomizerFactory</code>和<code>TestExecutionListener</code>实现集合等等操作。对于这种对TestContext 框架操作的底层的控制，Spring提供了一个引导策略。</p>
<p><code>TestContextBootstrapper</code>为TestContext框架定义了SPI。一个<code>TestContextBootstrapper</code>通过<code>TextContextManager</code>被用来为当前测试加载<code>TestExecutionListener</code>实现和构建他管理的<code>TestContext</code>。你可以通过<code>@BootstrapWith</code>为测试类（或者测试类结构）配置一个自定义的引导策略，可以直接使用<code>@BootstrapWith</code>或者把它作为一个元注解.如果没有显式的指定<code>@BootstrapWith</code>，默认情况下使用<code>DefaultTestContextBootstrapper</code>或者<code>WebTestContextBootstrapper</code>，取决于<code>@WebAppConfiguration</code>是否存在</p>
<p>因为<code>TestContextBootstrapper</code>SPI很可能在未来更改(去适应新需求),我们强烈建议继承<code>AbstractTestContextBootstrapper</code>类或者他的某个具体的字类,而不是实现<code>TestContextBootstrapper</code>这个接口</p>
<h2 id="53-testexecutionlistener配置">5.3. <code>TestExecutionListener</code>配置</h2>
<p>Spring提供了下面的<code>TestExecutionListener</code>实现，他们是被默认注册的，按照下面的顺序：</p>
<ul>
<li><code>ServletTestExecutionListener</code>:为<code>WebApplicationContext</code>配置Servlet API模拟。</li>
<li><code>DirtiesContextBeforeModesTestExecutionListener</code>:为&quot;before&quot;模式处理<code>@DirtiesContext</code>注解。</li>
<li><code>DependencyInjectionTestExecutionListener</code>:为测试实例提供依赖注入.</li>
<li><code>DirtiesContextTestExecutionListener</code>:为&quot;after&quot;模式处理<code>@DirtiesContext</code>注解。</li>
<li><code>TransactionalTestExecutionListener</code>:提供默认的rollback的事务测试执行。</li>
<li><code>SqlScriptsTestExecutionListener</code>:使用<code>@Sql</code>注解时运行配置的SQL脚本.</li>
<li><code>EventPublishingTestExecutionListener</code>:为测试的<code>ApplicationContext</code>发布测试执行事件(参照<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-test-execution-events">Test Execution Events</a>)  。</li>
</ul>
<h3 id="注册testexecutionlistener实现">注册<code>TestExecutionListener</code>实现</h3>
<p>你可以为测试类和其字类注册<code>TestExecutionListener</code>实现通过使用<code>@TestExecutionListeners</code>注解。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations">annotation support</a> ,<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">@TestExecutionListeners</a></p>
<h3 id="自动化探索默认的testexecutionlistener实现">自动化探索默认的<code>TestExecutionListener</code>实现</h3>
<p>通过使用<code>@TestExecutionListeners</code>来注册<code>TestExecutionListener</code>实现,适合有限测试方案的自定义监听器。如果自定义监听器要跨越整个测试套件,那么他就会变得十分臃肿。解决这个问题需要通过支持自动探索默认的<code>TestExecutionListener</code>实现来完成，背后依靠<code>SpringFactoriesLoader</code>机制来实现。</p>
<p>具体来说，<code>spring-test</code>模块申明所有的核心默认<code>TestExecutionListener</code>实现都在<code>META-INF/spring.factories</code>属性文件中的<code>org.springframework.test.context.TestExecutionListener</code>key下。第三方框架和开发者可以贡献他们自己的<code>TestExecutionListener</code>到默认的监听者列表，同样通过<code>META-INF/spring.factories</code>属性文件。</p>
<h3 id="testexecutionlistener实现的顺序"><code>TestExecutionListener</code>实现的顺序</h3>
<p>当TestContext框架发现了默认的<code>TesetExecutionListener</code>实现通过前面提到的SpringFactoriesLoader机制，这些初始化的监听器通过spring的<code>AnnotationAwareOrderComparator</code>来排序，而它又使用Spring的<code>Ordered</code>接口和<code>@Order</code>注解来排序。<code>AbstractTestExecutionListener</code>和所有默认的<code>TestExecutionListener</code>都以适当的值实现了<code>Ordered</code>。所以第三方框架和开发者应该确保他们的默认<code>TestExecutionListener</code>实现是是implements<code>Ordered</code>的或者由<code>@Order</code>注解。通过<code>TestExecutionListener</code>实现的<code>getOrder()</code>方法来查看核心监听器的顺序值。</p>
<h3 id="合并testexecutionlistener实现">合并<code>TestExecutionListener</code>实现</h3>
<p>如果一个自定义<code>TestExecutionListener</code>是通过<code>@TestExecutionListeners</code>注册的，那么默认的监听器将不会被注册。在大多数测试场景中，这会强制要求开发者手动申明所有默认的监听器加上用户自定义的监听器：</p>
<pre><code class="language-java">@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}
</code></pre>
<p>这种方法带来的挑战是，你必须要记得所有的默认监听器。并且每个发布版本的监听器可能改变-举个例子<code>SqlScriptsTestExecutionListener</code>是在Spring Framework 4.1引入的，而<code>DirtiesContextBeforeModesTestExecutionListener</code>实在Spring Framework 4.2引入的。此外，第三方框架比如Spring Boot和Spring Security通过前面提到的<code>automatic discovery mechanism</code>注册了他们自己的默认<code>TestExecutionListener</code>实现。</p>
<p>为了避免记住和重新声明所有默认的监听器，你可以设置<code>@TestExecutionListeners</code>的<code>mergeMode</code>属性为<code>MergeMode.MERGE_WITH_DEFAULTS</code>。这个属性值表实本地申明的监听器应该和默认监听器合并。这个合并算法会移除重复的申明，并且会根据<code>AnnotationAwareOrderComparator</code>排序。如果监听器实现了<code>Ordered</code>或者由<code>@Order</code>注解修饰，那么它可以影响默认监听器的排序。否则，本地声明的监听器会追加到默认监听器列表的末尾。</p>
<p>举个例子，如果<code>MyCustomTestExecutionListener</code>类配置了<code>order</code>值（举个例子，500）比<code>ServletTestExecutionListener</code>的order值小(恰好是1000)，<code>MyCustomTestExecutionListener</code>可以自动合并到默认集合中并在<code>ServletTestExecutionListener</code>之前，之前的例子可以替换成下面的代码：</p>
<pre><code class="language-java">@ContextConfiguration
@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}
</code></pre>
<h2 id="54-测试执行事件">5.4. 测试执行事件</h2>
<p>Spring Framework 5.2引入了<code>EventPublishingTestExecutionListener </code>，提供了一个实现自定义<code>TestExecutionListener</code>的替代方法。在测试<code>ApplicationContext</code>中的组件可以通过<code>EventPublishingTestExecutionListener</code>监听下列的事件，每个事件对应<code>TestExecutionListener</code>API中的一个方法。</p>
<ul>
<li><code>BeforeTestClassEvent</code></li>
<li><code>PrepareTestInstanceEvent</code></li>
<li><code>BeforeTestMethodEvent</code></li>
<li><code>BeforeTestExecutionEvent</code></li>
<li><code>AfterTestExecutionEvent</code></li>
<li><code>AfterTestMethodEvent</code></li>
<li><code>AfterTestClassEvent</code></li>
</ul>
<blockquote>
<p>这些事件只有在<code>ApplicationContext</code>已经加载后才发布</p>
</blockquote>
<p>这些事件可能因为多种原因被消费，比如重设模拟bean或者追踪测试执行。选择消费测试执行事件，而不是实现一个自定义<code>TestExecutionListener</code>，其中的一个优点是测试执行事件可以被任何在测试<code>ApplicationContext</code>中注册的Spring bean消耗，这些bean可以直接受利于依赖注入或者<code>ApplicationContext</code>的其他特性。相对应的，在<code>ApplicationContext</code>中的<code>TestExecutionListener</code>并不是一个bean。</p>
<p>为了监听测试执行事件，一个Spring bean可以选择去实现<code>org.springframework.context.ApplicationListener</code>接口。也可以用<code>@EventListener</code>修饰监听方法并且配置监听上面提到的指定事件类型中的一个。因为这个方法的流行，Spring提供了以下专用的<code>@EventListener</code>注解去简化测试执行事件监听器的注册。这些注解是在<code>org.springframework.test.context.event.annotation</code>包下的。</p>
<ul>
<li><code>@BeforeTestClass</code></li>
<li><code>@PrepareTestInstance</code></li>
<li><code>@BeforeTestMethod</code></li>
<li><code>@BeforeTestExecution</code></li>
<li><code>@AfterTestExecution</code></li>
<li><code>@AfterTestMethod</code></li>
<li><code>@AfterTestClass</code></li>
</ul>
<h3 id="异常处理">异常处理</h3>
<p>默认情况下，如果一个测试执行事件监听器在消费事件时抛出了一个异常，这个异常会传递到底层使用的测试框架上（比如JUnit或者TestNG）。比如在消费<code>BeforeTestMethodEvent</code>时抛出一个异常，对应的测试方法将会失败。相反，如果一个异步的测试执行事件监听器抛出一个异常，这个异常是不会传递到底层的测试框架的。异步异常处理的详情，查阅类级别<code>@EventListener</code>的javadoc。</p>
<h3 id="异步监听器">异步监听器</h3>
<p>如果你想要一个特别的测试执行事件监听器去异步处理事件，可以使用Spring的<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling-annotation-support-async">常规<code>@Async</code>支持</a> 。详情查阅类级别<code>@EventListener</code>的javadoc。</p>
<h2 id="55-上下文管理">5.5. 上下文管理</h2>
<p>每个<code>TestContext</code>都为它负责的测试实例提供了上下文管理和缓存支持。测试实例不会自动接收对配置<code>ApplicationContext</code>的访问。但是，如果测试类实现了<code>ApplicationContextAware</code>接口，会为测试实例提供一个<code>ApplicationContext</code>的引用。注意<code>AbstractJUnit4SpringContextTests</code>和<code>AbstractTestNGSpringContextTests</code>实现了<code>ApplicationContextAware</code>，所以自动提供对<code>ApplicationContext</code>的访问。</p>
<blockquote>
<p><strong>@Autowired ApplicationContext</strong>
作为一个实现<code>ApplicationContextAware</code>接口的替代方法，你可以通过设置<code>@Autowired</code>注解在字段上或者setter方法上来注入application context：</p>
<pre><code class="language-java">@SpringJUnitConfig
class MyTest {

   @Autowired 
   ApplicationContext applicationContext;

   // class body...
}
</code></pre>
<p>同样，如果你的测试需要加载一个<code>WebApplicationContext</code>:</p>
<pre><code class="language-java">@SpringJUnitWebConfig
class MyWebAppTest {

   @Autowired 
   WebApplicationContext wac;

   // class body...
}
</code></pre>
<p>通过使用<code>@Autowired</code>进行依赖注入是通过<code>DependencyInjectionTestExecutionListener</code>来提供的，默认情况下就会对它进行配置(参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-fixture-di">https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-fixture-di</a>)</p>
</blockquote>
<p>使用TestContext框架的测试类不需要extends任何特定的类或者实现任何特定接口去配置他们的application context。你只需要在类级别声明一个<code>@ContextConfiguration</code>注解即可。如果你的测试类没有显性的声明application context资源位置或者组件类，配置的<code>ContextLoader</code>会决定怎样从一个默认的位置或者默认的配置类加载一个context。除了资源位置和组件类，一个application context还可以通过application context初始化程序配置。</p>
<p>下面的几个章节阐述了怎样使用Srping的<code>@ContextConfiguration</code>注解去配置一个测试的<code>ApplicationContext</code>通过使用XML配置文件，Groovy脚本，组件类（典型的<code>@Configuration</code>类），或者上下文初始化程序。另外，你可以实现并配置你自定义的<code>SmartContextLoader</code>为高级的使用场景。</p>
<ul>
<li>Context Configuration with XML resources</li>
<li>Context Configuration with Groovy Scripts</li>
<li>Context Configuration with Component Classes</li>
<li>Mixing XML, Groovy Scripts, and Component Classes</li>
<li>Context Configuration with Context Initializers</li>
<li>Context Configuration Inheritance</li>
<li>Context Configuration with Environment Profiles</li>
<li>Context Configuration with Test Property Sources</li>
<li>Context Configuration with Dynamic Property Sources</li>
<li>Loading a <code>WebApplicationContext</code></li>
<li>Context Caching</li>
<li>Context Hierarchies</li>
</ul>
<h3 id="context-configuration-with-xml-resources">Context Configuration with XML resources</h3>
<p>通过XML配置文件为你的测试加载<code>ApplicationContext</code>，需要用<code>@ContextConfiguration</code>注解修饰你的测试类，并用一个由XML文件位置构成的数组来给<code>locations</code>属性赋值。一个相对路径（比如<code>context.xml</code>）会被看做一个classpath资源并且会关联到测试类定义的包下。一个以斜线开头的路径会被看作绝对的classpath路径（比如<code>/org/example/config.xml</code>）。一个路径代表一个资源URL(比如一个路径的前缀是<code>classpath:</code>,<code>file:</code>,<code>http:</code>,等等)。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from &quot;/app-config.xml&quot; and
// &quot;/test-config.xml&quot; in the root of the classpath
@ContextConfiguration(locations={&quot;/app-config.xml&quot;, &quot;/test-config.xml&quot;}) 
class MyTest {
    // class body...
}n
</code></pre>
<p><code>@ContextConfiguration</code>通过标准的Java<code>value</code>属性为<code>locations</code>属性提供了一个别名。所以如果你不在<code>@ContextConfiguration</code>申明额外的属性，你可以省略<code>locations</code>：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-config.xml&quot;}) 
class MyTest {
    // class body...
}
</code></pre>
<p>如果你<code>locations</code>和<code>value</code>属性都没有声明，那么TestContext框架会尝试检测默认的XML资源路径。具体来说，<code>GenericXmlContextLoader </code>和<code>GenericXmlWebContextLoader </code>会基于测试类的名称检测资源路径。如果你的类名为<code>com.example.MyTest</code>，<code>GenericXmlContextLoader</code>会从<code>classpath:com/example/MyTest-context.xml</code>加载你的application context。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// &quot;classpath:com/example/MyTest-context.xml&quot;
@ContextConfiguration 
class MyTest {
    // class body...
}
</code></pre>
<h3 id="context-configuration-with-groovy-scripts">Context Configuration with Groovy Scripts</h3>
<p>通过使用<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#groovy-bean-definition-dsl">Groovy Bean Definition DSL</a> 生成的Groovy脚本可以为你的测试生成<code>ApplicationContext</code>，配置Groovy的脚本可以通过<code>@ContextConfiguration</code>的<code>locations</code>和<code>value</code>属性来设置Groovy脚本的资源位置。资源查找语法跟XML文件配置一样。</p>
<blockquote>
<p><strong>启用Groovy脚本支持</strong><br>
如果Groovy在classpath路径下，Spring TestContext框架会自动支持用Groovy脚本加载<code>ApplicationContext</code></p>
</blockquote>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from &quot;/AppConfig.groovy&quot; and
// &quot;/TestConfig.groovy&quot; in the root of the classpath
@ContextConfiguration({&quot;/AppConfig.groovy&quot;, &quot;/TestConfig.Groovy&quot;}) 
class MyTest {
    // class body...
}
</code></pre>
<p>如果你同时忽略<code>locations</code>和<code>value</code>属性，测试框架会尝试检测默认的Groovy脚本。具体来说，<code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>会检测一个默认的路径，基于测试类的名称。如果你的类名为<code>com.example.MyTset</code>，Groovy上下文加载器会从<code>classpath:com/example/MyTestContext.groovy</code>加载上下文。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// &quot;classpath:com/example/MyTestContext.groovy&quot;
@ContextConfiguration 
class MyTest {
    // class body...
}
</code></pre>
<blockquote>
<p><strong>同时声明XML配置和Groovy脚本</strong><br>
你可以同时申明XML配置和Groovy脚本通过<code>@Configuration</code>脚本的<code>locations</code>和<code>value</code>属性。如果配置路径以<code>.xml</code>路径结尾，<code>XmlBeanDefinitionReader</code>会用来加载配置。否则会使用<code>GroovyBeanDefinitionReader</code>。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// &quot;/app-config.xml&quot; and &quot;/TestConfig.groovy&quot;
@ContextConfiguration({ &quot;/app-config.xml&quot;, &quot;/TestConfig.groovy&quot; })
class MyTest {
// class body...
}
</code></pre>
</blockquote>
<h3 id="context-configuration-with-component-classes">Context Configuration with Component Classes</h3>
<p>使用组件类为你的测试加载一个<code>ApplicationContext</code>，你可以通过<code>@ContextConfiguration</code>注解，并配置<code>classes</code>属性：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) 
class MyTest {
    // class body...
}
</code></pre>
<blockquote>
<p><strong>Component Classes</strong><br>
&ldquo;Component Class&quot;组件类指的是：</p>
<ul>
<li>被<code>@Configuration</code>修饰的类</li>
<li>一个组件（就是被<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，或者其他原始注解修饰的类）</li>
<li>一个JSR-330编译的类，就是被<code>javax.inject</code>注解修饰的类</li>
<li>任何类包含<code>@Bean</code>方法</li>
<li>任何其他类尝试去注册为一个Spring组件(就是说一个在<code>ApplicationContext</code>里的Spring bean)，可能是利用单个构造方法的自动装配，而不是Spring注解 <br>
查看<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a> 的javadoc查找更多详情。关于注解类的配置和语法，特别注意<code>@Bean</code>Lite模式的讨论。</li>
</ul>
</blockquote>
<p>如果忽略<code>classes</code>属性，TestContext框架会尝试检测默认配置类是否存在。具体来说，<code>AnnotationConfigContextLoader</code>和<code>AnnotationConfigWebContextLoader</code>会检测所有满足配置类实现需求的<code>static</code>集成类，详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a> javadoc。注意配置类的名称是任意的。另外，如果测试类愿意的话他可以包含多个<code>static</code>集成配置类。下面的例子里,<code>OrderServiceTest</code>类声明了一个<code>static</code>集成配置类叫做<code>Config</code>，他会被用来为测试类自动加载<code>ApplicationContext</code>：</p>
<pre><code class="language-java">@SpringJUnitConfig 
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}
</code></pre>
<h3 id="mixing-xml-groovy-scripts-and-component-classes">Mixing XML, Groovy Scripts, and Component Classes</h3>
<p>有时候会存在混合XML文件,Groovy脚本，和组件类去配置一个<code>ApplicationContext</code>的情况。</p>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>Permalink: </strong>
      <a href="http://www.mingaccount.com/2017/09/spring%E6%B5%8B%E8%AF%95/" title="Spring集成测试" target="_blank" rel="external">http://www.mingaccount.com/2017/09/spring%E6%B5%8B%E8%AF%95/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="http://www.mingaccount.com/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">Ming</span><small class="ml-1x">tianshiming5@outlook.com</small></a></h3>
        <div>Finally</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="http://www.mingaccount.com/2017/09/qpstpspv%E7%AD%89%E7%BD%91%E7%AB%99%E4%B8%9A%E5%8A%A1%E5%85%B3%E9%94%AE%E5%AD%97%E9%87%8A%E4%B9%89/" title="QPS、TPS、PV等网站业务关键字释义"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;Older</span></a>
            </li>
            <li class="next">
                <a href="http://www.mingaccount.com/2017/09/spel/"
                    title="Spring Expression Language"><span>Newer&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="Catalogue" role="button">
                    <span>[&nbsp;</span><span>Catalogue</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>

</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="http://www.mingaccount.com/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2015  -
    2020
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js" defer></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>
<script src="http://www.mingaccount.com/js/application.min.bdeb64b910570b6c41badc6a05b7afb0c8ad9efd8525de3c7257d59e786326a3.js"></script>
<script src="http://www.mingaccount.com/js/plugin.min.51ff8c7317566f82259170fa36e09c4493adc9b9378b427a01ad3f017ebac7dd.js"></script>

<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            ROOT_URL: 'http:\/\/www.mingaccount.com',
            CONTENT_URL: 'http:\/\/www.mingaccount.com\/searchindex.json ',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script type="text/javascript" src="http://www.mingaccount.com/js/insight.min.a343cd9a5a7698336b28ef3a7c16a3a1b1d2d5fb17dc8ed04022bbe08cc5459073a15bdafa3a8a58cdd56080784bdd69fa70b1ae8597565c799c57ed00f0e120.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    tocbot.init({
        
        tocSelector: '.js-toc',
        
        contentSelector: '.js-toc-content',
        
        headingSelector: 'h1, h2, h3',
        
        hasInnerContainers: true,
    });
</script>


  </body>
</html>
