<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
        Spring集成测试 - Ming Blog
      </title>
        <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    
    <meta name="theme-color" content="#000000" />
    
    <meta http-equiv="window-target" content="_top" />
    
    
    <meta name="description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成" />
    <meta name="generator" content="Hugo 0.80.0 with theme pure" />
    <title>Spring集成测试 - Ming Blog</title>
    
    
    <link rel="stylesheet" href="https://www.mingaccount.com/css/style.min.c4bc7071f132c964c2116bca53b392933f377e5ca7b7051ed245187c621a2d3e.css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css" async>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" async>
    <meta property="og:title" content="Spring集成测试" />
<meta property="og:description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mingaccount.com/2017/09/spring-test/" />
<meta property="article:published_time" content="2017-09-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-09-15T00:00:00+00:00" />
<meta itemprop="name" content="Spring集成测试">
<meta itemprop="description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成">
<meta itemprop="datePublished" content="2017-09-15T00:00:00+00:00" />
<meta itemprop="dateModified" content="2017-09-15T00:00:00+00:00" />
<meta itemprop="wordCount" content="57855">



<meta itemprop="keywords" content="spring,unit-test,junit4,junit5,testng,mockmvc," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring集成测试"/>
<meta name="twitter:description" content="1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成"/>

    <!--[if lte IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
      <![endif]-->

    <!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
      <![endif]-->
  </head>

  
  

  <body class="main-center theme-green" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="" target="_blank">
            <img class="img-circle img-rotate" src="https://www.mingaccount.com/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">Ming</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">tianshiming5@outlook.com</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>BeiJing, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="Type something..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts/">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories/">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags/">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>

<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title"> Categories</h3>
    <div class="widget-body">
        <ul class="category-list">
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> Tags</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/api/" class="tag-list-link">api</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/db2/" class="tag-list-link">db2</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/design-pattern/" class="tag-list-link">design-pattern</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/docker/" class="tag-list-link">docker</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/druid/" class="tag-list-link">druid</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/ehcache/" class="tag-list-link">ehcache</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/git/" class="tag-list-link">git</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/gradle/" class="tag-list-link">gradle</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/h2/" class="tag-list-link">h2</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/hadoop/" class="tag-list-link">hadoop</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/hive/" class="tag-list-link">hive</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/jackson/" class="tag-list-link">jackson</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">37</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/jenkins/" class="tag-list-link">jenkins</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/jooq/" class="tag-list-link">jooq</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/junit4/" class="tag-list-link">junit4</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/junit5/" class="tag-list-link">junit5</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/lombok/" class="tag-list-link">lombok</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/markdown/" class="tag-list-link">markdown</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/maven/" class="tag-list-link">maven</a><span
                    class="tag-list-count">17</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/mockmvc/" class="tag-list-link">mockmvc</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/mybatis/" class="tag-list-link">mybatis</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/mysql/" class="tag-list-link">mysql</a><span
                    class="tag-list-count">19</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/nexus/" class="tag-list-link">nexus</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/npm/" class="tag-list-link">npm</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/oracle/" class="tag-list-link">oracle</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/postgresql/" class="tag-list-link">postgresql</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/protocol/" class="tag-list-link">protocol</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/python/" class="tag-list-link">python</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/redis/" class="tag-list-link">redis</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/regexp/" class="tag-list-link">regexp</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/scala/" class="tag-list-link">scala</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/spark/" class="tag-list-link">spark</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/spring/" class="tag-list-link">spring</a><span
                    class="tag-list-count">28</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/testng/" class="tag-list-link">testng</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/unit-test/" class="tag-list-link">unit-test</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/website-build/" class="tag-list-link">website-build</a><span
                    class="tag-list-count">6</span></li>
            
            
            <li class="tag-list-item"><a href="https://www.mingaccount.com/tags/windows/" class="tag-list-link">windows</a><span
                    class="tag-list-count">6</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://www.mingaccount.com/2021/02/duration-format/" class="title">Duration format PnDTnHnMn.nS ISO-8601</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2021-02-20 00:00:00 &#43;0000 UTC" itemprop="datePublished">2021-02-20</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://www.mingaccount.com/2020/11/spring-boot-schema/" class="title">Spring boot 启动时自动初始化sql脚本</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-11-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-11-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://www.mingaccount.com/2020/10/windows-hyper-v-and-container/" class="title">启用Windows Hyper-v和containers</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-10-19 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-10-19</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://www.mingaccount.com/2020/10/windows-npm-exception/" class="title">Windows CMD 错误pngquant failed to build, make sure that libpng-dev is installed</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-10-18 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-10-18</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://www.mingaccount.com/2020/09/git-push-exception-ssl-error/" class="title">git push 异常SSL_connect: SSL_ERROR_SYSCALL</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-09-15 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-09-15</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <h4 class="toc-title">Catalogue</h4>
    <nav id="toc" class="js-toc toc">

    </nav>
  </div>
</aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2017/09/spring-test/"
    >Spring集成测试</a
  >
</h1>

      <div class="article-meta">
        
<span class="article-date">
  <i class="icon icon-calendar-check"></i>&nbsp;
<a href="https://www.mingaccount.com/2017/09/spring-test/" class="article-date">
  <time datetime="2017-09-15 00:00:00 &#43;0000 UTC" itemprop="datePublished">2017-09-15</time>
</a>
</span>
  
  <span class="article-tag">
    <i class="icon icon-tags"></i>&nbsp;
    <a class="article-tag-link" href="/tags/spring/"> spring </a>
    <a class="article-tag-link" href="/tags/unit-test/"> unit-test </a>
    <a class="article-tag-link" href="/tags/junit4/"> junit4 </a>
    <a class="article-tag-link" href="/tags/junit5/"> junit5 </a>
    <a class="article-tag-link" href="/tags/testng/"> testng </a>
    <a class="article-tag-link" href="/tags/mockmvc/"> mockmvc </a>
  </span>

        <span class="post-comment"><i class="icon icon-comment"></i>&nbsp;<a href="/2017/09/spring-test/#comments"
            class="article-comment-link">Comments</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 57855words</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 116minutes </span>
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <h1 id="1-概览">1. 概览</h1>
<p>一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成测试，那么将会极大的缩短测试时间。比如通过ORM框架访问数据库的时候，想确定sql的正确性，或者对象实例映射的正确性</p>
<p>介绍Spring的测试框架，第一个就离不开<code>org.springframework.test</code>包，他对Spring容器集成测试有很大的价值，并且它不依赖于任何其他的部署环境或者应用服务。虽然他比纯粹的单元测试慢，但是比任何等同于<code>Selenium</code>的测试，或者需要依赖于部署应用服务的测试都快</p>
<p>Spring TestContext框架是以注解为驱动支持单元和集成测试的。这个<code>TestContext</code>不管实际使用的是什么测试框架，在Junit，TestNG，以及其他测试框架环境中都能进行测试</p>
<h1 id="2-集成测试的目标">2. 集成测试的目标</h1>
<p>Spring集成测试主要有下面几个主要目标：</p>
<ul>
<li>在测试之间管理Spring IoC容器的缓存</li>
<li>为测试的资源实例提供依赖注入</li>
<li>提供适合集成测试的事务管理</li>
<li>提供Spring指定的基础类以帮助开发者写集成测试</li>
</ul>
<p>接下来的子章节是对上面几个目标的详细描述</p>
<h2 id="21-上下文管理和缓存">2.1. 上下文管理和缓存</h2>
<p>Spring TestContext框架提供了<code>ApplicationContext</code>实例和<code>WebApplicationContext</code>实例的一致性加载，以及这些上下文对象的缓存。支持缓存和加载这些上下文对象是非常重要的，因为启动时间是个很严重的问题，这个时间的消费并不是Spring容器自身消耗的，而是对象实例化需要时间。举个例子，一个项目有50到100个Hibernate的映射文件，那么将要花费10到20秒的时间去加载这些映射文件,如果每次测试都有这个花费，那么会拖慢整个测试进度，减少开发者的产出。</p>
<p>典型的测试类申明要么是xml的资源位置数组或者Groovy的配置源数据（一般在classpath目录下），又或者是配置应用的成员类数组。这些位置或者类跟<code>web.xml</code>中的申明基本类似</p>
<p>默认情况下，一旦加载，每次测试都复用的一个<code>ApplicationContext</code>。  因此，一个测试套件（test suite)只会有一次初始化应用的过程，每次子测试可以节省大量时间。这里说的测试套件(test suite)术语代表在一个JVM里面运行的所有测试-比如说，一个由Ant，Maven，或者Gradle构建的项目中运行的所有测试。在极少情况下，<code>ApplicationContext</code>会被污染需要重新加载（举个例子，通过修改bean的定义或者应用对象的状态）TestContext框架可以通过配置重载配置信息，并在执行下次测试之前重新构建<code>ApplicationContext</code>。下文中有详细操作。</p>
<h2 id="22-测试资源的依赖注入">2.2. 测试资源的依赖注入</h2>
<p>当<code>TestContext</code>框架加载你的<code>ApplicationContext</code>时，他可以通过依赖注入添加任意的配置到你的测试实例。他提供了一个简明的机制，通过<code>ApplicationContext</code>中的预配置bean来构建你测试所需要的资源环境。他的最大好处是每个测试场景都可以共用一个<code>ApplicationContext</code>，避免一次测试起一次环境</p>
<p>现在假如我们有一个类<code>HibernateTitleRepository</code>，他实现了<code>Title</code>领域实体（domain entity)的数据访问逻辑。我们想写一个集成测试以测试下面几个方面：</p>
<ul>
<li>Spring的配置：所有<code>HibernateTitleRepository</code>相关的配置是否正确关联和展示？</li>
<li>Hibernate的映射文件配置：映射是否正确并且延迟加载的配置是否到位？</li>
<li><code>HibernateTitleRepository</code>的逻辑：该类配置实例的运行是否符合预期？</li>
</ul>
<p>依赖注入的详细内容后面会讲到</p>
<h2 id="23-事务管理">2.3. 事务管理</h2>
<p>在测试中访问真实数据库的一个常见问题是测试对持久性存储状态的影响。即使你使用的是开发数据库，更改状态也可能会影响到进一步的测试。还有许多操作例如插入或者修改持久数据，没有事务都是不能运行的</p>
<p><code>TestContext</code>框架解决了这个问题。默认情况下，框架会为每次测试创建和回滚事务。你可以在假定有事务的前提下写测试代码。如果你在测试中调用事务的代理对象，根据他们配置的事务语句，决定他们是否能正常运转。另外，如果一个测试方法在事务管理的范围内删除了选中表的内容，默认情况下事务会回滚，数据库会返回到执行测试之前的状态。为测试提供的事务支持是由<code>PlatformTransactionManager</code>bean来提供的</p>
<p>如果你想提交一个事务（一般来说不会，在你想填充或者修改数据库的时候有用），你可以通过TestContext框架来提交事务以代替使用<code>@Commit</code>注解的回滚</p>
<p>详细内容后面会讲到</p>
<h2 id="24-集成测试的支持类">2.4. 集成测试的支持类</h2>
<p><code>TestContext</code>框架提供了多个抽象支持类，他们简化了集成测试的编写。这些基础测试类为测试框架提供了定义明确的钩子和方便的实例参数和方法，他们能让你访问：</p>
<ul>
<li><code>ApplicationContext</code>，用于执行显式的bean查找或者测试整个上下文的状态。</li>
<li><code>JdbcTemplate</code>，用于执行sql表达式。你可以查询数据库相关应用代码执行前后的数据库状态，并且Spring确保这些查询都在同一个事务中。党和ORM框架配合使用时，需要确保避免<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tx-false-positives">false positives</a></li>
</ul>
<p>另外你可能想创建你自定义的支持类，更多信息可以参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-framework">TestContext framework</a></p>
<h1 id="3-jdbc测试的支持">3. JDBC测试的支持</h1>
<p>JDBC相关的工具方法在类<code>JdbcTestUtils</code>类中，他在<code>org.springframework.test.jdbc</code>包下。它简化了标准的数据库测试场景。<code>JdbcTestUtils</code>提供了以下静态的工具方法：</p>
<ul>
<li><code>countRowsInTable(..)</code>:计算指定表有多少行数据</li>
<li><code>countRowsInTableWhere(..)</code>:计算指定表有多少行数据通过提供的where条件进行限制</li>
<li><code>deleteFromTables(..)</code>:删除指定表的所有行</li>
<li><code>deleteFromTableWhere(..)</code>:删除指定表的数据行通过提供的where条件进行限制</li>
<li><code>dropTables(..)</code>:Drop指定表</li>
</ul>
<blockquote>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code>和<code>AbstractTransactionalTestNGSpringContextTests</code>代理了前面提及的<code>JdbcTestUtils</code>类的方法。<br>
<code>spring-jdbc</code>模块支持配置和启动一个集成的数据库，你可以用它进行集成测试。更多细节，参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-embedded-database-support">Embedded Database Support</a> 和 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-embedded-database-dao-testing"> Testing Data Access Logic with an Embedded Database</a></p>
</blockquote>
<h1 id="4-注解">4. 注解</h1>
<p>这个章节介绍你在测试Spring应用时可以用的注解。它包含如下几个主题：</p>
<ul>
<li>Spring 测试注解</li>
<li>标准注解支持</li>
<li>Spring JUnit 4 测试注解</li>
<li>Spring JUnit Jupiter 测试注解</li>
<li>测试元注解</li>
</ul>
<h2 id="41-spring-测试注解">4.1. Spring 测试注解</h2>
<p>Spring框架提供了如下Spring特有的注解，你可以使用他们在你的单元和集成测试中。查看他们对应的javadoc以查找更多信息，包括默认的属性值，属性别名，和其他细节。</p>
<p>Spring测试注解包括：</p>
<ul>
<li><code>@BootstrapWith</code></li>
<li><code>@ContextConfiguration</code></li>
<li><code>@WebAppConfiguration</code></li>
<li><code>@ContextHierarchy</code></li>
<li><code>@ActiveProfiles</code></li>
<li><code>@TestPropertySource</code></li>
<li><code>@DynamicPropertySource</code></li>
<li><code>@DirtiesContext</code></li>
<li><code>@TestExecutionListeners</code></li>
<li><code>@Commit</code></li>
<li><code>@Rollback</code></li>
<li><code>@BeforeTransaction</code></li>
<li><code>@AfterTransaction</code></li>
<li><code>@Sql</code></li>
<li><code>@SqlConfig</code></li>
<li><code>@SqlMergeMode</code></li>
<li><code>@SqlGroup</code></li>
</ul>
<h3 id="boostrapwith"><code>@BoostrapWith</code></h3>
<p><code>@BootstrapWith</code>是一个类级别的注解，你可以使用它配置Spring TestContext框架是怎样引导启动的。具体可以使用<code>@BootstrapWith</code>去指定一个自定的<code>TestContextBootstrapper</code>。查看<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-bootstrapping">bootstrapping the TestContext framework</a> 以获取详细信息</p>
<h3 id="contextconfiguration"><code>@ContextConfiguration</code></h3>
<p><code>@ContextConfiguration</code> 定义类级别的源数据，常用来决定集成测试如何加载和配置一个<code>ApplicationContext</code>。具体的，可以使用<code>@ContextConfiguration</code>声明应用上下文的资源位置，或者用于加载上下文的组件类</p>
<p>资源位置，一般来说就是在classpath路径下的XML的配置文件或者Groovy的脚本，而组件类一般来说是<code>@Configuration</code>注解的类。但是，资源位置可以引用文件系统中的文件和脚本，并且组件类可以是<code>@Component</code>类，<code>@Service</code>类，其他等等。更多参照<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-javaconfig-component-classes">Component Classes</a></p>
<p>下面的例子<code>@ContextConfiguration</code>注解指向了一个XML文件：</p>
<pre><code class="language-java">@ContextConfiguration(&quot;/test-config.xml&quot;)
class XmlApplicationContextTests{}
</code></pre>
<p>下面的例子<code>@ContextConfiguration</code>指向一个类：</p>
<pre><code class="language-java">@ContextConfiguration(classes = TestConfig.class)
class ConfigClassApplicationContextTests{}
</code></pre>
<p>另外还可以使用<code>@ContextConfiguration</code>声明<code>ApplicationContextInitializer</code>类，这种方法也可以声明资源位置和组件类：</p>
<pre><code class="language-java">@ContextConfiguration(initializers = CustomContextIntializer.class)
class ContextInitializerTests{}
</code></pre>
<p>你也可以选择<code>ContextConfiguration</code>申明<code>ContextLoader</code>的方式也行。注意，你通常不需要显式的配置loader，因为默认的loader支持<code>initializers</code>和资源位置或组件类。<br>
下面的例子同时声明了一个资源位置和一个loader:</p>
<pre><code class="language-java">@ContextConfiguration(locations=&quot;/test-context.xml&quot;,loader=CustomContextLoader.class)
class CustomLoaderXmlApplicationContextTests{}
</code></pre>
<blockquote>
<p><code>@ContextConfigurtion</code>对继承资源位置或者配置类提供了支持，还有由父类或者封闭类声明的context initializers</p>
</blockquote>
<p>详情参考 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management">Context Management</a> ,<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration</a> 以及<code>@ContextConfiguration</code>的API文档</p>
<h3 id="webappconfiguration"><code>@WebAppConfiguration</code></h3>
<p><code>@WebAppConfiguration</code>是一个类级别的注解，它能将为集成测试声明的<code>ApplicationContext</code>指定为<code>WebApplicationContext</code>。<code>WebAppConfiguration</code>注解仅仅在测试类上存在，为确保<code>WebApplicationContext</code>是为测试加载，使用默认值<code>file:src/main/webapp</code>作为web应用的根路径（资源仓库路径）。资源仓库路径用于在后台创建<code>MockServletContext</code>，它被用作<code>WebApplicationContext</code>的<code>ServletContext</code></p>
<p>下面是如何使用<code>@WebAppConfiguration</code>注解：</p>
<pre><code class="language-java">@ContextConfiguration
@WebAppConfiguration
class WebAppTests{}
</code></pre>
<p>如果你的资源仓库路径不是默认的<code>file:src/main/webapp</code>，你可以指定你自己的资源仓库路径，使用默认的<code>value</code>属性。可以支持<code>classpath:</code>和<code>file:</code>资源前缀。如果没有提供资源前缀，这个路径会被假定位文件系统资源。下面的例子展示了怎样指定一个classpath资源：</p>
<pre><code class="language-java">@ContextConfiguration
@WebAppConfiguration(&quot;classpath:test-web-resources&quot;)
class WebAppTests{}
</code></pre>
<p>注意<code>WebAppConfiguration</code>必须与<code>ContextConfiguration</code>配合使用，不管在单个测试类还是一个测试类的层次结构中。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html">@WebAppConfiguration</a> API文档</p>
<h3 id="contexthierarchy"><code>@ContextHierarchy</code></h3>
<p>它是一个类级别的注解，为集成测试定义<code>ApplicationContext</code>实例的层次结构。<code>@ContextHierarchy</code>应该由一个<code>@ContextConfiguration</code>的实例集合来申明，其中每一个都定义context层级关系中的一级。下面的例子展示了<code>@ContextHierarchy</code>在单个测试类中的的使用（它也可以用在一个测试类的层次结构中）</p>
<pre><code class="language-java">@ContextHierarchy({
    @ContextConfiguration(&quot;/parent-config.xml&quot;),
    @ContextConfiguration(&quot;/child-config.xml&quot;)
})
class ContextHierarchyTests{}
</code></pre>
<pre><code class="language-java">@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests{}
</code></pre>
<p>如果你需要在测试类的层次结构中对指定层级的配置进行合并或者重写，那么需要一个别名值来对应层级，在设置<code>@ContextHierarchy</code>的每个<code>@ContextConfiguration</code>层级时，需要给他们指明参数<code>name</code>的值。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/ContextHierarchy.html"> @ContextHierarchy</a> api文档</p>
<h3 id="activeprofiles"><code>@ActiveProfiles</code></h3>
<p>它是类级别的注解，当为继承测试加载<code>ApplicationContext</code>时用来声明启用哪些bean定义配置文件</p>
<p>下面的例子表示启用了<code>dev</code>配置文件：</p>
<pre><code class="language-java">@ContextConfiguration
@ActiveProfiles(&quot;dev&quot;)
class DeveloperTests{}
</code></pre>
<p>下面的例子表示<code>dev</code>和<code>integration</code>配置文件都应该启用：</p>
<pre><code class="language-java">@ContextConfiguration
@ActiveProfiles({&quot;dev&quot;,&quot;integration&quot;})
class DeveloperIntegrationTests{}
</code></pre>
<blockquote>
<p>默认情况下<code>@ActiveProfiles</code>是支持继承父类或者封闭类的配置信息的。你可以完全自定义解析激活配置文件通过实现<code>ActiveProfilesResolver</code>，并使用<code>@ActiveProfiles</code>的属性<code>resolver</code>来注册。</p>
</blockquote>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a> ,<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration</a> ,以及<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/ActiveProfiles.html">@ActiveProfiles</a></p>
<h3 id="testpropertysource"><code>@TestPropertySource</code></h3>
<p>它是一个类级别的注解，你可以使用它来配置属性文件和内联属性的位置，最后添加到<code>PropertySources</code>集合中，这个集合在<code>ApplicationContext</code>的<code>Environment</code>中。</p>
<p>下面的例子展示了怎样声明一个来自classpath的属性文件:</p>
<pre><code class="language-java">@ContextConfiguration
@TestPropertySource(&quot;/test.properties&quot;)
class MyIntegrationTests{}
</code></pre>
<p>下面的例子展示怎样声明内联属性：</p>
<pre><code class="language-java">@ContextConfiguraiton
@TestPropertySource(properties = {&quot;timezone = GMT&quot;, &quot;port: 4242&quot;})
class MyIntegrationTests{}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></p>
<h3 id="dynamicpropertysource"><code>@DynamicPropertySource</code></h3>
<p>它是一个方法级别的注解，他可以注册动态属性，跟<code>@TestPropertySource</code>一样，也是添加到<code>PropertySources</code>集合中。当你不能提前判断属性值时，可以通过动态属性来设置-举个例子，如果属性是交由外部资源管理的，比如通过<a href="https://www.testcontainers.org/">TestContainers</a> 来进行的容器管理。</p>
<p>下面的例子展示了如何注册一个动态属性：</p>
<pre><code class="language-java">@ContextConfiguration
class MyIntegrationTests{
    static MyExternalServer server = // ...

    @DynamicPropertySource
    static void dynamicProperties(DynamicPropertyRegistry registry){
        registry.add(&quot;server.port&quot;,server::getPort);
    }
}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a></p>
<h3 id="dirtiescontext"><code>@DirtiesContext</code></h3>
<p>这个注解表示底层的Spring<code>ApplicationContext</code>在执行测试的时候被污染了（意思就是，测试的时候以某种方式修改或者污染了<code>ApplicationContext</code>-比如说，改变单例bean的状态），并且需要关闭这个context。当一个应用上下文被dirty标记，会被测试框架从缓存中移除并关闭。在最后，如果还有其他测试需要这个context，Spring容器会重新构建。</p>
<p>你可以使用该注解在类级别或者方法级别，在同一个类中或者类的层次结构中。你可以标记<code>ApplicationContext</code>是在方法前后还是在类前后被污染的，通过<code>methodMode</code>和<code>classMode</code>来配置。</p>
<p>下面的例子展示了几个不同场景的使用方案：</p>
<ul>
<li>在当前的测试类之前，通过声明<code>classMode</code>为<code>BEFORE_CLASS</code></li>
</ul>
<pre><code class="language-java">@DirtiesContext(classMode = BEFORE_CLASS)
class FetchContextTests{}
</code></pre>
<ul>
<li>在当前的测试类之后，通过声明<code>classMode</code>为<code>AFTER_CLASS</code>(默认的classMode)</li>
</ul>
<pre><code class="language-java">@DirtiesContext
class FetchContextTests{}
</code></pre>
<ul>
<li>在当前测试类的每个测试方法之前，通过声明<code>classMode</code>为<code>BEFORE_EACH_TEST_METHOD</code></li>
</ul>
<pre><code class="language-java">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD)
class FreshContextTests{
}
</code></pre>
<ul>
<li>在当前测试类的每个测试方法执行后，通过声明<code>classMode</code>为<code>AFTER_EACH_TEST_METHOD</code></li>
</ul>
<pre><code class="language-java">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD)
class ContextDirtyingTests{}
</code></pre>
<ul>
<li>在当前测试之前，通过在方法上申明<code>methodMode</code>为<code>BEFORE_METHOD</code></li>
</ul>
<pre><code class="language-java">@Test
@DirtiesContext(methodMode = BEFORE_METHOD)
void testProcessWhichRequiresFreshAppCtx(){}
</code></pre>
<ul>
<li>在当前测试之后，通过在方法上声明<code>methodMode</code>为<code>AFTER_METHOD</code>(默认的方法模式)</li>
</ul>
<pre><code class="language-java">@DirtiesContext
@Test
void testProcessWhichDirtiesAppCtx(){}
</code></pre>
<p>如果<code>@DirtiesContext</code>注解修饰的测试context，是<code>@ContextHierarchy</code>注解层次结构中的一部分，你可以使用<code>hierarchyMode</code>属性去控制context缓存如何清除。默认情况下，一个详尽的算法会用来清除context缓存，包括的不仅是当前层级，还有所有其他共享了同一个父类context的子层级，子层级的所有<code>ApplicationContext</code>实例都会从缓存中移除并关闭。在某些情况下，如果你觉得默认的算法清楚的范围太广，你可以指定更简单的当前层级算法：</p>
<pre><code class="language-java">@ContextHierarchy({
    @ContextConfiguration(&quot;/parent-config.xml&quot;),
    @ContextConfiguration(&quot;/child-config.xml&quot;)
})
class BaseTest{}

class ExtendedTests extends BaseTest{
    @Test
    @DirtiesContext(hierarchyMode=CURRENT_LEVEL)
    void test(){}
}
</code></pre>
<p>更多关于<code>EXHAUSTIVE</code>和<code>CURRENT_LEVEL</code>算法的问题，可以参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html">DirtiesContext.HierarchyMode</a></p>
<h3 id="testexecutionlisteners"><code>@TestExecutionListeners</code></h3>
<p>它定义了用来配置<code>TestExecutionListener</code>实现的类级别元数据(<code>TestExecutionListener</code>实现是由<code>TestContextManager</code>来注册的)。一般来说都是配合<code>@ContextConfiguration</code>来使用。</p>
<p>下面的例子展示了如何注册两个<code>TestExecutionListener</code>实现</p>
<pre><code class="language-java">@ContextConfiguration
@TestExecutionListeners({CustonTestExecutionListener.class,AnotherTestExecutionListerner.class})
class CustomTestExecutionListenerTests {}
</code></pre>
<p>默认情况下，<code>@TestExecutionListeners</code>是支持从父类继承的，或者内部类从外部封闭类继承。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">@TestExecutionListeners javadoc</a></p>
<h3 id="commit"><code>@Commit</code></h3>
<p><code>@Commit</code>代表测试方法的事务会在测试方法完成后提交。你可以将<code>@Commit</code>替换为<code>@Rollback(false)</code>。<code>@Commit</code>和<code>@Rollback</code>相似，都可以声明在类或方法上。</p>
<p>使用实例：</p>
<pre><code class="language-java">@Commit
@Test
void testProcessWithoutRollback(){
}
</code></pre>
<h3 id="rollback"><code>@Rollback</code></h3>
<p><code>@Rollback</code>代表测试方法执行完后，是否回滚事务。为true则回滚，否则事务会提交（跟<code>@Commit</code>一样）。该注解的默认值为true，就算没有声明该注解，事务默认也会回滚。</p>
<p>当申明在类上时，<code>@Rollback</code>注解将会影响类的所有测试方法，当申明在方法时，只会影响指定方法，并会覆盖类上的全局<code>@Rollback</code>或<code>@Commit</code>配置</p>
<p>使用实例：</p>
<pre><code class="language-java">@Test
@Rollback(false)
void testProcessWithoutRollback(){
}
</code></pre>
<h3 id="beforetransaction"><code>@BeforeTransaction</code></h3>
<p>它代表注解的<code>void</code>方法应该在事务启动之前运行，对测试方法来说，它已经被配置好了在一个事务中运行，是通过使用Spring的<code>@Transactional</code>注解来实现的。<code>@BeforeTransaction</code>方法是不需要<code>public</code>修饰的，并且可以声明在java8的接口默认方法上。</p>
<p>使用实例：</p>
<pre><code class="language-java">@BeforeTransaction
void beforeTransaction(){}
</code></pre>
<h3 id="aftertransaction"><code>@AfterTransaction</code></h3>
<p>它代表注解的<code>void</code>方法应该在事务结束后运行，对测试方法来说，它已经被配置好了在一个事务中运行，是通过使用Spring的<code>@Transactional</code>注解来实现的。<code>@AfterTransaction</code>方法是不需要<code>public</code>修饰的，并且可以声明在java8的接口默认方法上。</p>
<pre><code class="language-java">@AfterTransaction
void afterTransaction(){}
</code></pre>
<h3 id="sql"><code>@Sql</code></h3>
<p>它是用来配置测试类或者方法需要的sql脚本的。</p>
<pre><code class="language-java">@Test
@Sql({&quot;/test-schema.sql&quot;,&quot;/test-user-data.sql&quot;})
void userTest(){}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a></p>
<h3 id="sqlconfig"><code>@SqlConfig</code></h3>
<p>它用来配置如何解析和执行<code>@Sql</code>注解配置的脚本。</p>
<pre><code class="language-java">@Test
@Sql(
    scripts = &quot;/test-user-data.sql&quot;,
    config = @SqlConfig(commentPrefix = &quot;`&quot;, separator = &quot;@@&quot;)
)
void userTest(){}
</code></pre>
<h3 id="sqlmergemode"><code>@SqlMergeMode</code></h3>
<p>它是用来设置<code>@Sql</code>注解的方法和类的sql脚本是否融合在一起。如果类和方法上都没有<code>@SqlMergeMode</code>注解，那么默认的<code>OVERRIDE</code>模式将会被使用。在<code>OVERRIDE</code>模式下，方法上声明的<code>@Sql</code>会覆盖掉类上的<code>@Sql</code>声明。</p>
<p>注意方法上的<code>@SqlMergeMode</code>声明会覆盖类上的声明。</p>
<p>作用在类上：</p>
<pre><code class="language-java">@SpringJunitConfig(TestConfig.class)
@Sql(&quot;/test-schema.sql&quot;)
@SqlMergeMode
class UserTests{
    @Test
    @Sql(&quot;/user-test-data-001.sql&quot;)
    void standardUserProfile(){
    }
}
</code></pre>
<p>作用在方法上：</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
@Sql(&quot;/test-schema.sql&quot;)
class UserTests{
    @Test
    @Sql(&quot;/user-test-data-001.sql&quot;)
    @SqlMergeMode(MERGE)
    void standardUserProfile(){}
}
</code></pre>
<h3 id="sqlgroup"><code>@SqlGroup</code></h3>
<p>它是一个容器注解，内部集成了多个<code>@Sql</code>注解。你可以使用<code>@SqlGroup</code>直接声明多个集成的<code>@Sql</code>，或者你可以配合java8对重复注解的支持来使用，<code>@Sql</code>可以在同一个类和方法上声明多次，隐式的生成注解容器。</p>
<pre><code class="language-java">@Test
@SqlGroup({
    @Sql(scripts = &quot;/test-schema.sql&quot;,config = @SqlConfig(commentPrefix = &quot;`&quot;)),
    @Sql(&quot;/test-user-data.sql&quot;)
})
void userTest(){}
</code></pre>
<h2 id="42-标准注解支持">4.2. 标准注解支持</h2>
<p>下面的注解在任何配置的Spring TestContext框架的标准语法中都支持。注意这些注解并不是专门用来测试的，在Spring框架的任何地方都可以使用。</p>
<ul>
<li><code>@Autowired</code></li>
<li><code>@Qualifier</code></li>
<li><code>@Value</code></li>
<li><code>@Resource</code>(javax.annotation)如果JSR-250存在</li>
<li><code>@ManagedBean</code>(javax.annotation)如果JSR-250存在</li>
<li><code>@Inject</code>(javax.inject)如果JSR-330存在</li>
<li><code>@Named</code>(javax.inject)如果JSR-330存在</li>
<li><code>@PersistenceContext</code>(javax.persistence)如果JPA存在</li>
<li><code>@PersistenceUnit</code>(javax.persistence)如果JPA存在</li>
<li><code>@Required</code></li>
<li><code>@Transactional</code>(org.springframework.transaction.annotation)<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tx-attribute-support">部分属性支持</a></li>
</ul>
<blockquote>
<p>JSR-250生命周期注解<br>
在Spring TestContext框架中，你可以在<code>ApplicationContext</code>内部配置的任何应用组件上以标准语法使用<code>@PostConstruct</code>和<code>@PreDestroy</code>。但是在实际测试类中，这些生命周期注解还是有使用限制的。</p>
<p>如果一个方法在测试类中，并且被注解<code>@PostConstruct</code>修饰，那么这个方法会在底层测试框架的所有before方法之前执行（举个例子，任何被JUnit Jupiter的<code>@BeforeEach</code>注解修饰的方法），并且他会被应用在测试类中的每个测试方法上。另一方面，如果一个方法在测试类中被<code>@PreDestroy</code>注解修饰，那么这个方法永远不会运行。所以，在一个测试类中，我们推荐使用来自测试框架的生命周期的回调函数，而不是<code>@PostConstruct</code>和<code>@PreDestroy</code>。</p>
</blockquote>
<h2 id="43-spring-junit-4-测试注解">4.3. Spring JUnit 4 测试注解</h2>
<p>下面的注解仅在与 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit4-runner">SpringRunner</a> ，<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit4-rules">Spring&rsquo;s JUnit 4 rules</a> ,或者<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-support-classes-junit4">Spring’s JUnit 4 support classes</a> 配合使用时才有效：</p>
<ul>
<li><code>@IfProfileValue</code></li>
<li><code>@ProfileValueSourceConfiguration</code></li>
<li><code>@Timed</code></li>
<li><code>@Repeat</code></li>
</ul>
<h3 id="ifprofilevalue"><code>IfProfileValue</code></h3>
<p>它代表注解修饰的测试只在指定测试环境生效。如果<code>ProfileValueSource</code>的属性<code>value</code>跟<code>name</code>的值匹配，这个测试才生效。否则，这个测试不会启用。</p>
<p>你可以声明<code>IfProfileValue</code>在类或者方法上。类级别的使用优先于方法级别的使用，特别是针对类下的所有方法或者所有子类的时候。要启用一个测试，他的类和方法都要是启用状态，但是在默认没有声明<code>IfProfileValue</code>的情况下，就代表着启用状态。JUnit4的<code>@Ignore</code>注解跟它类似，除了<code>@Ignore</code>只能用来屏蔽测试。</p>
<p>使用实例：</p>
<pre><code class="language-java">@IfProfileValue(name = &quot;java.vendor&quot;, value=&quot;Oracle Corporation&quot;)
@Test
public void testProcessWithRunsOnlyOnOracleJvm(){}
</code></pre>
<p>另外，你可以为<code>@IfProfileValue</code>配置一个<code>values</code>集合，就像TestNG在JUnit4环境支持测试组一样：</p>
<pre><code class="language-java">@Test
@IfProfileValue(name = &quot;test-groups&quot;, values={&quot;unit-tests&quot;,&quot;integration-tests&quot;})
public void testProcessWhichRunsForUnitOrIntegrationTestGroups(){}
</code></pre>
<h3 id="profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></h3>
<p>它是一个类级别的注解，它指定了当通过<code>@IfProfileValue</code>注解检索配置值的时候该使用什么类型的<code>ProfileValueSource</code>。如果该注解没有在测试上声明，<code>SystemProfileValueSource</code>会被作为默认值。</p>
<p>使用实例：</p>
<pre><code class="language-java">@Test
@ProfileValueSourceConfiguration(CustomProfileValueSource.class)
public class CustomProfileValueSourceTests(){}
</code></pre>
<h3 id="timed"><code>@Timed</code></h3>
<p><code>@Timed</code>代表备注接的测试方法必须在指定的时间段内完成（微秒）。如果测试时间超过了指定的时间段，则测试失败。</p>
<p>这个时间段包括运行测试方法自身的时间，以及重复测试的时间（<code>@Repeat</code>)，也包括其他测试资源的安装和卸载时间。</p>
<pre><code class="language-java">@Timed(millis = 1000)
public void testProcessWithOneSecondTimeout(){
}
</code></pre>
<p>Spring的<code>@Timed</code>语法跟JUnit4的语法<code>@Test(timeout=...)</code>不同，是因为JUnit4处理测试执行超时的处理方式（在单独的一个分支执行测试方法），如果测试超时<code>@Test(timeout=...)</code>会立即让测试失败。但Spring的<code>@Timed</code>不同，在标识失败之前，他会让测试方法先走完。</p>
<h3 id="repeat"><code>@Repeat</code></h3>
<p>它代表注解的测试方法必定会重复执行。重复执行的次数需要指定在注解参数中</p>
<p>除了重复执行测试方法本身，测试资源的安装和卸载也会被重复执行。</p>
<pre><code class="language-java">@Repeat(10)
@Test
public void testProcessRepeatedly(){}
</code></pre>
<h2 id="44-spring-junit-jupiter-测试注解">4.4. Spring JUnit Jupiter 测试注解</h2>
<p>下面的注解只在配合<code>SpringExtension</code>和JUnit Jupiter(也就是JUnit5的编程模型)使用时才可用</p>
<ul>
<li><code>@SpringJUnitConfig</code></li>
<li><code>@SpringJUnitWebConfig</code></li>
<li><code>@TestConstructor</code></li>
<li><code>@NestedTestConfiguration</code></li>
<li><code>@EnabledIf</code></li>
<li><code>@DisabledIf</code></li>
</ul>
<h3 id="springjunitconfig"><code>@SpringJUnitConfig</code></h3>
<p>它是一个集成的注解，他是由来自JUnit Jupiter的<code>@ExtendWith(SpringExtension.class)</code>和来自Spring TestContext框架的<code>@ContextConfiguration</code>组成的。他可以作用在类上以替代<code>@ContextConfiguration</code>。关于配置选项，<code>@ContextConfiguration</code>和<code>@SpringJUnitConfig</code>唯一的区别是在<code>@SpringJUnitConfig</code>可以用<code>value</code>属性声明组件类。</p>
<p>下面的例子展示了如何使用<code>@SpringJUnitConfig</code>注解指定一个配置类：</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
class ConfigurationClassJUnitJupiterSpringTests{
}
</code></pre>
<p>下面的例子展示了如何使用<code>@SpringJUnitConfig</code>注解指定一个配置文件的位置：</p>
<pre><code class="language-java">@SpringJUnitConfig(locations = &quot;/test-config.xml&quot;)
class XmlJUnitJupiterSpringTests{
}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management">Context Management</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html">@SpringJUnitConfig</a> ，<code>@ContextConfiguration</code>的API文档</p>
<h3 id="springjunitwebconfig"><code>@SpringJUnitWebConfig</code></h3>
<p>它是一个复合注解，是由来自JUnit Jupiter的<code>@ExtendWith(SprintExtension.class)</code>与来自Spring TestContext框架的<code>ContextConfiguration</code>、<code>@WebAppConfiguration</code>构成。你可以将他申明在类上，它可以用来代替<code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code>。关于配置选项，<code>@ContextConfiguration</code>和<code>@SpringJUnitWebConfig</code>的唯一区别是<code>@SpringJUnitWebConfig</code>可以使用<code>value</code>属性来声明组件类。另外你可以覆盖<code>@WebAppConfiguration</code>的<code>value</code>属性，通过<code>@SpringJUnitWebConfig</code>的<code>resourcePath</code>属性。</p>
<p>下面的例子展示了如何指定一个配置类：</p>
<pre><code class="language-java">@SpringJUnitWebConfig(TestConfig.class)
class ConfigurationClassJUnitJupiterSpringWebTests{}
</code></pre>
<p>下面的例子展示了如何指定一个配置文件的路径：</p>
<pre><code class="language-java">@SpringJUnitWebConfig(locations = &quot;/test-config.xml&quot;)
class XmlJUnitJupiterSpringWebTests{}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management">Context Management</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html">@SpringJUnitWebConfig</a> ，<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/ContextConfiguration.html">@ContextConfiguration</a> ，<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html">@WebAppConfiguration</a></p>
<h3 id="testconstructor">TestConstructor</h3>
<p>它是一个类级别的注解，用来配置如何将测试的<code>ApplicationContext</code>组件参数装配到测试类构造方法的参数中。</p>
<p>如果<code>@TestConstructor</code>不存在，那么会有一个默认的装配模式被使用。下面的提示展示了如何改变默认模式。注意，如果构造器上有一个<code>@Autowired</code>注解，那么<code>@TestConstructor</code>和默认模式都会被覆盖。</p>
<blockquote>
<p><strong>改变测试构造方法的默认装配模式</strong>
要改变默认的装配模式可以通过设置<code>spring.test.constructor.autowire.mode</code>JVM 系统属性为<code>all</code>。还可以通过设置<code>SpringProperties</code>机制来完成。</p>
<p>从Spring Framework 5.3开始，默认模式可以设置为一个<a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-config-params">JUnit Platform configuration parameter</a></p>
<p>如果<code>spring.test.constructor.autowire.mode</code>属性没有设置，那么测试类的构造函数将不会自动装配</p>
</blockquote>
<blockquote>
<p>从Spring Framework 5.2开始，在使用JUnit Jupiter时<code>TestConstructor</code>只能和<code>SpringExtension</code>配合使用。注意在大多数境况下，<code>SpringExtension</code>已经为你自动注册完成了-比如在用了<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>或者各种来自Spring Boot测试相关的注解时</p>
</blockquote>
<h3 id="nestedtestconfiguration"><code>@NestedTestConfiguration</code></h3>
<p>它是一个类级别的注解，被用来设置Spring测试配置注解如何在内部测试类中运行。</p>
<p>如果它没有在测试类显性申明，在他的父类结构，或者在他的封闭类结构中，默认的封闭配置继承模型会被使用。下面的提示展示如何修改默认模式。</p>
<blockquote>
<p><strong>改变默认的封闭配置继承模式</strong><br>
默认的封闭配置继承模式是<code>INHERIT</code>，要改变默认的模式可以通过设置<code>spring.test.enclosing.configuration</code>JVM系统属性为<code>OVERRIDE</code>.还可以通过<code>SpringProperties</code>机制来改变</p>
</blockquote>
<p>支持<code>@NestedTestConfiguration</code>语法的Spring测试框架注解：</p>
<ul>
<li><code>@BootstrapWith</code></li>
<li><code>@ContextConfiguration</code></li>
<li><code>@WebAppConfiguration</code></li>
<li><code>@ContextHierarchy</code></li>
<li><code>@ActiveProfiles</code></li>
<li><code>@TestPropertySource</code></li>
<li><code>@DiritesContext</code></li>
<li><code>@TestExecutionListeners</code></li>
<li><code>@Transactional</code></li>
<li><code>@Commit</code></li>
<li><code>@Rollback</code></li>
<li><code>@Sql</code></li>
<li><code>@SqlConfig</code></li>
<li><code>@SqlMergeMode</code></li>
<li><code>@TestContructor</code></li>
</ul>
<blockquote>
<p>通常情况下<code>@NestedTestConfiguration</code>注解需要和<code>@Nested</code>注解结合使用在JUnit Jupiter中才有意义；但是可能有其他Spring支持的测试框架和继承测试类使用了该注解。</p>
</blockquote>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration">@Nested test class configuration </a></p>
<h3 id="enabledif"><code>@EnabledIf</code></h3>
<p>它表示它修饰的JUnit Jupiter类或者测试方法是否启用，由提供的<code>expression</code>结果决定。具体来说，如果一个表达式的计算结果是<code>Boolean.TRUE</code>或者一个<code>String</code>equal为<code>true</code>(忽略大小写)，这个测试就是启用的。当应用于类级别时，所有在该类中的测试方法都会默认启用。</p>
<p>以下的表达式都可用：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions">Spring Expression Language</a> 。举个例子：<code>@EnabledIf(&quot;#{systemProperties\['os.name'].toLowerCase().contains('mac')}&quot;)</code></li>
<li>Spring <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment">Environment</a> 中可用的属性占位符。举个例子：<code>@EnabledIf(&quot;${smoke.tests.enabled}&quot;)</code></li>
<li>文本。比如：<code>@EnabledIf(&quot;true&quot;)</code></li>
</ul>
<p>注意文本表达式如果不是动态的属性占位符的解析结果，那将没有任何意义，因为<code>@EnableIf(&quot;false&quot;)</code>等于<code>@Disabled</code>，并且<code>@EnabledIf(&quot;true&quot;)</code>也没有任何意义。</p>
<p>你可以将<code>@EnabledIf</code>作为一个元注解去创建自定义的复合注解。比如，你可以创建一个自定义的<code>@EnabledOnMac</code>注解：</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = &quot;#{systemProperties['os.name'].toLowerCase().contains('mac')}&quot;,
    reason = &quot;Enabled on Mac OS&quot;
)
public @interface EnabledOnMac{}
</code></pre>
<h3 id="disabledif"><code>@DisabledIf</code></h3>
<p>它表示它修饰的JUnit Jupiter类或者测试方法是否弃用，由提供的<code>expression</code>结果决定。具体来说，如果一个表达式的计算结果是<code>Boolean.TRUE</code>或者一个<code>String</code>equal为<code>true</code>(忽略大小写)，这个测试就是弃用的。当应用于类级别时，所有在该类中的测试方法都会默认弃用。</p>
<p>以下的表达式都可用：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions">Spring Expression Language</a> 。举个例子：<code>@DisabledIf(&quot;#{systemProperties\['os.name'].toLowerCase().contains('mac')}&quot;)</code></li>
<li>Spring <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment">Environment</a> 中可用的属性占位符。举个例子：<code>@DisabledIf(&quot;${smoke.tests.enabled}&quot;)</code></li>
<li>文本。比如：<code>@DisabledIf(&quot;true&quot;)</code></li>
</ul>
<p>注意文本表达式如果不是动态的属性占位符的解析结果，那将没有任何意义，因为<code>@DisabledIf(&quot;true&quot;)</code>等于<code>@Disabled</code>，并且<code>@EnabledIf(&quot;false&quot;)</code>也没有任何意义。</p>
<p>你可以将<code>@DisabledIf</code>作为一个元注解去创建自定义的复合注解。比如，你可以创建一个自定义的<code>@DisabledOnMac</code>注解：</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = &quot;#{systemProperties['os.name'].toLowerCase().contains('mac')}&quot;,
    reason = &quot;Disabled on Mac OS&quot;
)
public @interface DisabledOnMac {}
</code></pre>
<h2 id="45-测试元注解">4.5. 测试元注解</h2>
<p>你可以使用大多数测试相关的注解作为元注解去创建自定义的复合注解，那样可以减少测试套件的重复配置。</p>
<p>你可以使用下面任何一个注解作为元注解：</p>
<ul>
<li>@BootstrapWith</li>
<li>@ContextConfiguration</li>
<li>@ContextHierarchy</li>
<li>@ActiveProfiles</li>
<li>@TestPropertySource</li>
<li>@DirtiesContext</li>
<li>@WebAppConfiguration</li>
<li>@TestExecutionListeners</li>
<li>@Transactional</li>
<li>@BeforeTransaction</li>
<li>@AfterTransaction</li>
<li>@Commit</li>
<li>@Rollback</li>
<li>@Sql</li>
<li>@SqlConfig</li>
<li>@SqlMergeMode</li>
<li>@SqlGroup</li>
<li>@Repeat (only supported on JUnit 4)</li>
<li>@Timed (only supported on JUnit 4)</li>
<li>@IfProfileValue (only supported on JUnit 4)</li>
<li>@ProfileValueSourceConfiguration (only supported on JUnit 4)</li>
<li>@SpringJUnitConfig (only supported on JUnit Jupiter)</li>
<li>@SpringJUnitWebConfig (only supported on JUnit Jupiter)</li>
<li>@TestConstructor (only supported on JUnit Jupiter)</li>
<li>@NestedTestConfiguration (only supported on JUnit Jupiter)</li>
<li>@EnabledIf (only supported on JUnit Jupiter)</li>
<li>@DisabledIf (only supported on JUnit Jupiter)</li>
</ul>
<p>考虑下面的例子：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@ContextConfiguration({&quot;/app-config.xml&quot;,&quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public class OrderRepositoryTests{}

@RunWith(SpringRunner.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public class UserRepositoryTests{}
</code></pre>
<p>观察上面的Spring测试注解配置基本都是重复的，可以通过自定义注解合并他们：</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public @interface TransactionalDevTestConfig {}
</code></pre>
<p>然后你就可以直接使用这个自定义注解去简化JUnit4为基础的测试类：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class OrderRepositoryTests{}

@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class UserRepositoryTests {}
</code></pre>
<p>如果我们使用JUnit Jupiter进行测试类编写，那么可以进一步减少重复代码，因为JUnit 5的注解同样可以作为元注解：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
class OrderRepositoryTest{}

@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
class UserRepositoryTests{}
</code></pre>
<p>观察上面的Spring测试注解配置基本都是重复的，可以通过自定义注解合并他们：</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;})
@ActiveProfiles(&quot;dev&quot;)
@Transactional
public @interface TransactionalDevTestConfig { }
</code></pre>
<p>然后你就可以直接使用这个自定义注解去简化JUnit5为基础的测试类：</p>
<pre><code class="language-java">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }
</code></pre>
<p>因为JUnit Jupiter支持<code>@Test</code>,<code>@RepeatedTest</code>,<code>ParameterizedTest</code>等等作为源注解，所以你也可以创建基于方法级别的自定义复合注解，比如我们创建一个注解它结合了来自JUnit Jupiter的<code>@Test</code>，<code>@Tag</code>和来自Spring的<code>@Transactional</code>：</p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Tag(&quot;integration-test&quot;) // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
public @interface TransactionalIntegrationTest {
}
</code></pre>
<p>然后我们可以在任何JUnit Jupiter测试方法上使用它们：</p>
<pre><code class="language-java">@TransactionalIntegrationTest
void saveOrder() { }

@TransactionalIntegrationTest
void deleteOrder() { }
</code></pre>
<p>详情参考<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a></p>
<h1 id="5-spring-testcontext-framework">5. Spring TestContext Framework</h1>
<p>Spring TestContext Framework(在<code>org.springframework.test.context</code>包下)，提供了通用的，注解驱动的单元和集成测试，并且不跟你的测试框架耦合。TestContext framework更看重约定而不是配置，有合理的默认值，并且你可以通过注解参数来修改它。</p>
<p>另外对于常见的测试架构：JUnit 4，JUnit Jupiter(JUnit 5)，和TestNG，TestContext framework提供了特定的支持。对于JUnit4和TestNG，spring提供了<code>abstract</code>支持类。此外，Spring为JUnit4提供了自定义JUnit<code>Runner</code>和自定义JUnit<code>Rules</code>，并且为JUnit Jupiter提供了自定义的<code>Extension</code>，它们可以让你编写所谓的POJO测试类。POJO测试类就是测试类不需要继承一个特定的类结构，比如<code>abstarct</code>父类。</p>
<p>下面的章节提供了一个TestContext framework的概览。如果你只对使用框架有兴趣，对扩展自定义监听或者自定义加载器不感兴趣的话，可以直接跳过这个章节。</p>
<h2 id="51-关键抽象概念">5.1. 关键抽象概念</h2>
<p>框架的核心是由<code>TestContextManager</code>、<code>TestContext</code>、<code>TestExecutionListener</code>、和<code>SmartContextLoader</code>接口组成。每个测试类都会创建一个<code>TestContextManager</code>。反过来，<code>TestContextManger</code>管理着一个<code>TestContext</code>，这个<code>TestContext</code>保存着当前测试的上下文参数。在测试进行中<code>TestContextManger</code>同时也更新<code>TestContext</code>的状态，并且委托给<code>TestExecutionListener</code>的实现，它会通过依赖注入来检测实际测试的运行，管理事务等等。一个<code>SmartContextLoader</code>负责为一个给定的测试类加载<code>ApplicationContext</code>。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/package-summary.html">javadoc</a></p>
<h3 id="testcontext"><code>TestContext</code></h3>
<p><code>TestContext</code>封装了测试运行所在的上下文（忽略具体的测试框架）并为其所负责的测试实例提供上下文管理和缓存支持。<code>TestContext</code>还能委托<code>SmarkContextLoader</code>去加载<code>ApplicationContext</code>。</p>
<h3 id="testcontextmanager"><code>TestContextManager</code></h3>
<p><code>TestContextManger</code>是Spring TestContext Framework的主要切入点，它负责管理一个单独的<code>TestContext</code>并且给每个已经注册的<code>TestExcutionListener</code>在以下定义良好的测试执行点发送信号：</p>
<ul>
<li>在任何&quot;before class&quot;或者&quot;before all&quot;方法之前</li>
<li>测试实例的后期处理</li>
<li>在任何&quot;before&quot;或者&quot;before each&quot;方法之前</li>
<li>在测试方法执行之前但在测试初始化之后</li>
<li>在测试方法执行之后但在测试销毁之前</li>
<li>在任何&quot;after&quot;或者&quot;after each&quot;方法执行之后</li>
<li>在任何&quot;after class&quot;或者&quot;after all&quot;方法执行之后</li>
</ul>
<h3 id="testexecutionlistener"><code>TestExecutionListener</code></h3>
<p><code>TestExecutionListener</code>定义了一系列测试监听API，它们又<code>TestContextManager</code>注册和发布。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tel-config">TestExecutionListener Configuration</a></p>
<h3 id="contextloaders"><code>ContextLoaders</code></h3>
<p><code>ContextLoaders</code>是一个策略接口为一个Spring TestContext Framework管理的集成测试加载一个<code>ApplicationContext</code>。要提供组件类，激活bean定义配置，测试属性资源，上下文结构，和<code>WebApplicationContext</code>的支持你应该实现<code>SmartContextLoader</code>而不是这个接口。</p>
<p><code>SmartContextLoader</code>是<code>ContextLoader</code>接口的扩展，它接替了原始<code>ContextLoader</code>极少的SPI。具体来说，一个<code>SmartContextLoader</code>可以选择去处理资源位置，组件类，或者上下文初始化。其次，一个<code>SmartContextLoader</code>可以设置启用bean定义配置和上下文加载的测试属性资源。</p>
<p>Spring提供了下面的实现：</p>
<ul>
<li><code>DelegatingSmartContextLoader</code>：两个默认加载器之一，它委托给内部的一个<code>AnnotationConfigContextLoader</code>，一个<code>GenericXmlContextLoader</code>，或者一个<code>GenericGroovyXmlContextLoader</code>，取决于测试类的配置声明，或者存在的默认位置或者默认配置类。Groovy支持只在classpath目录下有Groovy时才可用。</li>
<li><code>WebDelegatingSmartContextLoader</code>:两个默认加载器之一,它委托给内部的一个<code>AnnotationConfigWebContextLoader</code>，一个<code>GenericXmlWebContextLoader</code>，或者一个<code>GenericGroovyXmlWebContextLoader</code>，取决于测试类的配置声明，或者存在的默认位置或者默认配置类。只有在测试类上有<code>@WebAppConfiguration</code>存在时，才能使用web<code>ContextLoader</code>。Groovy支持只在classpath目录下有Groovy时才可用。</li>
<li><code>AnnotationConfigContextLoader</code>:用组件类加载一个标准的<code>ApplicationContext</code></li>
<li><code>AnnotationConfigWebContextLoader</code>:用组件类加载一个<code>WebApplicationContext</code></li>
<li><code>GenericGroovyXmlContextLoader</code>:用Groovy脚本或者XML配置文件加载一个标准的<code>ApplicationContext</code></li>
<li><code>GenericGroovyXmlWebContextLoader</code>:用Groovy脚本或者XML配置文件加载一个<code>WebApplicationContext</code></li>
<li><code>GenericXmlContextLoader</code>:用XML资源地址加载一个标准的<code>ApplicationContext</code></li>
<li><code>GenericXmlWebContextLoader</code>:用XML资源地址加载一个<code>WepApplicationContext</code></li>
</ul>
<h2 id="52-引导testcontext-framework">5.2. 引导TestContext Framework</h2>
<p>Spring TestContext Framework内部的默认配置对于一般的使用情况已经足够了。但是，有时开发团队或者第三方框架想改变默认的<code>ContextLoader</code>，实现自定义的<code>TestContext</code>或者<code>ContextCache</code>，增加默认的<code>ContextCustomizerFactory</code>和<code>TestExecutionListener</code>实现集合等等操作。对于这种对TestContext 框架操作的底层的控制，Spring提供了一个引导策略。</p>
<p><code>TestContextBootstrapper</code>为TestContext框架定义了SPI。一个<code>TestContextBootstrapper</code>通过<code>TextContextManager</code>被用来为当前测试加载<code>TestExecutionListener</code>实现和构建他管理的<code>TestContext</code>。你可以通过<code>@BootstrapWith</code>为测试类（或者测试类结构）配置一个自定义的引导策略，可以直接使用<code>@BootstrapWith</code>或者把它作为一个元注解.如果没有显式的指定<code>@BootstrapWith</code>，默认情况下使用<code>DefaultTestContextBootstrapper</code>或者<code>WebTestContextBootstrapper</code>，取决于<code>@WebAppConfiguration</code>是否存在</p>
<p>因为<code>TestContextBootstrapper</code>SPI很可能在未来更改(去适应新需求),我们强烈建议继承<code>AbstractTestContextBootstrapper</code>类或者他的某个具体的字类,而不是实现<code>TestContextBootstrapper</code>这个接口</p>
<h2 id="53-testexecutionlistener配置">5.3. <code>TestExecutionListener</code>配置</h2>
<p>Spring提供了下面的<code>TestExecutionListener</code>实现，他们是被默认注册的，按照下面的顺序：</p>
<ul>
<li><code>ServletTestExecutionListener</code>:为<code>WebApplicationContext</code>配置Servlet API模拟。</li>
<li><code>DirtiesContextBeforeModesTestExecutionListener</code>:为&quot;before&quot;模式处理<code>@DirtiesContext</code>注解。</li>
<li><code>DependencyInjectionTestExecutionListener</code>:为测试实例提供依赖注入.</li>
<li><code>DirtiesContextTestExecutionListener</code>:为&quot;after&quot;模式处理<code>@DirtiesContext</code>注解。</li>
<li><code>TransactionalTestExecutionListener</code>:提供默认的rollback的事务测试执行。</li>
<li><code>SqlScriptsTestExecutionListener</code>:使用<code>@Sql</code>注解时运行配置的SQL脚本.</li>
<li><code>EventPublishingTestExecutionListener</code>:为测试的<code>ApplicationContext</code>发布测试执行事件(参照<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-test-execution-events">Test Execution Events</a>)  。</li>
</ul>
<h3 id="注册testexecutionlistener实现">注册<code>TestExecutionListener</code>实现</h3>
<p>你可以为测试类和其字类注册<code>TestExecutionListener</code>实现通过使用<code>@TestExecutionListeners</code>注解。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations">annotation support</a> ,<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">@TestExecutionListeners</a></p>
<h3 id="自动化探索默认的testexecutionlistener实现">自动化探索默认的<code>TestExecutionListener</code>实现</h3>
<p>通过使用<code>@TestExecutionListeners</code>来注册<code>TestExecutionListener</code>实现,适合有限测试方案的自定义监听器。如果自定义监听器要跨越整个测试套件,那么他就会变得十分臃肿。解决这个问题需要通过支持自动探索默认的<code>TestExecutionListener</code>实现来完成，背后依靠<code>SpringFactoriesLoader</code>机制来实现。</p>
<p>具体来说，<code>spring-test</code>模块申明所有的核心默认<code>TestExecutionListener</code>实现都在<code>META-INF/spring.factories</code>属性文件中的<code>org.springframework.test.context.TestExecutionListener</code>key下。第三方框架和开发者可以贡献他们自己的<code>TestExecutionListener</code>到默认的监听者列表，同样通过<code>META-INF/spring.factories</code>属性文件。</p>
<h3 id="testexecutionlistener实现的顺序"><code>TestExecutionListener</code>实现的顺序</h3>
<p>当TestContext框架发现了默认的<code>TesetExecutionListener</code>实现通过前面提到的SpringFactoriesLoader机制，这些初始化的监听器通过spring的<code>AnnotationAwareOrderComparator</code>来排序，而它又使用Spring的<code>Ordered</code>接口和<code>@Order</code>注解来排序。<code>AbstractTestExecutionListener</code>和所有默认的<code>TestExecutionListener</code>都以适当的值实现了<code>Ordered</code>。所以第三方框架和开发者应该确保他们的默认<code>TestExecutionListener</code>实现是是implements<code>Ordered</code>的或者由<code>@Order</code>注解。通过<code>TestExecutionListener</code>实现的<code>getOrder()</code>方法来查看核心监听器的顺序值。</p>
<h3 id="合并testexecutionlistener实现">合并<code>TestExecutionListener</code>实现</h3>
<p>如果一个自定义<code>TestExecutionListener</code>是通过<code>@TestExecutionListeners</code>注册的，那么默认的监听器将不会被注册。在大多数测试场景中，这会强制要求开发者手动申明所有默认的监听器加上用户自定义的监听器：</p>
<pre><code class="language-java">@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}
</code></pre>
<p>这种方法带来的挑战是，你必须要记得所有的默认监听器。并且每个发布版本的监听器可能改变-举个例子<code>SqlScriptsTestExecutionListener</code>是在Spring Framework 4.1引入的，而<code>DirtiesContextBeforeModesTestExecutionListener</code>实在Spring Framework 4.2引入的。此外，第三方框架比如Spring Boot和Spring Security通过前面提到的<code>automatic discovery mechanism</code>注册了他们自己的默认<code>TestExecutionListener</code>实现。</p>
<p>为了避免记住和重新声明所有默认的监听器，你可以设置<code>@TestExecutionListeners</code>的<code>mergeMode</code>属性为<code>MergeMode.MERGE_WITH_DEFAULTS</code>。这个属性值表实本地申明的监听器应该和默认监听器合并。这个合并算法会移除重复的申明，并且会根据<code>AnnotationAwareOrderComparator</code>排序。如果监听器实现了<code>Ordered</code>或者由<code>@Order</code>注解修饰，那么它可以影响默认监听器的排序。否则，本地声明的监听器会追加到默认监听器列表的末尾。</p>
<p>举个例子，如果<code>MyCustomTestExecutionListener</code>类配置了<code>order</code>值（举个例子，500）比<code>ServletTestExecutionListener</code>的order值小(恰好是1000)，<code>MyCustomTestExecutionListener</code>可以自动合并到默认集合中并在<code>ServletTestExecutionListener</code>之前，之前的例子可以替换成下面的代码：</p>
<pre><code class="language-java">@ContextConfiguration
@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}
</code></pre>
<h2 id="54-测试执行事件">5.4. 测试执行事件</h2>
<p>Spring Framework 5.2引入了<code>EventPublishingTestExecutionListener </code>，提供了一个实现自定义<code>TestExecutionListener</code>的替代方法。在测试<code>ApplicationContext</code>中的组件可以通过<code>EventPublishingTestExecutionListener</code>监听下列的事件，每个事件对应<code>TestExecutionListener</code>API中的一个方法。</p>
<ul>
<li><code>BeforeTestClassEvent</code></li>
<li><code>PrepareTestInstanceEvent</code></li>
<li><code>BeforeTestMethodEvent</code></li>
<li><code>BeforeTestExecutionEvent</code></li>
<li><code>AfterTestExecutionEvent</code></li>
<li><code>AfterTestMethodEvent</code></li>
<li><code>AfterTestClassEvent</code></li>
</ul>
<blockquote>
<p>这些事件只有在<code>ApplicationContext</code>已经加载后才发布</p>
</blockquote>
<p>这些事件可能因为多种原因被消费，比如重设模拟bean或者追踪测试执行。选择消费测试执行事件，而不是实现一个自定义<code>TestExecutionListener</code>，其中的一个优点是测试执行事件可以被任何在测试<code>ApplicationContext</code>中注册的Spring bean消耗，这些bean可以直接受利于依赖注入或者<code>ApplicationContext</code>的其他特性。相对应的，在<code>ApplicationContext</code>中的<code>TestExecutionListener</code>并不是一个bean。</p>
<p>为了监听测试执行事件，一个Spring bean可以选择去实现<code>org.springframework.context.ApplicationListener</code>接口。也可以用<code>@EventListener</code>修饰监听方法并且配置监听上面提到的指定事件类型中的一个。因为这个方法的流行，Spring提供了以下专用的<code>@EventListener</code>注解去简化测试执行事件监听器的注册。这些注解是在<code>org.springframework.test.context.event.annotation</code>包下的。</p>
<ul>
<li><code>@BeforeTestClass</code></li>
<li><code>@PrepareTestInstance</code></li>
<li><code>@BeforeTestMethod</code></li>
<li><code>@BeforeTestExecution</code></li>
<li><code>@AfterTestExecution</code></li>
<li><code>@AfterTestMethod</code></li>
<li><code>@AfterTestClass</code></li>
</ul>
<h3 id="异常处理">异常处理</h3>
<p>默认情况下，如果一个测试执行事件监听器在消费事件时抛出了一个异常，这个异常会传递到底层使用的测试框架上（比如JUnit或者TestNG）。比如在消费<code>BeforeTestMethodEvent</code>时抛出一个异常，对应的测试方法将会失败。相反，如果一个异步的测试执行事件监听器抛出一个异常，这个异常是不会传递到底层的测试框架的。异步异常处理的详情，查阅类级别<code>@EventListener</code>的javadoc。</p>
<h3 id="异步监听器">异步监听器</h3>
<p>如果你想要一个特别的测试执行事件监听器去异步处理事件，可以使用Spring的<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling-annotation-support-async">常规<code>@Async</code>支持</a> 。详情查阅类级别<code>@EventListener</code>的javadoc。</p>
<h2 id="55-上下文管理">5.5. 上下文管理</h2>
<p>每个<code>TestContext</code>都为它负责的测试实例提供了上下文管理和缓存支持。测试实例不会自动接收对配置<code>ApplicationContext</code>的访问。但是，如果测试类实现了<code>ApplicationContextAware</code>接口，会为测试实例提供一个<code>ApplicationContext</code>的引用。注意<code>AbstractJUnit4SpringContextTests</code>和<code>AbstractTestNGSpringContextTests</code>实现了<code>ApplicationContextAware</code>，所以自动提供对<code>ApplicationContext</code>的访问。</p>
<blockquote>
<p><strong>@Autowired ApplicationContext</strong>
作为一个实现<code>ApplicationContextAware</code>接口的替代方法，你可以通过设置<code>@Autowired</code>注解在字段上或者setter方法上来注入application context：</p>
<pre><code class="language-java">@SpringJUnitConfig
class MyTest {

   @Autowired 
   ApplicationContext applicationContext;

   // class body...
}
</code></pre>
<p>同样，如果你的测试需要加载一个<code>WebApplicationContext</code>:</p>
<pre><code class="language-java">@SpringJUnitWebConfig
class MyWebAppTest {

   @Autowired 
   WebApplicationContext wac;

   // class body...
}
</code></pre>
<p>通过使用<code>@Autowired</code>进行依赖注入是通过<code>DependencyInjectionTestExecutionListener</code>来提供的，默认情况下就会对它进行配置(参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-fixture-di">https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-fixture-di</a>)</p>
</blockquote>
<p>使用TestContext框架的测试类不需要extends任何特定的类或者实现任何特定接口去配置他们的application context。你只需要在类级别声明一个<code>@ContextConfiguration</code>注解即可。如果你的测试类没有显性的声明application context资源位置或者组件类，配置的<code>ContextLoader</code>会决定怎样从一个默认的位置或者默认的配置类加载一个context。除了资源位置和组件类，一个application context还可以通过application context初始化程序配置。</p>
<p>下面的几个章节阐述了怎样使用Srping的<code>@ContextConfiguration</code>注解去配置一个测试的<code>ApplicationContext</code>通过使用XML配置文件，Groovy脚本，组件类（典型的<code>@Configuration</code>类），或者上下文初始化程序。另外，你可以实现并配置你自定义的<code>SmartContextLoader</code>为高级的使用场景。</p>
<ul>
<li>Context Configuration with XML resources</li>
<li>Context Configuration with Groovy Scripts</li>
<li>Context Configuration with Component Classes</li>
<li>Mixing XML, Groovy Scripts, and Component Classes</li>
<li>Context Configuration with Context Initializers</li>
<li>Context Configuration Inheritance</li>
<li>Context Configuration with Environment Profiles</li>
<li>Context Configuration with Test Property Sources</li>
<li>Context Configuration with Dynamic Property Sources</li>
<li>Loading a <code>WebApplicationContext</code></li>
<li>Context Caching</li>
<li>Context Hierarchies</li>
</ul>
<h3 id="context-configuration-with-xml-resources">Context Configuration with XML resources</h3>
<p>通过XML配置文件为你的测试加载<code>ApplicationContext</code>，需要用<code>@ContextConfiguration</code>注解修饰你的测试类，并用一个由XML文件位置构成的数组来给<code>locations</code>属性赋值。一个相对路径（比如<code>context.xml</code>）会被看做一个classpath资源并且会关联到测试类定义的包下。一个以斜线开头的路径会被看作绝对的classpath路径（比如<code>/org/example/config.xml</code>）。一个路径代表一个资源URL(比如一个路径的前缀是<code>classpath:</code>,<code>file:</code>,<code>http:</code>,等等)。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from &quot;/app-config.xml&quot; and
// &quot;/test-config.xml&quot; in the root of the classpath
@ContextConfiguration(locations={&quot;/app-config.xml&quot;, &quot;/test-config.xml&quot;}) 
class MyTest {
    // class body...
}n
</code></pre>
<p><code>@ContextConfiguration</code>通过标准的Java<code>value</code>属性为<code>locations</code>属性提供了一个别名。所以如果你不在<code>@ContextConfiguration</code>申明额外的属性，你可以省略<code>locations</code>：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({&quot;/app-config.xml&quot;, &quot;/test-config.xml&quot;}) 
class MyTest {
    // class body...
}
</code></pre>
<p>如果你<code>locations</code>和<code>value</code>属性都没有声明，那么TestContext框架会尝试检测默认的XML资源路径。具体来说，<code>GenericXmlContextLoader </code>和<code>GenericXmlWebContextLoader </code>会基于测试类的名称检测资源路径。如果你的类名为<code>com.example.MyTest</code>，<code>GenericXmlContextLoader</code>会从<code>classpath:com/example/MyTest-context.xml</code>加载你的application context。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// &quot;classpath:com/example/MyTest-context.xml&quot;
@ContextConfiguration 
class MyTest {
    // class body...
}
</code></pre>
<h3 id="context-configuration-with-groovy-scripts">Context Configuration with Groovy Scripts</h3>
<p>通过使用<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#groovy-bean-definition-dsl">Groovy Bean Definition DSL</a> 生成的Groovy脚本可以为你的测试生成<code>ApplicationContext</code>，配置Groovy的脚本可以通过<code>@ContextConfiguration</code>的<code>locations</code>和<code>value</code>属性来设置Groovy脚本的资源位置。资源查找语法跟XML文件配置一样。</p>
<blockquote>
<p><strong>启用Groovy脚本支持</strong><br>
如果Groovy在classpath路径下，Spring TestContext框架会自动支持用Groovy脚本加载<code>ApplicationContext</code></p>
</blockquote>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from &quot;/AppConfig.groovy&quot; and
// &quot;/TestConfig.groovy&quot; in the root of the classpath
@ContextConfiguration({&quot;/AppConfig.groovy&quot;, &quot;/TestConfig.Groovy&quot;}) 
class MyTest {
    // class body...
}
</code></pre>
<p>如果你同时忽略<code>locations</code>和<code>value</code>属性，测试框架会尝试检测默认的Groovy脚本。具体来说，<code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>会检测一个默认的路径，基于测试类的名称。如果你的类名为<code>com.example.MyTset</code>，Groovy上下文加载器会从<code>classpath:com/example/MyTestContext.groovy</code>加载上下文。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// &quot;classpath:com/example/MyTestContext.groovy&quot;
@ContextConfiguration 
class MyTest {
    // class body...
}
</code></pre>
<blockquote>
<p><strong>同时声明XML配置和Groovy脚本</strong><br>
你可以同时申明XML配置和Groovy脚本通过<code>@Configuration</code>脚本的<code>locations</code>和<code>value</code>属性。如果配置路径以<code>.xml</code>路径结尾，<code>XmlBeanDefinitionReader</code>会用来加载配置。否则会使用<code>GroovyBeanDefinitionReader</code>。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// &quot;/app-config.xml&quot; and &quot;/TestConfig.groovy&quot;
@ContextConfiguration({ &quot;/app-config.xml&quot;, &quot;/TestConfig.groovy&quot; })
class MyTest {
// class body...
}
</code></pre>
</blockquote>
<h3 id="context-configuration-with-component-classes">Context Configuration with Component Classes</h3>
<p>使用组件类为你的测试加载一个<code>ApplicationContext</code>，你可以通过<code>@ContextConfiguration</code>注解，并配置<code>classes</code>属性：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) 
class MyTest {
    // class body...
}
</code></pre>
<blockquote>
<p><strong>Component Classes</strong><br>
&ldquo;Component Class&quot;组件类指的是：</p>
<ul>
<li>被<code>@Configuration</code>修饰的类</li>
<li>一个组件（就是被<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，或者其他原始注解修饰的类）</li>
<li>一个JSR-330编译的类，就是被<code>javax.inject</code>注解修饰的类</li>
<li>任何类包含<code>@Bean</code>方法</li>
<li>任何其他类尝试去注册为一个Spring组件(就是说一个在<code>ApplicationContext</code>里的Spring bean)，可能是利用单个构造方法的自动装配，而不是Spring注解 <br>
查看<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a> 的javadoc查找更多详情。关于注解类的配置和语法，特别注意<code>@Bean</code>Lite模式的讨论。</li>
</ul>
</blockquote>
<p>如果忽略<code>classes</code>属性，TestContext框架会尝试检测默认配置类是否存在。具体来说，<code>AnnotationConfigContextLoader</code>和<code>AnnotationConfigWebContextLoader</code>会检测所有满足配置类实现需求的<code>static</code>集成类，详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a> javadoc。注意配置类的名称是任意的。另外，如果测试类愿意的话他可以包含多个<code>static</code>集成配置类。下面的例子里,<code>OrderServiceTest</code>类声明了一个<code>static</code>集成配置类叫做<code>Config</code>，他会被用来为测试类自动加载<code>ApplicationContext</code>：</p>
<pre><code class="language-java">@SpringJUnitConfig 
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}
</code></pre>
<h3 id="mixing-xml-groovy-scripts-and-component-classes">Mixing XML, Groovy Scripts, and Component Classes</h3>
<p>有时候会存在混合XML文件,Groovy脚本，和组件类去配置一个<code>ApplicationContext</code>的情况。</p>
<p>一些第三方框架（比如SpringBoot）对这种混合类型加载提供了良好的支持。但是对Spring框架本身来说，因为之前Spring不支持这种形式的加载，所以在Spring-test模块中，大多数<code>SmartContextLoader</code>实现是只支持一种资源类型的。但是，这不意味着你写代码的时候只能用一种类型。<code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>有些不同，他们同时支持XML配置文件和Groovy脚本。此外，第三方框架可以通过<code>@ContextConfiguration</code>的属性<code>locations</code>和<code>classes</code>来实现多类型资源支持，并且，有TestContext框架的标准测试支持，你还可以有如下选项：</p>
<p>如果你想使用一组资源位置(xml,groovy脚本)和一组<code>@Configuration</code>类来配置你的测试，你必须选择一个作为入口，这个入口必须include或者import其他的资源。比如说，在XML或者Groovy脚本中，你可以include<code>@Configuration</code>类通过component扫描或者把他们作为一般的Spring Bean定义，反之，在<code>@Configuration</code>类中，你可以使用<code>@ImportResource</code>去导入XML配置文件或者Groovy脚本。注意这个方式在语义上跟生产配置应用相同：在生产配置中，你可以定义XML或者Groovy资源集合抑或<code>@Configuration</code>类集合去加载你的<code>ApplicationContext</code>，但是你仍然可以选择include或者import其他类型的配置。</p>
<h3 id="context-configuration-with-context-initializers">Context Configuration with Context Initializers</h3>
<p>需要通过初始化程序构造<code>ApplicationContext</code>，使用<code>@ContextConfiguration</code>注解的<code>initializers</code>属性即可，该属性需要一个实现<code>ApplicationcontextInitializer</code>类的引用数组。申明初始化构造器之后，他们会被拿来初始化<code>ConfigurableApplicationContext</code>。注意每个初始化程序支持的具体<code>ConfigurableApplicationContext</code>类型必须跟使用中的<code>SmartContextLoader</code>所创建的<code>ApplicationContext</code>类型兼容（通常是<code>GenericApplicationContext</code>）。此外，初始化程序的调用顺序依赖于他们是否实现了Spring的<code>Ordered</code>接口或者以<code>@Order</code>注解修饰或者标准的<code>@Priority</code>注解。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class) 
class MyTest {
    // class body...
}
</code></pre>
<p>如果你没有申明任何xml，groovy脚本或者组件类，仅仅声明了初始化程序，那么初始化程序将负责加载context中的bean-举个例子，通过编程方式从xml文件或者配置类中加载bean定义。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = EntireAppInitializer.class) 
class MyTest {
    // class body...
}
</code></pre>
<h3 id="context-configuration-inheritance">Context Configuration Inheritance</h3>
<p><code>@ContextConfiguration</code>提供了<code>inheritLocations</code>和<code>inheritInitializers</code>属性来设置当前测试类是否从父类继承 <code>资源位置</code>或者<code>组件类</code>和初始化程序</p>
<blockquote>
<p>从Spring Framework 5.3开始，属性为false，配置信息还是可以从包围类继承</p>
</blockquote>
<p>下面的例子展示了测试类<code>ExtendedTests</code>如何按照<code>base-config.xml</code>，<code>extended-config.xml</code>的顺序加载<code>ApplicaitonContext</code>。<code>extened-config.xml</code>可以覆盖<code>base-config.xml</code>中的bean配置。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from &quot;/base-config.xml&quot;
// in the root of the classpath
@ContextConfiguration(&quot;/base-config.xml&quot;) 
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from &quot;/base-config.xml&quot; and
// &quot;/extended-config.xml&quot; in the root of the classpath
@ContextConfiguration(&quot;/extended-config.xml&quot;) 
class ExtendedTest extends BaseTest {
    // class body...
}
</code></pre>
<p>组件类也按照同样的加载顺序，覆盖规则也完全一样：</p>
<pre><code class="language-java">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig.class) 
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig.class) 
class ExtendedTest extends BaseTest {
    // class body...
}
</code></pre>
<p>下面的例子展示了初始化程序的继承关系，他们的执行顺序跟父子关系无关，参考上一章节对初始化程序执行顺序的描述：</p>
<pre><code class="language-java">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = BaseInitializer.class) 
class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = ExtendedInitializer.class) 
class ExtendedTest extends BaseTest {
    // class body...
}
</code></pre>
<h3 id="context-configuration-with-environment-profiles">Context Configuration with Environment Profiles</h3>
<p>当有多个环境的配置时，Spring提供<code>@ActiveProfiles</code>注解，可以让你指定当前激活的环境配置。</p>
<blockquote>
<p>你可以在任何<code>SmartContextLoader</code>的实现类上使用<code>@ActvieProfiles</code>注解，但是旧的<code>ContextLoader</code>实现上是不支持的</p>
</blockquote>
<p>下面是一个xml配置和一个<code>@Configuration</code>配置类</p>
<pre><code class="language-xml">&lt;!-- app-config.xml --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;bean id=&quot;transferService&quot;
            class=&quot;com.bank.service.internal.DefaultTransferService&quot;&gt;
        &lt;constructor-arg ref=&quot;accountRepository&quot;/&gt;
        &lt;constructor-arg ref=&quot;feePolicy&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;accountRepository&quot;
            class=&quot;com.bank.repository.internal.JdbcAccountRepository&quot;&gt;
        &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;feePolicy&quot;
        class=&quot;com.bank.service.internal.ZeroFeePolicy&quot;/&gt;

    &lt;beans profile=&quot;dev&quot;&gt;
        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
            &lt;jdbc:script
                location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
            &lt;jdbc:script
                location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
    &lt;/beans&gt;

    &lt;beans profile=&quot;default&quot;&gt;
        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
            &lt;jdbc:script
                location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from &quot;classpath:/app-config.xml&quot;
@ContextConfiguration(&quot;/app-config.xml&quot;)
@ActiveProfiles(&quot;dev&quot;)
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}
</code></pre>
<p>当<code>TransferServiceTest</code>运行时，他的<code>ApplicationContext</code>会从<code>app-config.xml</code>配置文件加载。查看<code>app-config.xml</code>你会发现，<code>accountRepository</code>有一个<code>dataSource</code>bean依赖，但是这个<code>dataSource</code>bean没有定义为一个顶级的bean，相反，<code>dataSource</code>bean定义了三次，分别在<code>production</code>profile，<code>dev</code>profile，和<code>default</code>profile。</p>
<p>通过<code>@ActiveProfiles(&quot;dev&quot;)</code>，我们命令Spring启用<code>{&quot;dev&quot;}</code>配置信息去加载<code>ApplicationContext</code>。最终，会创建一个集成数据库并填充测试数据，并且<code>accountRepositroy</code>装配时会带上一个开发的<code>DataSource</code>引用。</p>
<p>当没有明确指定一个profile时，Spring会启用<code>default</code>profile。他可以作为一个默认的备用方案。</p>
<p>下面展示如何使用<code>@Configuration</code>替代xml配置：</p>
<pre><code class="language-java">@Configuration
@Profile(&quot;dev&quot;)
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)
            .build();
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@Profile(&quot;production&quot;)
public class JndiDataConfig {

    @Bean(destroyMethod=&quot;&quot;)
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/datasource&quot;);
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@Profile(&quot;default&quot;)
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .build();
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
public class TransferServiceConfig {

    @Autowired DataSource dataSource;

    @Bean
    public TransferService transferService() {
        return new DefaultTransferService(accountRepository(), feePolicy());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public FeePolicy feePolicy() {
        return new ZeroFeePolicy();
    }
}
</code></pre>
<pre><code class="language-java">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles(&quot;dev&quot;)
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}
</code></pre>
<p>上面的例子中将xml配置文件拆分成四个独立的<code>@Configuration</code>类：</p>
<ul>
<li><code>TransferServiceConfig</code>：使用<code>@Autowired</code>注解通过依赖注入获取一个<code>dataSource</code></li>
<li><code>StandaloneDataConfig</code>：为开发测试定义一个<code>dataSource</code>，它集成了一个数据库</li>
<li><code>JndiDataCOnfig</code>：为生产环境定义一个<code>dataSrouce</code>，从JNDI检索而得</li>
<li><code>DefaultDataConfig</code>：定义一个默认环境，申明了一个集成的数据库</li>
</ul>
<p>跟xml配置一样,<code>TransferServiceTest</code>同样声明了<code>@ActiveProfiles(&quot;dev&quot;)</code>，但是这次申明了所有组件类。测试类的具体内容没有任何改变。</p>
<p>通常情况下，配置信心会用在多个测试类上，为了避免重复申明，可以创建一个基类去配置<code>@ActiveProfiles</code>注解，以及其他注解配置，然后其他的测试类都实现这个基类：</p>
<blockquote>
<p>从Spring Framework 5.3开始，测试配置可以从包围类继承</p>
</blockquote>
<pre><code class="language-java">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles(&quot;dev&quot;)
abstract class AbstractIntegrationTest {
}
</code></pre>
<pre><code class="language-java">// &quot;dev&quot; profile inherited from superclass
class TransferServiceTest extends AbstractIntegrationTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}
</code></pre>
<p><code>@ActvieProfiles</code>注解支持<code>inheritProfiles</code>属性，提供一个boolean值就可以配置是否从父类集成配置信息：</p>
<pre><code class="language-java">// &quot;dev&quot; profile overridden with &quot;production&quot;
@ActiveProfiles(profiles = &quot;production&quot;, inheritProfiles = false)
class ProductionTransferServiceTest extends AbstractIntegrationTest {
    // test body
}
</code></pre>
<p>此外，有些时候只能用编程的形式解析要激活哪个配置信息，而不是用声明的方式-基于下面这几个方面：</p>
<ul>
<li>当前的操作系统</li>
<li>测试是否运行在一个不断集成构建的服务</li>
<li>是否存在某一环境参数</li>
<li>是否存在类级别的自定义注解</li>
<li>其他情况</li>
</ul>
<p>通过编程的方式解析激活的配置，你需要实现<code>ActiveProfilesResolver</code>并且通过<code>resolver</code>属性去注册它。更多信息，请参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html">javadoc</a> ：</p>
<pre><code class="language-java">// &quot;dev&quot; profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver.class,
        inheritProfiles = false)
class TransferServiceTest extends AbstractIntegrationTest {
    // test body
}
</code></pre>
<pre><code class="language-java">public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

    @Override
    public String[] resolve(Class&lt;?&gt; testClass) {
        String profile = ...;
        // determine the value of profile based on the operating system
        return new String[] {profile};
    }
}
</code></pre>
<h3 id="context-configuration-with-test-property-sources">Context Configuration with Test Property Sources</h3>
<p>相对于<code>@Configuration</code>配置的<code>@PropertySource</code>，你同样可以使用<code>@TestPropertySource</code>在测试类上去声明属性资源。这些申明的测试属性资源会被添加到<code>Environment</code>中的<code>PropertySource</code>集合中，为注解的集成测试类加载<code>ApplicationContext</code>。</p>
<blockquote>
<p>你可以在任何实现<code>SmartContextLoader</code>的类上使用<code>@TestPropertySource</code>，但是他不支持在<code>ContextLoader</code>的实现上申明。</p>
<p><code>SmartContextLoader</code>的实现可以通过<code>MergedContextConfiguraiton</code>中的<code>getPropertySourceLocations()</code>和<code>getPropertySourceProperties()</code>方法来合并测试属性资源值。</p>
</blockquote>
<h4 id="声明测试属性资源">声明测试属性资源</h4>
<p>你可以通过<code>@TestPropertySource</code>的<code>locations</code>和<code>value</code>属性来配置测试的属性文件。</p>
<p>传统的和XML基础的属性文件格式都支持-举个例子<code>classpath:/com/example/test.properties</code>或者<code>file:///path/to/file.xml</code></p>
<p>每个path都会被翻译为一个Spring<code>Resource</code>。一个相对路径（比如&quot;test.properties)会被看做一个classpath资源，他指向了当前测试类所在的包。如果一个路径是以斜线开头，会被当做绝对路径（比如：&quot;/org/example/test.xml&rdquo;）。引用了URL的路径（比如说，以<code>classpath:</code>，<code>file:</code>，或者<code>http:</code>开头的路径）会使用指定的资源协议去加载。资源位置通配符（比如<code>*/.properties</code>）是不允许的：每个位置必须被解析为一个具体的<code>.properties</code>或者<code>.xml</code>资源。</p>
<pre><code class="language-java">@ContextConfiguration
@TestPropertySource(&quot;/test.properties&quot;) 
class MyIntegrationTests {
    // class body...
}
</code></pre>
<p>你可以配置内联属性通过<code>properties</code>属性，以key-value的结构赋值，下面的例子会展示如何使用。所有的key-value值对会被添加到包围的<code>Environment</code>中，对一个单独测试<code>PropertySource</code>它们有最高的优先级。</p>
<p>key-value值对支持的语法跟java属性文件中的键值定义语法一样：</p>
<ul>
<li>key=value</li>
<li>key:value</li>
<li>key value</li>
</ul>
<pre><code class="language-java">@ContextConfiguration
@TestPropertySource(properties = {&quot;timezone = GMT&quot;, &quot;port: 4242&quot;}) 
class MyIntegrationTests {
    // class body...
}
</code></pre>
<blockquote>
<p>从Spring Framework 5.2开始，<code>@TestPropertySource</code>可以被用作可重复注解。这意味着你可以为一个测试类声明多次该注解。后面的<code>@TestPropertySource</code>的<code>locations</code>和<code>properties</code>属性会覆盖之前<code>@TestPropertySource</code>声明的。</p>
<p>另外，你申明的复合注解里面可能都包含了<code>@TestPropertySource</code>，那么所有的<code>@TestPropertySource</code>都会为你的测试属性提供资源。</p>
<p>直接声明的<code>@TestPropertySource</code>的优先级都会高于复合注解中的声明</p>
</blockquote>
<h4 id="默认属性文件检测">默认属性文件检测</h4>
<p>如果<code>@TestPropertySource</code>注解的<code>locations</code>和<code>properties</code>属性都没有声明，那么他会查找一个默认的属性文件，路径基于当前注解修饰的测试类所在位置。比如测试类在<code>com.example.MyTest</code>，那么默认的属性文件路径为<code>classpath:com/example/MyTest.properties</code>。如果找不到默认文件，那么将会抛出一个<code>IllegalStateException</code>。</p>
<h4 id="优先级">优先级</h4>
<p>测试配置的属性优先级比操作系环境，java系统，或者任何通过<code>@PropertySource</code>或者编程方式声明的属性配置优先级都要高。因此测试属性可以选择性的覆盖所有系统属性和application属性资源。此外，内联属性的优先级是高于资源位置的。但是，有个例外，由<code>@DynamicPropertySource</code>申明的属性优先级是高于<code>@TestPropertySource</code>的。</p>
<p>下面的例子中，<code>timezone</code>和<code>port</code>属性和定义在<code>/test.properties</code>中的所有属性会覆盖在系统或者application中相同的属性名称配置。此外如果<code>/test.properties</code>中也有<code>timezone</code>和<code>port</code>属性，那么他们会被由<code>properties</code>声明内联属性所覆盖。</p>
<pre><code class="language-java">@ContextConfiguration
@TestPropertySource(
    locations = &quot;/test.properties&quot;,
    properties = {&quot;timezone = GMT&quot;, &quot;port: 4242&quot;}
)
class MyIntegrationTests {
    // class body...
}
</code></pre>
<h4 id="继承并覆盖测试属性资源">继承并覆盖测试属性资源</h4>
<p><code>@TestPropertySource</code>支持<code>inheritLocations</code>和<code>inheritProperties</code>属性来设置是否从父类继承配置位置和内联属性信息，这两个参数的默认值都为ture。在值为ture的情况下，就代表可以从父类继承配置信息，并且如果有相同名称的配置，那么后出现的会覆盖之前的。其他的优先级信息跟前面章节提到的一致。</p>
<p>如果<code>inheritLocations</code>和<code>inheritProperties</code>属性为false，那么一丝就是不从父类继承配置信息，当前测试类的配置会替代父类的。</p>
<blockquote>
<p>从Spring Framework 5.3开始，测试配置可以从环绕类中获取</p>
</blockquote>
<p>下面的例子展示了怎么从父类继承配置资源位置信息：</p>
<pre><code class="language-java">@TestPropertySource(&quot;base.properties&quot;)
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource(&quot;extended.properties&quot;)
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}
</code></pre>
<p>下面的例子展示了如何从父类继承内联属性：</p>
<pre><code class="language-java">@TestPropertySource(properties = &quot;key1 = value1&quot;)
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource(properties = &quot;key2 = value2&quot;)
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}
</code></pre>
<h3 id="context-configuration-with-dynamic-property-sources">Context Configuration with Dynamic Property Sources</h3>
<p>从Spring Framework 5.2.5版本开始，TestContext 框架通过<code>@DynamicPropertySource</code>注解提供了动态属性的支持。这个注解可以在继承测试类需要动态资源属性的时候提供帮助。</p>
<p>相对于作用在类级别的<code>@TestPropertySource</code>，<code>@DynamicPropertySource</code>只能作用在静态方法上，并且该方法必须有一个<code>DynamicPropertyRegistry</code>参数，这个参数被用来向<code>Environment</code>添加 name-value 格式的数据。这些动态的参数值都是通过一个<code>Supplier</code>来提供的，它只有在属性被解析的时候才会调用。通常来说，方法引用就是被用来提供参数的，就像下面的例子一样，使用TestContainers项目去管理一个在Spring <code>ApplicationContext</code>之外的Redis container。通过<code>redis.host</code>和<code>redis.port</code>属性，让redis容器管理的ip和host也对test<code>ApplicationContext</code>的组件可用。这些属性可以通过Spring的<code>Environment</code>抽象访问或者直接在Spring管理的组件中注入-举个例子，分别通过<code>@Value(&quot;${redis.host}&quot;)</code>和<code>@Value(&quot;${redis.port}&quot;)</code>赋值</p>
<blockquote>
<p>如果你的<code>@DynamicPropertySource</code>声明在基类，并且子类测试失败，因为属性值在子类之中已经被改变。那么你需要在基类上声明<code>@DirtiesContext</code>，以确保每个子类的<code>ApplcationContext</code>都有正确的属性值</p>
</blockquote>
<pre><code class="language-java">@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    @Container
    static RedisContainer redis = new RedisContainer();

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add(&quot;redis.host&quot;, redis::getContainerIpAddress);
        registry.add(&quot;redis.port&quot;, redis::getMappedPort);
    }

    // tests ...

}
</code></pre>
<h4 id="优先级-1">优先级</h4>
<p>动态属性拥有最高的优先级，意思就是会覆盖来自<code>@TestPropertySource</code>、操作系统环境、java系统属性、或者通过<code>@PropertySource</code>和编码方式申明的属性。因为他的高优先级特性，可以用来覆盖指定的属性值。</p>
<h3 id="loading-a-webapplicationcontext">Loading a WebApplicationContext</h3>
<p>如果你需要的上下文对象是<code>WebApplcationContext</code>而不是<code>ApplicationContext</code>，那你需要在每个测试类上声明<code>@WebAppConfiguration</code>注解。</p>
<p>在TestContext框架为你的测试类生成<code>WebApplicationContext</code>时，会在后台为你的<code>WebApplicationContext</code>提供一个<code>MockServletContext</code>。默认情况下，<code>MockServletContext</code>的基础资源路径被设定为<code>src/main/webapp</code>。这个相对路径跟JVM的根路径关联（一般来说就是你的项目路径）。如果你熟悉maven项目的Web应用目录结构，你肯定知道WAR根目录的默认位置就是<code>src/main/webapp</code>。你可以提供自定义路径去覆盖默认的（<code>@WebAppConfiguration(&quot;src/test/webapp&quot;)</code>）。如果你想引用的基础资源路径是来自classpath而不是文件系统，可以使用Spring的<code>classpath:</code>前缀。</p>
<p>注意Spring测试对<code>WebApplicationContext</code>实现的支持等同于对<code>ApplicationContext</code>实现的支持。这句话的意思就是<code>ApplicationContext</code>可用的注解，<code>WebaApplicationContext</code>同样可用，并且使用方式也一样-例如：<code>@Configuration</code>、<code>@ContextConfiguration</code>、<code>@ActiveProfiles</code>、<code>@TestExecutionListeners</code>、<code>@Sql</code>、<code>@Rollback</code>，等等其他注解。</p>
<p>下面例子展示如果加载<code>WebApplicationContext</code>。第一个例子展示默认配置：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)

// defaults to &quot;file:src/main/webapp&quot;
@WebAppConfiguration

// detects &quot;WacTests-context.xml&quot; in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}
</code></pre>
<p>如果<code>@WebAppConfiguration</code>没有指定一个基础资源路径，那么默认的<code>file:src/main/webapp</code>路径将会使用。同样的，如果申明<code>@ContextConfiguration</code>没有指定资源<code>locations</code>，组件类，或者context<code>initializers</code>，Spring会尝试在当前测试类的所在路径检测<code>WacTests-context.xml</code>文件，或者静态集成的<code>@Configuration</code>类。</p>
<p>下面的例子展示了如何清晰的声明一个<code>@WebAppConfiguration</code>基础资源路径，和<code>@ContextConfiguration</code>的XML资源路径：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)

// file system resource
@WebAppConfiguration(&quot;webapp&quot;)

// classpath resource
@ContextConfiguration(&quot;/spring/test-servlet-config.xml&quot;)
class WacTests {
    //...
}
</code></pre>
<p>这里有个重要的事情需要注意，默认情况下，<code>@WebAppConfiguration</code>资源路径是以文件系统为基础的，然而<code>@ContextConfiguration</code>资源路径是以classpath为基础的。</p>
<p>下面展示了如果通过Spring前缀改变默认的路径语法：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)

// classpath resource
@WebAppConfiguration(&quot;classpath:test-web-resources&quot;)

// file system resource
@ContextConfiguration(&quot;file:src/main/webapp/WEB-INF/servlet-config.xml&quot;)
class WacTests {
    //...
}
</code></pre>
<h4 id="web-mocks">Web Mocks</h4>
<p>为了提供完整的测试支持，TestContext框架默认启用了<code>ServletTestExecutionListener</code>。当在测试一个<code>WebApplcationContext</code>时，<code>TestExecutionListener</code>在每个测试方法之前，通过Spring Web的<code>RequestContextHolder</code>配置好默认的线程本地状态，并且基于<code>@WebAppConfiguration</code>配置的基础资源路径创建<code>MockHttpServletRequest</code>，<code>MockHttpServletResponse</code>，和<code>ServletWebRequest</code>。<code>ServletTestExecutionListener</code>同时也确保了<code>MockHttpServletRequest</code>和<code>MockHttpServletResponse</code>能够注入到测试实例当中，当测试完毕，他会清空线程本地状态。</p>
<p>下面的实例展示了那些mock对象可以注入到你的测试实例当中。注意<code>WebApplicationContext</code>和<code>MockServletContext</code>都是被缓存起来的通用测试对象，然而其他的mock对象都是每个测试方法维护一个，其中的逻辑是通过<code>ServletTestExecutionListener</code>来实现的。</p>
<pre><code class="language-java">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    WebApplicationContext wac; // cached

    @Autowired
    MockServletContext servletContext; // cached

    @Autowired
    MockHttpSession session;

    @Autowired
    MockHttpServletRequest request;

    @Autowired
    MockHttpServletResponse response;

    @Autowired
    ServletWebRequest webRequest;

    //...
}
</code></pre>
<h3 id="context-caching">Context Caching</h3>
<p>一旦TestContext框架为一个测试加载了<code>ApplicationContext</code>(或者<code>WebApplicationContext</code>)，这个上下文对象会被缓存并且在接下来的测试中复用。测试的上下文对象是否从缓存中读取，要看他是否申明了相同<code>唯一</code>的上下文配置，并且是在同一个<code>测试套件</code>中。要了解测试框架的缓存机制，就必须知道<code>唯一</code>和<code>测试套件</code>分别代表了什么。</p>
<p>Spring测试框架会根据context的配置参数生成一个唯一的key值。下面是影响这个key值的配置参数：</p>
<ul>
<li>locations (from @ContextConfiguration)</li>
<li>classes (from @ContextConfiguration)</li>
<li>contextInitializerClasses (from @ContextConfiguration)</li>
<li>contextCustomizers (from ContextCustomizerFactory) – 这个包含了<code>@DynamicPropertySource</code>的方法以及Spring Boot支持的测试特性，比如<code>@MockBean</code>和<code>@SpyBean</code></li>
<li>contextLoader (from @ContextConfiguration)</li>
<li>parent (from @ContextHierarchy)</li>
<li>activeProfiles (from @ActiveProfiles)</li>
<li>propertySourceLocations (from @TestPropertySource)</li>
<li>propertySourceProperties (from @TestPropertySource)</li>
<li>resourceBasePath (from @WebAppConfiguration)</li>
</ul>
<p>举个例子，<code>TestClassA</code>根据<code>@ContextConfiguration</code>的属性<code>{&quot;app-config.xml&quot;, &quot;test-config.xml&quot;}</code>初始化了context，接下来测试框架会加载该<code>ApplicationContext</code>并且根据前面的路径生成一个key，保存到<code>static</code>上下文缓存中。如果<code>TestClassB</code>同样申明了<code>{&quot;app-config.xml&quot;, &quot;test-config.xml&quot;}</code>，并且没有<code>@WebAppConfiguration</code>，不一样的<code>ContextLoader</code>，不一样的启用配置， 不一样的上下文初始化程序，不一样的测试属性资源，或者不一样的父上下文类，那么这两个类就会共享同一个<code>ApplicationContext</code>。</p>
<blockquote>
<p><strong>测试套件和分支进程</strong><br>
Spring测试框架缓存上下文对象在一个静态的参数里，意思就是如果测试类来自两个不同的进程，就算满足上面两个条件，缓存机制也不可能生效。</p>
<p>因此如果想利用Spring测试的上下文缓存机制，必须确保在同一个进程或者同一个测试套件中。同样，如果通过build框架执行的测试，比如Ant，Maven，或者Gradle，必须确保build框架在测试之间没有fork。比如说，Maven Surefire插件的<code>forkMode</code>如果设置为<code>always</code>或者<code>pertest</code>，那么上下文缓存就不会生效。</p>
</blockquote>
<p>上下文缓存的最大个数是32个。当达到最大值时，一个<code>最近使用最少</code>(LRU)的驱逐策略将会被使用来驱逐和关闭陈旧的上下文。想配置缓存的最大数量，可以通过命令行或者JVM系统属性的构建脚本，名字叫<code>spring.test.context.cache.maxSize</code>。或者通过编程的方式使用<code>SpringProperties</code>设置相同的属性。</p>
<p>缓存多个应用上下文在给定测试套件中会造成测试套件无意义的长时间运行，当然最好是能知道目前有多少个上下文缓存。通过设置<code>org.springframework.test.context.cache</code>的log等级为<code>DEBUG</code>即可实现。</p>
<p>极少数情况测试会污染上下文对象（比如修改bean的定义或者上下文对象的状态），你可以使用<code>@DirtiesContext</code>注解来表示下次测试运行之前重载上下文。这个注解是<code>DirtiesContextBeforeModesTestExecutionListener</code>和<code>DirtiesContextTestExecutionListener</code>提供的，他们两个都是默认启用。</p>
<h3 id="context-hierarchies">Context Hierarchies</h3>
<p>有时候需要用到上下文的层次结构，比如说在开发Spring MVC Web应用的时候，你需要一个由Spring<code>ContextLoaderListener</code>加载的根<code>WebApplicationContext</code>，和一个由Spring<code>DispatcherServlet</code>加载的子<code>WebApplicationContext</code>。由根对象的申明的组件和基础配置会在子对象中通过web指定的组件去调用。</p>
<p><code>@ContextHierarchy</code>注解可以申明context的层次结构。如果一个层次结构中的多个类都有该注解，那么你可以合并或者覆盖指定的并已命名的层级。当需要合并一个给定层级的配置时，他们的资源类型必须一样（XML，或者组件类），否则将会被视为两个层级。</p>
<p>下面的例子是以JUnit Jupiter为基础的，展示了需要使用上下文层次的常见场景。</p>
<h4 id="单个类有上下文层次">单个类有上下文层次</h4>
<p><code>ControllerIntegrationTests</code>展示了一个典型的Spring MVC web应用的测试场景，申明的上下文层次包含两个层级，一个是根<code>WebApplicaitonContext</code>，另外一个是dispatcher servlet<code>WebApplicationContext</code>。测试类中的<code>wac</code>参数，注入的是上下文层次结构中最后的那一个。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = TestAppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class ControllerIntegrationTests {

    @Autowired
    WebApplicationContext wac;

    // ...
}
</code></pre>
<h4 id="类层次中有隐式的父context">类层次中有隐式的父context</h4>
<p>下面的例子展示了父子类的层次结构，一共会加载三个上下文对象， 每个子类上下文都是基于父类上下文：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextConfiguration(&quot;file:src/main/webapp/WEB-INF/applicationContext.xml&quot;)
public abstract class AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration(&quot;/spring/soap-ws-config.xml&quot;))
public class SoapWebServiceTests extends AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration(&quot;/spring/rest-ws-config.xml&quot;))
public class RestWebServiceTests extends AbstractWebTests {}
</code></pre>
<h4 id="类层次中有合并的上下文层次配置">类层次中有合并的上下文层次配置</h4>
<p>下面的例子展示了如何通过指定层级名称去合并上下文配置。一共会加载三个上下文对象，一个是<code>parent</code>，一个是父类<code>child</code>，还有一个是父类和子类<code>child</code>层级之和。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = &quot;parent&quot;, locations = &quot;/app-config.xml&quot;),
    @ContextConfiguration(name = &quot;child&quot;, locations = &quot;/user-config.xml&quot;)
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(name = &quot;child&quot;, locations = &quot;/order-config.xml&quot;)
)
class ExtendedTests extends BaseTests {}
</code></pre>
<h4 id="类层次中有覆盖上下文层次配置">类层次中有覆盖上下文层次配置</h4>
<p>相对于上一个例子，下面要展示的是如果覆盖父类的层级配置。通过设定<code>@ContextConfiguration</code>的参数<code>inheritLocations</code>为<code>false</code>，即可让子类覆盖<code>child</code>层级的配置，并同时继承<code>parent</code>层级。</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = &quot;parent&quot;, locations = &quot;/app-config.xml&quot;),
    @ContextConfiguration(name = &quot;child&quot;, locations = &quot;/user-config.xml&quot;)
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(
        name = &quot;child&quot;,
        locations = &quot;/test-user-config.xml&quot;,
        inheritLocations = false
))
class ExtendedTests extends BaseTests {}
</code></pre>
<blockquote>
<p>如果你在测试中使用<code>@DirtiesContext</code>，并且对应的上下文对象还在一个上下文层级结构中，那么你可以通过<code>hierarchyMode</code>去控制上下文缓存如何清理，详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#spring-testing-annotation-dirtiescontext">@DirtiesContext in Spring Testing Annotations</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/annotation/DirtiesContext.html">@DirtiesContext</a></p>
</blockquote>
<h2 id="56-测试资源的依赖注入">5.6. 测试资源的依赖注入</h2>
<p>当你使用<code>DependencyInjectionTestExecutionListener</code>（默认配置），测试实例中的依赖会从上下文中的bean中注入。你可以使用setter注入，字段注入，或者两者同时存在，取决于你选择哪个注解和你是否要将他们放进setter方法。如果使用JUnit Jupiter你还可以选择构造器注入。为了跟Spring的基于注解的注入支持保持一致，你还可以使用<code>@Autowired</code>注解或者<code>@Inject</code>注解来自JSR-330申明在字段或者setter上。</p>
<blockquote>
<p>对于JUnit Jupiter以外的测试框架，TestContext框架是不参与测试类的初始化的。因此，如果使用<code>@Autowired</code>或者<code>@Inject</code>在构造器上，将不会有任何效果</p>
</blockquote>
<blockquote>
<p>虽然生产代码不鼓励使用字段注入，但是在测试代码中没有这个提议。其中差别的原理是因为你永远不会直接实例化你的测试类。因此，没必要保证能够调用测试类的<code>public</code>构造或者setter方法。</p>
</blockquote>
<p>因为<code>@Autowired</code>是根据类型的自动装配，如果你有多个bean定义了相同的类型，那么你就无法通过这种方式获取正确的bean。 这种情况下，你可以搭配<code>@Qualifier</code>使用<code>@Autowired</code>。或者使用<code>@Inject</code>搭配<code>@Named</code>使用。另外，如果你的测试可以访问他的<code>ApplicationContext</code>，你可以直接查找对应bean：<code>applicationContext.getBean(&quot;titleRepository&quot;,TitleRepository.class)</code>。</p>
<p>如果你不想依赖注入应用到你的测试实例上，不在字段或者setter方法上使用<code>@Autowired</code>或者<code>@Inject</code>。你可以整个关掉依赖注入，通过直接配置<code>@TestExecutionListeners</code>，并且在监听器集合中省略<code>DependencyInjectionTestExecutionListener.class</code>。</p>
<p>考虑测试类中调用<code>HibernateTitleRepository</code>类访问数据库的场景，下面的例子通过依赖注入实现了测试。他们的上下文配置在所有的样例代码之后。</p>
<blockquote>
<p>下面的依赖注入行为不是JUnit Jupiter特有的，所有支持的测试框架都能适配。</p>
<p>下面例子中调用的静态断言方法，省略了<code>import</code></p>
</blockquote>
<p><code>@Autowired</code> field</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration(&quot;repository-config.xml&quot;)
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    HibernateTitleRepository titleRepository;

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}
</code></pre>
<p><code>@Autowired</code> setter</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration(&quot;repository-config.xml&quot;)
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    HibernateTitleRepository titleRepository;

    @Autowired
    void setTitleRepository(HibernateTitleRepository titleRepository) {
        this.titleRepository = titleRepository;
    }

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}
</code></pre>
<p>上面的测试类用了相同的XML上下文文件（repository-config.xml）：</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;
    &lt;bean id=&quot;titleRepository&quot; class=&quot;com.foo.repository.hibernate.HibernateTitleRepository&quot;&gt;
        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;
        &lt;!-- configuration elided for brevity --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<blockquote>
<p>如果你继承了一个Spring提供的测试基类，刚好它使用了<code>@Autowired</code>在一个setter方法上，那么影响的类型可能有多个bean定义在你的应用上下文中（举个例子，多个<code>DataSource</code>bean）。在这种情况下，你可以重写setter方法并且使用<code>@Qualiifier</code>注解去指明一个特定的目标bean，就像下面的例子一样（但也确保委托给超类中的重写方法）：</p>
<pre><code class="language-java">@Autowired
@Override
public void setDataSource(@Qualifier(&quot;myDataSource&quot;) DataSource dataSource) {
  super.setDataSource(dataSource);
}
</code></pre>
<p>指定的qualifier值代表要注入的那个目标<code>DataSource</code>bean。它的值匹配的是<!-- raw HTML omitted -->定义中的<!-- raw HTML omitted -->申明。Bean的名称被用作后备的<code>qualifier</code>值，因此也可以用来有效的指向特定的Bean（Bean id）。</p>
</blockquote>
<h2 id="57-测试request和session范围的bean">5.7. 测试Request和Session范围的bean</h2>
<p>从早期开始Spring就一直支持Request和Session范围的bean，你可以根据下面的步骤来测试你的request范围和session范围的bean：</p>
<ul>
<li>确保你的测试类被<code>@WebAppConfiguration</code>注解修饰。</li>
<li>注入模拟request或者session到你的测试实例中，并且根据需要准备你的测试资源。</li>
<li>通过依赖注入调用<code>WebApplicationContext</code>中配置的web组件。</li>
<li>对模拟对象进行断言。</li>
</ul>
<p>下面的代码片段是一个用户登录案例的XML配置。注意<code>userService</code>bean有一个request范围的<code>loginAction</code>bean依赖。并且，<code>LoginAction</code>通过使用<code>SpEL</code>表达式初始化，表达式从HTTP请求中获取用户名和密码。在我们的测试中，我们希望通过TestContext框架的mock管理来配置这些请求参数。下面首先是配置xml：</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.example.SimpleUserService&quot;
            c:loginAction-ref=&quot;loginAction&quot;/&gt;
    &lt;bean id=&quot;loginAction&quot; class=&quot;com.example.LoginAction&quot;
            c:username=&quot;#{request.getParameter('user')}&quot;
            c:password=&quot;#{request.getParameter('pswd')}&quot;
            scope=&quot;request&quot;&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>在下面的<code>RequestScopedBeanTests</code>类中，我们同时注入了<code>UserService</code>和<code>MockHttpServletRequest</code>到我们的测试实例中。在<code>requestScope()</code>测试方法中，我们通过设置<code>MockHttpServletRequest</code>中的request参数来配置我们的测试资源。当<code>userService</code>的<code>loginUser()</code>方法被调用时，我们可以确定service中访问的<code>loginAction</code>是当前<code>MockHttpServletRequest</code>范围中的。</p>
<pre><code class="language-java">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpServletRequest request;

    @Test
    void requestScope() {
        request.setParameter(&quot;user&quot;, &quot;enigma&quot;);
        request.setParameter(&quot;pswd&quot;, &quot;$pr!ng&quot;);

        LoginResults results = userService.loginUser();
        // assert results
    }
}
</code></pre>
<p>下面的代码片段跟之前的请求范围的bean类似。但是，这次<code>userService</code>bean有了一个session范围的依赖<code>userPreferences</code>bean。注意这个<code>UserPreferences</code>bean通过一个SpEL表达式初始化，它从HTTP session中获取了主题参数。在我们的测试中，需要配置mock session的主题参数。</p>
<pre><code class="language-xml">&lt;beans&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.example.SimpleUserService&quot;
            c:userPreferences-ref=&quot;userPreferences&quot; /&gt;

    &lt;bean id=&quot;userPreferences&quot; class=&quot;com.example.UserPreferences&quot;
            c:theme=&quot;#{session.getAttribute('theme')}&quot;
            scope=&quot;session&quot;&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>在下面的<code>SessionScopedBeanTests</code>类中，我们同时注入<code>UserService</code>和<code>MockHttpService</code>到我们的测试实例当中。在<code>sessionScope()</code>方法中，我们通过设置<code>MockHttpSession</code>中的<code>theme</code>属性来配置我们的测试资源，我们可以确定service内部调用的<code>userPreferences</code>是当前<code>MockHttpSession</code>范围中的。</p>
<pre><code class="language-java">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpSession session;

    @Test
    void sessionScope() throws Exception {
        session.setAttribute(&quot;theme&quot;, &quot;blue&quot;);

        Results results = userService.processUserPreferences();
        // assert results
    }
}
</code></pre>
<h2 id="58-事务管理">5.8. 事务管理</h2>
<p>在TestContext框架中，事务管理是在<code>TransactionalTestExecutionListener</code>中的，并且它是默认配置，即使你不显式的在你的测试类上申明<code>@TestExecutionListeners</code>。为了开启事务支持，你必须配置一个<code>PlatformTransactionManager</code>bean在<code>ApplicationContext</code>中，它是随着<code>@ContextConfiguration</code>语法加载的（详情参考下文）。另外，你必须申明<code>@Transactional</code>注解在测试类或者方法上。</p>
<h3 id="581-测试管理的事务">5.8.1. 测试管理的事务</h3>
<p>测试管理的是事务指的是通过使用<code>TransactionalTestExecutionListener</code>申明管理的或者是编程方式通过<code>TestTransaction</code>。你不应该将它和Spring管理的事务混淆（直接由Spring管理的在测试类的<code>ApplicationContext</code>中的事务），或者应用管理的事务混淆（测试中调用的通过编码方式直接管理的在应用代码中的事务）。Spring管理的事务和应用管理的事务通常都可以参与到测试管理的事务当中。但是，当Spring管理或者应用管理的事务配置的是任何传播类型，而不是<code>REQUIRED</code>或者<code>SUPPORTS</code>类型时，需要特别小心（详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation"> transaction propagation</a></p>
<blockquote>
<p><strong>抢占式超时和测试管理的事务</strong><br>
当使用来自测试框架任何形式的抢占式超时和Spring的测试管理事务配合使用时一定要小心。 <br>
典型的就是，Spring测试支持绑定事务状态到当前的线程上（通过一个<code>java.lang.ThreadLocal</code>参数）在当前的测试方法执行之前。如果测试框架为了支持抢占式超时，在一个新的线程调用当前的测试方法，那么在当前测试方法中的任何action都不会在测试管理的事务当中被调用。结果就是，测试管理的事务不会回滚任何action。相对的，这些action会被提交到持久储存中。</p>
<p>下面就是可能引起这种问题的情形，但并不是全部：</p>
<ul>
<li>JUnit 4的<code>@Test(timeout = ...)</code>支持和<code>TimeOut</code>规则。</li>
<li>JUnit Jupiter 在<code>org.junit.jupiter.api.Assertions</code>类中的<code>assertTimeoutPreemptively(...)</code>方法。</li>
<li>TestNG的<code>@Test(timeOut=...)</code>支持</li>
</ul>
</blockquote>
<h3 id="582-启用和关闭事务">5.8.2 启用和关闭事务</h3>
<p>用<code>@Transactional</code>修饰一个测试方法，可以让测试在事务中运行，默认情况下，该事务会在测试完成后自动回滚。如果测试类被<code>@Transactional</code>修饰，类层次结构中的所有方法都会在事务中运行。测试方法如果没有被<code>@Transactional</code>注解修饰（在类或者方法上），那么测试就不会在事务中运行。注意<code>@Transactional</code>不支持测试生命周期方法——比如说，方法有Jupiter的<code>@BeforeAll</code>，<code>@BeforeEach</code>，等等。此外，测试有<code>@Transactional</code>注解但是<code>propagation</code>属性是<code>NOT_SUPPORTED</code>或者<code>NEVER</code>，方法也不会在事务中运行。</p>
<p><code>@Transactional</code>属性支持</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>是否支持测试管理的事务</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code>和<code>transactionManager</code></td>
<td>yes</td>
</tr>
<tr>
<td><code>propagation</code></td>
<td>只有<code>Propagation.NOT_SUPPORTED</code>和<code>Propagation.NEVER</code>支持</td>
</tr>
<tr>
<td><code>isolation</code></td>
<td>no</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>no</td>
</tr>
<tr>
<td><code>readOnly</code></td>
<td>no</td>
</tr>
<tr>
<td><code>rollbackFor</code>和<code>rollbackForClassName</code></td>
<td>no:使用<code>TestTransaction.flagForRollback()</code>替代</td>
</tr>
<tr>
<td><code>noRollbackFor</code>和<code>noRollbackForClassName</code></td>
<td>no:使用<code>TestTransaction.flagForCommit()</code>代替</td>
</tr>
</tbody>
</table>
<blockquote>
<p>方法级别的生命周期函数——举个例子，被JUnit jupiter的<code>@BeforeEach</code>或者<code>@AfterEach</code>注解修饰的——是运行在测试管理的事务中的。另一方法，suite级别和类级别的生命周期方法——举个例子，被JUnit Jupiter的<code>@BeforeAll</code>或者<code>AfterAll</code>注解修饰的和被TestNG的<code>@BeforeSuite</code>，<code>@AfterSuite</code>，<code>@BeforeClass</code>，或者<code>@AfterClass</code>注解修饰的方法——是不会运行在测试管理的事务当中的。</p>
<p>如果你需要在事务中运行suit级别或者类级别的生命周期方法，你可以注入对应的<code>PlatformTransactionManager</code>到你的测试类中，然后和<code>TransactionTempalte</code>一起使用，通过编码的方式实现事务管理。</p>
</blockquote>
<p>注意，<code>AbstractTransactionalJUnit4SpringContextTests</code>和<code>AbstractTransactionalTestNGSpringContextTests</code>在类级别已经预配置了事务的支持。</p>
<p>下面的例子展示了一个常用的场景：为一个Hibernate为基础的<code>UserRepository</code>写一个集成测试。</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    HibernateUserRepository repository;

    @Autowired
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    @Autowired
    void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    void createUser() {
        // track initial state in test database:
        final int count = countRowsInTable(&quot;user&quot;);

        User user = new User(...);
        repository.save(user);

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + 1);
    }

    private int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    private void assertNumUsers(int expected) {
        assertEquals(&quot;Number of rows in the [user] table.&quot;, expected, countRowsInTable(&quot;user&quot;));
    }
}
</code></pre>
<p>这里是不需要在createUser()方法执行后再去清理数据库的，因为任何改变都会通过<code>TransactionalTestExecutionListener</code>自动回滚。</p>
<h3 id="583-事务回滚和提交行为">5.8.3. 事务回滚和提交行为</h3>
<p>默认情况下，测试执行完成后会默认回滚；但是事务提交和回滚是可以配置的，通过<code>@Commit</code>和<code>@Rollback</code>注解。</p>
<h3 id="584-手写事务管理">5.8.4. 手写事务管理</h3>
<p>你可以通过在<code>TestTransaction</code>中的静态方法来以编码的方式管理事务。举个例子，你可以在测试方法，before方法，和after方法中start或者end当前测试管理的事务或者说rollback或者commit当前测试管理的事务。每当<code>TransactionalTestExecutionListener</code>启用，<code>TestTransaction</code>就是自动支持的。</p>
<p>下面的例子展示了<code>TestTransaction</code>的部分特征，详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html">TestTransaction</a></p>
<pre><code class="language-java">@ContextConfiguration(classes = TestConfig.class)
public class ProgrammaticTransactionManagementTests extends
        AbstractTransactionalJUnit4SpringContextTests {

    @Test
    public void transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2);

        deleteFromTables(&quot;user&quot;);

        // changes to the database will be committed!
        TestTransaction.flagForCommit();
        TestTransaction.end();
        assertFalse(TestTransaction.isActive());
        assertNumUsers(0);

        TestTransaction.start();
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected void assertNumUsers(int expected) {
        assertEquals(&quot;Number of rows in the [user] table.&quot;, expected, countRowsInTable(&quot;user&quot;));
    }
}
</code></pre>
<h3 id="585-在一个事务之外运行代码">5.8.5. 在一个事务之外运行代码</h3>
<p>有些时候，你可能需要在事务测试方法之前或者之后运行代码，并且在事务上下文之外——举个例子，在运行测试之前验证初始化数据库的状态，或者在运行测试之后验证预期的事务提交行为。<code>TransactionalTestExecutionListener</code>为这种场景提供了<code>@BeforeTransaction</code>和<code>@AfterTransaction</code>注解。你可以把他们中的一个用在测试类的<code>void</code>方法上，或者测试接口的任何default<code>void</code>方法，然后<code>TransactionalTestExecutionListener</code>确保方法在合适的时间运行。</p>
<blockquote>
<p>任何before方法(比如JUnit Jupiter的<code>@BeforeEach</code>)和任何after方法（比如JUnit Jupiter的<code>@AfterEach</code>）是运行在一个事务中的。此外，被<code>@BeforeTransaction</code>或者<code>@AfterTransaction</code>修饰的方法，不会在没有事务的测试方法执行流程中运行。</p>
</blockquote>
<h3 id="586-配置一个事务管理器">5.8.6. 配置一个事务管理器</h3>
<p><code>TransactionalTestExecutionListener</code>是期望在测试的<code>ApplicationContext</code>中有一个<code>PlatformTransactionManager</code>的。如果在测试的<code>ApplicationContext</code>中有多个<code>PlatformTransactionManager</code>bean，你可以通过<code>@Transactional(&quot;myTxMgr&quot;)</code>申明qualifier，或者<code>@Transactional(transactionManager = &quot;myTxMgr&quot;)</code>，或者<code>TransactionManagementConfigurer</code>的<code>@Configuration</code>类实现。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-">javadoc for TestContextTransactionUtils.retrieveTransactionManager()</a></p>
<h3 id="587-展示所有事务相关的注解">5.8.7. 展示所有事务相关的注解</h3>
<p>下面展示了所有支持的事务相关的注解：</p>
<pre><code class="language-java">@SpringJUnitConfig
@Transactional(transactionManager = &quot;txMgr&quot;)
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    void verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    void setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    void modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    void tearDownWithinTransaction() {
        // run &quot;tear down&quot; logic within the transaction
    }

    @AfterTransaction
    void verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}
</code></pre>
<blockquote>
<p><strong>当测试ORM代码时避免误报</strong>
当你的测试应用代码修改Hibernate session或者JPA持久上下文状态时，确保刷新底层的工作单元。未能刷新底层的工作单元可能产生误报：你的测试通过，但是相同的代码在线上生产环境抛异常。注意，这可以适用于任何在内存中维护工作单元的ORM框架。<br>
下面的Hibernate为基础的测试实例，一个方法展示了误报，另外一个方法正确的暴露了刷新session的结果：</p>
<pre><code class="language-java">// ...

@Autowired
SessionFactory sessionFactory;

@Transactional
@Test // no expected exception!
public void falsePositive() {
  updateEntityInHibernateSession();
  // False positive: an exception will be thrown once the Hibernate
  // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithSessionFlush() {
  updateEntityInHibernateSession();
  // Manual flush is required to avoid false positive in test
  sessionFactory.getCurrentSession().flush();
}

// ...
</code></pre>
<p>下面的例子展示的是JPA的：</p>
<pre><code class="language-java">// ...

@PersistenceContext
EntityManager entityManager;

@Transactional
@Test // no expected exception!
public void falsePositive() {
  updateEntityInJpaPersistenceContext();
  // False positive: an exception will be thrown once the JPA
  // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithEntityManagerFlush() {
  updateEntityInJpaPersistenceContext();
  // Manual flush is required to avoid false positive in test
  entityManager.flush();
}

// ...
</code></pre>
</blockquote>
<h2 id="59-执行sql脚本">5.9. 执行SQL脚本</h2>
<p>在对一个关系数据库写集成测试的时候，经常需要运行SQL脚本去修改数据库的schema或者插入测试数据到表中。<code>spring-jdbc</code>模块提供了初始化集成或者已存在数据库的支持，通过在<code>ApplicationContext</code>加载时执行SQL脚本。</p>
<p>下面的章节是如何以编码的形式和申明的形式运行SQL脚本</p>
<h3 id="591-编码形式执行sql脚本">5.9.1. 编码形式执行SQL脚本</h3>
<p>Spring提供了下面的选项，以在集成测试方法中编码的形式执行SQL脚本。</p>
<ul>
<li>org.springframework.jdbc.datasource.init.ScriptUtils</li>
<li>org.springframework.jdbc.datasource.init.ResourceDatabasePopulator</li>
<li>org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests</li>
<li>org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests</li>
</ul>
<p><code>ScriptUtils</code>提供了一个有关SQL脚本的静态实用方法集合，并且他主要是为框架内部使用的。但是，如果你需要完全的控制SQL脚本的解析和运行，<code>ScriptUtils</code>可能比之后提到的工具更符合你的需求。详情参考他的<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html">javadoc</a></p>
<p><code>ResourceDatabasePopulator</code>提供了一个对象基础的API通过定义在外部的SQL脚本，手动编码执行填充，初始化，或者清除数据库。<code>ResourceDatabasePopulator</code>提供许多参数，包括：配置字符编码，语句分隔符，注释分隔符，和异常处理。每个配置参数都有一个合理的默认值。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html">javadoc</a> 。要运行<code>ResourceDatabasePopulator</code>配置的脚本，针对<code>java.sql.Connection</code>你可以调用<code>populate(Connection)</code>方法，针对<code>javax.sql.DataSource</code>你可以调用<code>execute(DataSource)</code>方法。<br>
下面的例子指定了一个有关测试schema和测试数据的SQL叫阿苯，设置了语句分隔符为<code>@@</code>，并且针对<code>DataSource</code>运行脚本。</p>
<pre><code class="language-java">@Test
void databaseTest() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScripts(
            new ClassPathResource(&quot;test-schema.sql&quot;),
            new ClassPathResource(&quot;test-data.sql&quot;));
    populator.setSeparator(&quot;@@&quot;);
    populator.execute(this.dataSource);
    // run code that uses the test schema and data
}
</code></pre>
<p>注意<code>ResourceDatabasePopulator</code>内部委托了<code>ScriptUtils</code>去解析和运行SQL脚本。类似的是，在<code>AbstractTransactionalJUnit4SpringContextTests</code>和<code>AbstractTransactionalTestNGSpringContextTests</code>中的<code>executeSqlScript(..)</code>方法，内部使用的是<code>ResourceDatabasePopulator</code>去运行SQL脚本。</p>
<h3 id="592-通过注解sql执行脚本">5.9.2. 通过注解<code>@Sql</code>执行脚本</h3>
<p>除了前面提到过的通过编程的方式实现脚本执行，Spring TestContext框架还支持通过注解执行脚本，通过注解你可以在测试方法之前或者之后执行脚本。<code>@Sql</code>可以修饰到类或者方法上，可以配置独立的sql脚本或者sql脚本的资源路径，他的支持由<code>SqlScriptsTestExecutionListener</code>提供，这个listener是默认启用的。</p>
<blockquote>
<p>方法级别的<code>@Sql</code>申明会默认覆盖类级别的声明。从Spring Framework 5.2开始，是否覆盖可以通过<code>@SqlMergeMode</code>来配置，他可以在类级别或者方法级别配置，详情参考之前提到的<code>@SqlMergeMode</code></p>
</blockquote>
<h3 id="593-路径资源语法">5.9.3. 路径资源语法</h3>
<p>每个path都会被翻译为Spring的<code>Resource</code>。一个相对路径（比如，<code>&quot;schema.sql&quot;</code>）会被当做classpath资源，他会跟测试类所在的包相关联。路径以斜杠开头会被当做绝对路径（比如<code>&quot;/org/example/schema.sql&quot;</code>）。一个路径引用了一个URL（比如，一个path以<code>classpath:</code>，<code>file:</code>，<code>http:</code>开头）会按照指定的资源协议来加载。</p>
<p>下面的例子展示了在一个以JUnit Jupiter为基础的测试类中，类和方法都被<code>@Sql</code>修饰的例子：</p>
<pre><code class="language-java">@SpringJUnitConfig
@Sql(&quot;/test-schema.sql&quot;)
class DatabaseTests {

    @Test
    void emptySchemaTest() {
        // run code that uses the test schema without any test data
    }

    @Test
    @Sql({&quot;/test-schema.sql&quot;, &quot;/test-user-data.sql&quot;})
    void userTest() {
        // run code that uses the test schema and test data
    }
}
</code></pre>
<h3 id="594-默认脚本检测">5.9.4. 默认脚本检测</h3>
<p>如果<code>@Sql</code>注解没有声明任何脚本或者资源位置，那么会去检测默认的脚本位置，具体默认位置取决于注解申明位置，在类和方法上略有区别。如果没有在默认位置找到对应的sql脚本，会抛出<code>IllegalStateException</code>异常。</p>
<ul>
<li>类级别的申明：如果注解的测试类是<code>com.example.MyTest</code>，那么对应的默认脚本就是<code>classpath:com/example/MyTest.sql</code>。</li>
<li>方法级别的申明：如果注解的方法叫做<code>testMethod()</code>并且它是定义在<code>com.example.MyTest</code>类中，那么对应的默认脚本是<code>classpath:com/example/MyTest.testMethod.sql</code>。</li>
</ul>
<h3 id="595-申明多个sql集">5.9.5. 申明多个<code>@Sql</code>集</h3>
<p>如果你需要对一个测试类或者测试方法配置多个SQL脚本集合，他们可能有不同的语法配置，不同的异常处理规则，或者不同的执行阶段，你可以申明多个<code>@Sql</code>实例。如果是Java 8 ，那么你可以重复使用<code>@Sql</code>注解。否则，你需要使用<code>@SqlGroup</code>注解去包含多个<code>@Sql</code>实例。</p>
<p>下面的例子是Java 8的重复注解申明：</p>
<pre><code class="language-java">@Test
@Sql(scripts = &quot;/test-schema.sql&quot;, config = @SqlConfig(commentPrefix = &quot;`&quot;))
@Sql(&quot;/test-user-data.sql&quot;)
void userTest() {
    // run code that uses the test schema and test data
}
</code></pre>
<p>在上面的例子中，<code>test-schema.sql</code>脚本使用了一个不同的语法：单行注释。</p>
<p>下面的例子跟之前的例子相同，只不过是<code>@Sql</code>被<code>@SqlGroup</code>包装了一下。上面的例子在Java8的背景下，<code>@SqlGroup</code>是可选的，但是为了兼容性，比如需要兼容<code>Kotlin</code>，那么你只能选择<code>@SqlGroup</code>。</p>
<pre><code class="language-java">@Test
@SqlGroup({
    @Sql(scripts = &quot;/test-schema.sql&quot;, config = @SqlConfig(commentPrefix = &quot;`&quot;)),
    @Sql(&quot;/test-user-data.sql&quot;)
)}
void userTest() {
    // run code that uses the test schema and test data
}
</code></pre>
<h3 id="596-脚本执行阶段">5.9.6. 脚本执行阶段</h3>
<p>默认情况下<code>@Sql</code>的脚本都是在测试方法之前执行的，如果你需要在测试方法之后执行（比如，清楚数据库状态），那么<code>@Sql</code>的属性<code>executionPhase</code>可以帮到你。</p>
<pre><code class="language-java">@Test
@Sql(
    scripts = &quot;create-test-data.sql&quot;,
    config = @SqlConfig(transactionMode = ISOLATED)
)
@Sql(
    scripts = &quot;delete-test-data.sql&quot;,
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)
void userTest() {
    // run code that needs the test data to be committed
    // to the database outside of the test's transaction
}
</code></pre>
<p>注意<code>ISOLATED</code>和<code>AFTER_TEST_METHOD</code>是分别从<code>Sql.TransactionMode</code>和<code>Sql.ExecutionPhase</code>静态导入的。</p>
<h3 id="597-通过sqlconfig进行脚本配置">5.9.7. 通过<code>@SqlConfig</code>进行脚本配置</h3>
<p>你可以配置脚本解析或者异常处理通过使用<code>@SqlConfig</code>注解。当作为一个类级别的注解申明时，<code>@SqlConfig</code>服务于整个测试类的层次结构，对其中的所有SQL脚本生效。当通过<code>config</code>属性直接申明到<code>@Sql</code>注解里的时候，<code>@SqlConfig</code>作为一个本地配置服务，只对<code>@Sql</code>注解范围内的SQL脚本生效。每个<code>@SqlConfig</code>的属性都有一个隐性的默认值。因为Java语言规范中定义的注解属性规则，注解属性是不能分配<code>null</code>值的。因此，为了支持覆盖继承的全局属性，<code>@SqlConfig</code>属性有一个显性的默认值为 &ldquo;&quot;(字符串)，{}(数组)，或者<code>DEFAULT</code>(枚举)。这种方法允许本地的<code>@SqlConfig</code>提供除了&rdquo;&quot;，{}，或者<code>DEFAULT</code>以外的值来选择性的覆盖来自全局的每个属性。只要本地<code>@SqlConfig</code>没有提供一个显性的属性值（&quot;&quot;,{},DEFAULT除外），那么对应属性仍然从全局继承。</p>
<p><code>@Sql</code>和<code>@SqlConfig</code>提供的配置选项跟<code>ScriptUtils</code>和<code>ResourceDatabasePopulator</code>提供的相等，但是是<code>&lt;jdbc:initialize-database/&gt;</code>提供的XML命名空间元素的超集。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/jdbc/Sql.html">@Sql</a> 和<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html">@SqlConfig</a></p>
<h3 id="598-sql的事务管理">5.9.8. <code>@Sql</code>的事务管理</h3>
<p>默认情况下，<code>SqlScriptsTestExecutionListener</code>会推断<code>@Sql</code>配置的脚本期望的事务语义。具体来说，SQL脚本没有运行在一个事务中，但在一个Spring管理的事务中（举个例子，一个由<code>TransactionalTestExecutionListener</code>管理的事务，当测试被<code>@Transactional</code>注解修饰时），或者在一个隔离的事务当中，取决于<code>@SqlConfig</code>属性<code>transactionMode</code>的取值和测试<code>ApplicationContext</code>中是否有<code>PlatformTransactionManager</code>存在。就算最低的要求，也需要一个<code>javax.sql.DataSource</code>在测试<code>ApplicationContext</code>中存在。</p>
<p>如果<code>SqlScriptsTestExecutionListener</code>使用的算法通过检测<code>DataSource</code>和<code>PlatformTransactionManager</code>来推断的事务语义不符合你的需求，你可以指定显式名称通过设置<code>@SqlConfig</code>的属性<code>dataSource</code>和<code>transactionManager</code>。此外，你可以空值事务的传播方式通过设置<code>@SqlConfig</code>的<code>transactionMode</code>属性（比如，是否脚本应该运行在一个隔离的事务中）。详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html">@SqlConfig</a> 和 <a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html">SqlScriptsTestExecutionListener</a></p>
<pre><code class="language-java">@SpringJUnitConfig(TestDatabaseConfig.class)
@Transactional
class TransactionalSqlScriptsTests {

    final JdbcTemplate jdbcTemplate;

    @Autowired
    TransactionalSqlScriptsTests(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    @Sql(&quot;/test-data.sql&quot;)
    void usersTest() {
        // verify state in test database:
        assertNumUsers(2);
        // run code that uses the test data...
    }

    int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    void assertNumUsers(int expected) {
        assertEquals(expected, countRowsInTable(&quot;user&quot;),
            &quot;Number of rows in the [user] table.&quot;);
    }
}
</code></pre>
<p>注意这里不需要在执行完<code>userTest()</code>方法后清理数据库，因为所有对数据库的修改（不管是测试方法中的，还是<code>/test-data.sql</code>脚本中的）都会由<code>TransactionalTestExecutionListener</code>自动回滚。</p>
<h3 id="599-sqlmergemode合并或者覆盖配置">5.9.9. <code>@SqlMergeMode</code>合并或者覆盖配置</h3>
<p>从Spring Framework 5.2开始，合并方法级别的和类级别的<code>@Sql</code>申明成为可能。比如说，这能让你为每个测试类提供一次数据库schema配置或者提供一些常见的测试数据，然后在每个测试方法提供指定的测试数据。要开启<code>@Sql</code>合并，在你的测试类或者方法上修饰<code>@SqlMergeMode(MERGE)</code>。要为指定的方法或者子类关闭合，你可以设置模式为<code>@SqlMergeMode(OVERRIDE)</code>。</p>
<h2 id="510-并发测试执行">5.10. 并发测试执行</h2>
<p>Spring Framework 5.0引入了在单个JVM中并发执行测试的基础支持，当然是使用Spring TestContext框架前提下。一般来说，这意味着大多数测试类或者测试方法都可以在不修改任何测试代码或者配置的前提下并发的执行。</p>
<blockquote>
<p>怎样设置并发测试执行，详情可以参考你使用的测试框架，构建工具，或者IDE。</p>
</blockquote>
<p>记住在你的测试套件中引入并发可能会导致一些意想不到的副作用，奇怪的运行时行为，和间歇的测试失败或者产生随机性。因此Spring团队对于何时不适于使用并发测试有以下总结：</p>
<ul>
<li>使用Spring框架的<code>@DirtiesContext</code>。</li>
<li>使用Spring Boot的<code>@MockBean</code>或者<code>@SpyBean</code>。</li>
<li>使用JUnit 4的<code>@FixMethodOrder</code>或者任何是设计来确保测试方法按照指定顺序执行的框架特征。注意，当整个测试类是并发运行的时候，并不适用。</li>
<li>改变共享服务或者系统的状态（比如数据库，消息代理，文件系统等等）。这适用于集成或者外部系统。</li>
</ul>
<blockquote>
<p>如果并发测试执行失败过后，当前测试的<code>ApplicationContext</code>不再可用，这通常意味着<code>ApplicationContext</code>在另一个线程中被从<code>ContextCache</code>中移除了。</p>
<p>这可能是因为<code>@DirtiesContext</code>或者是<code>ContextCache</code>自动清除的。如果<code>@DirtiesContext</code>是罪魁祸首，你要么避免使用<code>@DirtiesContext</code>，要么避免使用并发测试。如果是由于<code>ContextCache</code>已经超过最大容量，你可以增加缓存数量的最大值。</p>
</blockquote>
<blockquote>
<p>在Spring TestContext框架中测试要并发执行，只有底层<code>TestContext</code>实现提供了一个 <code>copy constructor</code>时才有效(参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/TestContext.html">javadoc</a> )。但是，如果使用第三方提供的自定义<code>TestContext</code>实现，你需要验证它是否适配并发测试的执行。</p>
</blockquote>
<h2 id="511-testcontext-框架支持类">5.11. TestContext 框架支持类</h2>
<p>这个章节描述了Spring TestContext框架支持的各种类。</p>
<h3 id="5111-spring-junit-4-runner">5.11.1. Spring JUnit 4 Runner</h3>
<p>TestContext框架提供了完整的JUnit 4集成，通过一个自定义的runner（在JUnit4.12或者更高版本支持）。通过修饰测试<code>@RunWith(SpringJUnit4ClassRunner.class)</code>或者更短的变体<code>@RunWith(SpringRunner.class)</code>，开发者可以实现JUnit 4为基础的单元和集成测试并且同事获得TestContext框架带来的好处，比如加载ApplicationContext，测试示例的依赖注入，测试方法的事务管理等等。如果你想使用其他的runner（比如JUnit 4的<code>Parameterized</code>runner）或者第三方的runner（比如<code>MockitoJUnitRunner</code>），更多参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit4-rules"> Spring’s support for JUnit rules</a></p>
<p>下面的代码展示了配置一个测试类运行自定义Spring<code>Runner</code>的最低需求：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        // test logic...
    }
}
</code></pre>
<p>上面的例子中<code>@TestExecutionListeners</code>被配置为一个空的list，这样会关闭所有默认的listener，否则需要通过<code>@ContextConfiguration</code>配置一个<code>ApplicationContext</code>。</p>
<h3 id="5112-spring-junit-规则">5.11.2. Spring JUnit 规则</h3>
<p><code>org.springframework.test.context.junit4.rules</code>包提供了以下JUnit 4规则（在JUnit4.12或者更高版本支持）：</p>
<ul>
<li>SpringClassRule</li>
<li>SpringMethodRule</li>
</ul>
<p><code>SpringClassRule</code>是一个JUnit<code>TestRule</code>，他支持TestContext框架类级别的特征，但是<code>SpringMethodRule</code>是一个JUnit<code>MethodRule</code>，他支持TestContext框架实例级别或者方法级别的特征。</p>
<p>相对于<code>SpringRunner</code>，Spring规则基础的Junit支持具有独立于任何<code>org.junit.runner.Runner</code>实现的有点，因此，可以和已存在的runner（比如JUnit4的<code>Parameterized</code>）或者第三方的runner结合使用（<code>MockitoJUnitRunner</code>）。</p>
<p>为了支持TestContext框架的完整功能，你必须结合一个<code>SpringClassRule</code>和一个<code>SpringMethodRule</code>。下面的例子展示了在继承测试中如何正确的申明这些规则：</p>
<pre><code class="language-java">
// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
public class IntegrationTest {

    @ClassRule
    public static final SpringClassRule springClassRule = new SpringClassRule();

    @Rule
    public final SpringMethodRule springMethodRule = new SpringMethodRule();

    @Test
    public void testMethod() {
        // test logic...
    }
}
</code></pre>
<h3 id="5113-junit-4-支持类">5.11.3. JUnit 4 支持类</h3>
<p><code>org.springframework.test.context.junit4</code>为JUnit4(在JUnit4.12或者更高版本支持)为基础的测试案例提供了以下支持类：</p>
<ul>
<li>AbstractJUnit4SpringContextTests</li>
<li>AbstractTransactionalJUnit4SpringContextTests</li>
</ul>
<p><code>AbstractJUnit4SpringContextTests</code>是一个抽象测试基类，他集成了在JUnit 4环境的TestContext框架带有显式的<code>ApplicationContext</code>测试支持。当你extend<code>AbstractJUnit4SpringContextTests</code>，你可以访问一个<code>protected``applicationContext</code>实例参数，用它来执行显式的bean查找或者测试整个上下文的状态。</p>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code>是对<code>AbstractJUnit4SpringContextTests</code>的一个抽象事物的扩展，它新增了一些有关JDBC的便捷访问。这个类需要<code>ApplicationContext</code>中定义了一个<code>javax.sql.DataSource</code>bean和一个<code>PlatformTransactionManager</code>bean。当你extend<code>AbstractTransactionalJUnit4SpringContextTests</code>，你可以访问一个<code>protected``jdbcTemplate</code>实例参数，你可以用它来跑SQL语句。你可以在数据库相关代码运行前后确定数据库的状态，Spring会确保应用代码的query在相同的事务中。当配合ORM工具使用时，需要确保避免<code>false positives</code>，之前提到过。<code>AbstractTransactionalJUnit4SpringContextTests</code>也提供了快捷方法，他们都是委托<code>JdbcTestUtils</code>的方法完成的通过前面提到的<code>jdbcTemplate</code>。此外，<code>AbstractTransactionalJUnit4SpringContextTests</code>提供了一个<code>executeSqlScript(..)</code>方法可以运行SQL脚本。</p>
<blockquote>
<p>这些类方便了扩展。但是如果你不像你的测试类跟Spring指定的类结构绑定，那么你可以通过<code>@RunWith(SpringRunner.class)</code>或者 Spring’s JUnit rules。</p>
</blockquote>
<h3 id="5114-springextension-for-junit-jupiter">5.11.4. SpringExtension for JUnit Jupiter</h3>
<p>TestContext框架为JUnit5引入的JUnit Jupiter测试框架提供了完整的集成。通过注解测试类<code>@ExtendWith(SpringExtension.class)</code>，你可以实现标准的JUnit Jupiter为基础的单元或者集成测试同事也可以从TestContext框架中受益。</p>
<p>此外，多亏了JUnit Jupiter丰富的扩展，Spring提供了以下特征，它比Spring对JUnit4和TestNG特征的支持要更多更完善：</p>
<ul>
<li>测试构造方法，测试方法，和测试声明周期回调方法的依赖注入。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-di">Dependency Injection with SpringExtension</a></li>
<li>强力支持基于SpEL表达式的<a href="https://junit.org/junit5/docs/current/user-guide/#extensions-conditions">条件化测试执行</a> ，环境变量，系统属性等等。参考<code>@EnabledIf</code>和<code>@DisabledIf</code>在<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations-junit-jupiter"> Spring JUnit Jupiter Testing Annotations</a> 中</li>
<li>自定义复合注解由Spring和JUnit Jupiter的注解组成。参考<code>@TransactionalDevTestConfig</code>和<code>@TransactionalIntegrationTest</code>的例子在<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations-meta"> Meta-Annotation Support for Testing</a></li>
</ul>
<p>下面的例子是一个使用实例：</p>
<pre><code class="language-java">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension.class)
// Instructs Spring to load an ApplicationContext from TestConfig.class
@ContextConfiguration(classes = TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}
</code></pre>
<p>因为你也可以使用JUnit 5的注解作为元注解，所以Spring提供了<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>他们组合了必要的注解。</p>
<p>下面是一个<code>@SpringJUnitConfig</code>的例子：</p>
<pre><code class="language-java">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}
</code></pre>
<p>同样的，下面是一个<code>@SpringJUnitWebConfig</code>例子，为JUnit Jupiter创建了一个<code>WebApplicationContext</code>：</p>
<pre><code class="language-java">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig.class
@SpringJUnitWebConfig(TestWebConfig.class)
class SimpleWebTests {

    @Test
    void testMethod() {
        // test logic...
    }
}
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations-junit-jupiter"> Spring JUnit Jupiter Testing Annotations</a></p>
<h3 id="5115-dependency-injection-with-springextension">5.11.5. Dependency Injection with <code>SpringExtension</code></h3>
<p><code>SpringExtension</code>实现了来自JUnit Jupiter的<code>ParameterResoler</code>扩展API，它让Spring为测试构造函数，测试方法，和测试生命周期回调函数提供了依赖注入。</p>
<p>具体来说，<code>SpringExtension</code>你可以注入来自测试的<code>ApplicationContext</code>中的依赖到测试构造函数和被<code>@BeforeAll,</code> <code>@AfterAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code>, <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>，和其他注解修饰的方法中。</p>
<h4 id="构造函数注入">构造函数注入</h4>
<p>如果构造器中的指定参数是<code>ApplicationContext</code>类型（或者其子类型）或者是其被以下注解或者元注解修饰：@Autowired，@Qualifier，或者@Value，Spring会根据来自测试<code>ApplicationContext</code>中对应bean或者value来注入值。</p>
<p>Spring可以为测试类的构造函数配置自动装配所有的参数，如果构造函数是考虑成为自动装配化的。一个构造函数是否考虑自动装配化，下面的条件有一个满足就可以（按优先顺序）。</p>
<ul>
<li>构造函数被<code>@Autowired</code>修饰。</li>
<li><code>@TestConstructor</code>注解在测试类上存在或者他的元注解，并且<code>autowireMode</code>属性要为<code>ALL</code>。</li>
<li>默认的测试构造函数自动装配模式改为了<code>ALL</code>。</li>
</ul>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations-testconstructor">@TestConstructor</a></p>
<blockquote>
<p>如果测试类的构造函数考虑成为自动装配化的，Spring会承担构造函数所有参数的解析工作。这会导致，这样的构造函数不会有其他通过JUnit Jupiter注册的<code>ParameterResolver</code>能够解析他的参数。</p>
</blockquote>
<blockquote>
<p>如果测试方法申明了<code>@DirtiesContext</code>来在方法执行前或者执行后关闭<code>ApplicationContext</code>，那么就不能将构造器注入和JUnit Jupiter的<code>@TestInstance(PER_CLASS)</code>配合使用。</p>
<p>原因是因为<code>@TestInstance(PER_CLASS)</code>让JUnit Jupiter去缓存了测试方法调用之间的测试实例。因此，测试实例将会保留即将被关闭的<code>ApplicationContext</code>中的bean引用。因为在这种场景下，测试类的构造器只会被调用一次，依赖注入不会再次执行，接下来的测试交互的都是一个关闭的<code>ApplicationContext</code>，会直接抛出异常。</p>
<p>要配合<code>@TestInstance(PER_CLASS)</code>使用<code>before test method</code>或者<code>after test method</code>模式的<code>@DirtiesContext</code>，必须要通过字段或者setter方式的依赖注入，这样就能在测试方法调用之间重新注入。</p>
</blockquote>
<p>下面的例子中，Spring注入来自<code>ApplicationContext</code>的<code>OrderService</code>bean到<code>OrderServiceIntegrationTests</code>构造方法中。</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    @Autowired
    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}
</code></pre>
<p>注意这个特征让测试依赖成为<code>final</code>，因此不能更改。</p>
<p>如果<code>spring.test.constructor.autowire.mode</code>属性值是<code>all</code>(详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations-testconstructor">@TestConstructor</a> )，我们可以忽略之前例子中构造方法上的<code>@Autowired</code>，结果如下：</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}
</code></pre>
<h4 id="方法注入">方法注入</h4>
<p>如果JUnit Jupiter测试方法或者测试声明周期回调方法的一个参数是<code>ApplicationContext</code>类型（或者是其子类型）或者是被一下注解或元注解修饰的：<code>@Autowird</code>，<code>@Qualifier</code>，或者<code>@Value</code>，Spring会为指定的参数注入<code>ApplicationContext</code>中对应的bean。</p>
<p>下面的就是一个方法注入的实例：</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @Test
    void deleteOrder(@Autowired OrderService orderService) {
        // use orderService from the test's ApplicationContext
    }
}
</code></pre>
<p>因为在JUnit Jupiter中对<code>ParameterResolver</code>支持的稳健性，你可以有多个依赖注入到单个方法中，不仅是来自Spring，也可以是来自JUnit Jupiter或者其他第三方的扩展。</p>
<p>下面的例子展示如何同时有Spring和JUnit Jupiter的注入到同一个测试方法中：</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
            @Autowired OrderService orderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}
</code></pre>
<p>注意使用来自JUnit Jupiter的<code>@RepeatedTest</code>，可以让方法有权限访问<code>RepetitionInfo</code>。</p>
<h3 id="5116-nested测试类配置">5.11.6. <code>@Nested</code>测试类配置</h3>
<p>从Spring Framework 5.0开始，Spring TestContext框架支持在JUnit Jupiter的<code>@Nested</code>测试类上使用测试相关的注解；但是，直到Spring Framework5.3，类级别的测试配置注解才从封闭类继承而来，就像他们继承来自父类的一样。</p>
<p>Spring Framework 5.3 引入了良好的内部类配置继承支持，并且将会默认启用。要改变默认的<code>INHERIT</code>模式为<code>OVERRIDE</code>模式，你可以给每个<code>@Nested</code>测试类添加一个<code>@NestedTestConfiguration(EnclosingConfiguration.OVERRIDE)</code>。一个显式<code>@NestedTestConfiguration</code>申明不仅对注解修饰的测试类有效也对其子类和集成的类有效。因此，你可以用<code>@NestedTestConfiguration</code>注解修饰顶级测试类，让后递归应用到其所有集成的测试类上。</p>
<p>为了允许开发团队修改默认的模型为<code>OVERRIDE</code>——举个例子，为了兼容Spring Framework 5.0到5.2——默认的模型可以全局修改通过JVM系统属性或者一个在classpath根路径下的<code>spring.properties</code>文件。详情参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations-nestedtestconfiguration">&ldquo;Changing the default enclosing configuration inheritance mode&rdquo;</a></p>
<p>下面的<code>Hello World</code>例子是非常简单的，他展示了怎样申明常用的配置到顶级类上，方便它的集成类能够继承这些配置。在这个例子中，只有<code>TestConfig</code>配置类是继承的。每个集成测试类提供了它自己的激活配置文件，结果就是每个继承测试类都有一个不同的<code>ApplicationContext</code>。</p>
<pre><code class="language-java">@SpringJUnitConfig(TestConfig.class)
class GreetingServiceTests {

    @Nested
    @ActiveProfiles(&quot;lang_en&quot;)
    class EnglishGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo(&quot;Hello World&quot;);
        }
    }

    @Nested
    @ActiveProfiles(&quot;lang_de&quot;)
    class GermanGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo(&quot;Hallo Welt&quot;);
        }
    }
}
</code></pre>
<h3 id="5117-testng支持类">5.11.7. TestNG支持类</h3>
<p><code>org.springframework.test.context.testng</code>为TestNG为基础的测试案例提供了以下支持类：</p>
<ul>
<li>AbstractTestNGSpringContextTests</li>
<li>AbstractTransactionalTestNGSpringContextTests</li>
</ul>
<p><code>AbstractTestNGSpringContextTests</code>是一个抽象测试基类，他集成了在TestNG环境的TestContext框架带有显式的<code>ApplicationContext</code>测试支持。当你extend<code>AbstractTestNGSpringContextTests</code>，你可以访问一个<code>protected``applicationContext</code>实例参数，用它来执行显式的bean查找或者测试整个上下文的状态。</p>
<p><code>AbstractTransactionalTestNGSpringContextTests</code>是对<code>AbstractTestNGSpringContextTests</code>的一个抽象事物的扩展，它新增了一些有关JDBC的便捷访问。这个类需要<code>ApplicationContext</code>中定义一个<code>javax.sql.DataSource</code>bean和一个<code>PlatformTransactionManager</code>bean。当你extend<code>AbstractTransactionalTestNGSpringContextTests</code>，你可以访问一个<code>protected``jdbcTemplate</code>实例参数，你可以用它来跑SQL语句。你可以在数据库相关代码运行前后确定数据库的状态，Spring会确保应用代码的query在相同的事务中。当配合ORM工具使用时，需要确保避免<code>false positives</code>，之前提到过。<code>AbstractTransactionalTestNGSpringContextTests</code>也提供了快捷方法，他们都是委托<code>JdbcTestUtils</code>的方法完成的通过前面提到的<code>jdbcTemplate</code>。此外，<code>AbstractTransactionalTestNGSpringContextTests</code>提供了一个<code>executeSqlScript(..)</code>方法可以运行SQL脚本。</p>
<blockquote>
<p>这些类方便了扩展。如果你不想你的测试类和Spring指定的类结构绑定，你可以配置你自己的自定义测试类，通过使用<code>@ContextConfiguration</code>,<code>@TestExecutionListeners</code>等，并且通过<code>TestContextManager</code>手动检测你的测试类。关于如何检测你的测试类，参考<code>AbstractTestNGSpringContextTests</code>源码。</p>
</blockquote>
<h1 id="6-webtestclient">6. WebTestClient</h1>
<p><code>WebTestClient</code>是一个设计用于测试服务应用的HTTP客户端。它包装了Spring的<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client">WebClient</a> ，并且用它来执行请求，并且暴露一个验证response的测试门面。<code>WebTestClient</code>可以用来执行端对端的HTTP测试。它也可以用来测试Spring MVC和Spring WebFlux应用，而且不需要运行服务，通过模拟请求和返回对象。</p>
<blockquote>
<p>Kotlin用户：查看<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#kotlin-webtestclient-issue">this section</a> 相关的<code>WebTestClient</code>使用。</p>
</blockquote>
<h2 id="61-配置">6.1. 配置</h2>
<p>要配置一个<code>WebTestClient</code>，你需要选择一个服务配置来绑定。这可以是众多模拟服务器配置中的一个或者一个实时线上服务器的连接。</p>
<h3 id="绑定到controller">绑定到Controller</h3>
<p>这个配置允许你测试指定的controller通过虚拟的request和response对象，并且不需要运行服务。</p>
<p>对于WebFlux应用，使用下面的代码加载基础框架等于<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config">WebFlux Java config</a> ，注册给定的controller，然后创建一个<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api">WebHandler chain</a> 去处理request：</p>
<pre><code class="language-java">WebTestClient client =
        WebTestClient.bindToController(new TestController()).build();
</code></pre>
<p>对于Spring MVC，使用下面的代码委托<code>StandaloneMockMvcBuilder</code>去加载与<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config">WebMvc Java config</a>  等效的基础架构，注册给定的controller，并且创建一个<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#spring-mvc-test-framework">MockMvc</a> 实例去处理request：</p>
<pre><code class="language-java">WebTestClient client =
        MockMvcWebTestClient.bindToController(new TestController()).build();
</code></pre>
<h3 id="绑定到-applicationcontext">绑定到 ApplicationContext</h3>
<p>这个配置允许你通过Spring MVC或者Spring WebFlux基础框架和controller申明来加载Spring配置，并且通过模拟的request和response对象处理去处理请求，而无需运行服务。</p>
<p>对于WebFlux，使用以下内容传递Spring<code>ApplicationContext</code>到<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html#applicationContext-org.springframework.context.ApplicationContext-">WebHttpHandlerBuilder</a> 中去创建<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api">WebHandler chain</a> 以处理请求：</p>
<pre><code class="language-java">@SpringJUnitConfig(WebConfig.class) 
class MyTests {

    WebTestClient client;

    @BeforeEach
    void setUp(ApplicationContext context) {  
        client = WebTestClient.bindToApplicationContext(context).build(); 
    }
}
</code></pre>
<p>对于Spring MVC，使用以下内容传递Spring<code>ApplicationContext</code>到<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/web/servlet/setup/MockMvcBuilders.html#webAppContextSetup-org.springframework.web.context.WebApplicationContext-">MockMvcBuilders.webAppContextSetup</a> 去创建一个<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#spring-mvc-test-framework">MockMvc</a> 实例以处理请求：</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@WebAppConfiguration(&quot;classpath:META-INF/web-resources&quot;) 
@ContextHierarchy({
    @ContextConfiguration(classes = RootConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class MyTests {

    @Autowired
    WebApplicationContext wac; 

    WebTestClient client;

    @BeforeEach
    void setUp() {
        client = MockMvcWebTestClient.bindToApplicationContext(this.wac).build(); 
    }
}
</code></pre>
<h3 id="绑定到-router-function">绑定到 Router Function</h3>
<p>这个配置允许你在不启动服务的情况下通过模拟request和response对象测试<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-fn">functional endpoints</a></p>
<p>对于WebFlux，使用下面内容委托给<code>RouterFunctions.toWebHandler</code>去创建一个服务配置以处理请求：</p>
<pre><code class="language-java">RouterFunction&lt;?&gt; route = ...
client = WebTestClient.bindToRouterFunction(route).build();
</code></pre>
<p>对于Spring MVC，目前还没有测试<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#webmvc-fn"> WebMvc functional endpoints</a> 的选项。</p>
<h3 id="绑定到服务器">绑定到服务器</h3>
<p>这个配置连接到一个运行的服务上以进行完整的，端对端的HTTP测试：</p>
<pre><code class="language-java">client = WebTestClient.bindToServer().baseUrl(&quot;http://localhost:8080&quot;).build();
</code></pre>
<h3 id="客户端配置">客户端配置</h3>
<p>除了之前梯级的服务配置以外，你还可以配置客户端选项，包括 base URL，默认 headers，客户端过滤器等等。这些选项在<code>bindToServcer()</code>之后都是很容易获得的。对于其他配置选项，你可以使用<code>configureClient()</code>将服务转为客户端配置：</p>
<pre><code class="language-java">client = WebTestClient.bindToController(new TestController())
        .configureClient()
        .baseUrl(&quot;/test&quot;)
        .build();
</code></pre>
<h2 id="62-写测试">6.2. 写测试</h2>
<p>直到通过<code>exchange()</code>执行请求为止，<code>WebTestClient</code>提供和<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client">WebClient</a> 相同的API。参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-body">WebClient</a> 文档以查找如何准备一个有任何内容的请求，包括 form data， multipart data，等等。</p>
<p>在调用<code>exchange()</code>之后，<code>WebTestClient</code>从<code>WebClient</code>偏离，转变工作流的方向去验证response。</p>
<p>使用下面内容去断言response的状态和header：</p>
<pre><code class="language-java">client.get().uri(&quot;/persons/1&quot;)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)
</code></pre>
<p>然后你可以通过下面任何一种方法去解码reponse的body：</p>
<ul>
<li>expectBody(Class<!-- raw HTML omitted -->)：解码为单个对象。</li>
<li>expectBodyList(Class<!-- raw HTML omitted -->)：解码并收集对象到List<!-- raw HTML omitted -->。</li>
<li>expectBody()：解码到<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#webtestclient-json">JSON Content</a> 或者一个空的body <code>byte[]</code></li>
</ul>
<p>然后在高等级的结果对象上执行断言：</p>
<pre><code class="language-java">client.get().uri(&quot;/persons&quot;)
        .exchange()
        .expectStatus().isOk()
        .expectBodyList(Person.class).hasSize(3).contains(person);
</code></pre>
<p>如果内置的断言效率太低，你还可以用其他的断言代替：</p>
<pre><code class="language-java">import org.springframework.test.web.reactive.server.expectBody

client.get().uri(&quot;/persons/1&quot;)
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .consumeWith(result -&gt; {
            // custom assertions (e.g. AssertJ)...
        });
</code></pre>
<p>或者你可以退出工作流，并获取一个<code>EntityExchangeResult</code>：</p>
<pre><code class="language-java">EntityExchangeResult&lt;Person&gt; result = client.get().uri(&quot;/persons/1&quot;)
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .returnResult();
</code></pre>
<blockquote>
<p>当你需要解码的目标类型是一个泛型时，请寻找接受<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/core/ParameterizedTypeReference.html">ParameterizedTypeReference</a> 而不是<code>Class&lt;T&gt;</code>的重载方法</p>
</blockquote>
<h3 id="no-content">No Content</h3>
<p>如果不期待response会返回任何内容，你可以这样断言：</p>
<pre><code class="language-java">client.post().uri(&quot;/persons&quot;)
        .body(personMono, Person.class)
        .exchange()
        .expectStatus().isCreated()
        .expectBody().isEmpty();
</code></pre>
<p>如果需要忽略response内容，下面就是是释放内容并不需要任何断言：</p>
<pre><code class="language-java">client.get().uri(&quot;/persons/123&quot;)
        .exchange()
        .expectStatus().isNotFound()
        .expectBody(Void.class);
</code></pre>
<h3 id="json-content">JSON Content</h3>
<p>你可以使用<code>expectBody()</code>，他没有目标类型，他断言的目标是为加工的内容而不是高等级的对象。</p>
<p>用<a href="https://jsonassert.skyscreamer.org/">JSONAssert</a> 验证完整的JSON内容：</p>
<pre><code class="language-java">client.get().uri(&quot;/persons/1&quot;)
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .json(&quot;{\&quot;name\&quot;:\&quot;Jane\&quot;}&quot;)
</code></pre>
<p>用<a href="https://github.com/json-path/JsonPath">JSONPath</a> 验证JSON内容：</p>
<pre><code class="language-java">client.get().uri(&quot;/persons&quot;)
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath(&quot;$[0].name&quot;).isEqualTo(&quot;Jane&quot;)
        .jsonPath(&quot;$[1].name&quot;).isEqualTo(&quot;Jason&quot;);
</code></pre>
<h3 id="streaming-responses">Streaming Responses</h3>
<p>要测试一个可能无穷尽的流，比如说<code>&quot;text/event-stream&quot;</code>或者<code>&quot;application/x-ndjson&quot;</code>，通过验证response状态和header开始，然后获取一个<code>FluxExchangeResult</code>：</p>
<pre><code class="language-java">FluxExchangeResult&lt;MyEvent&gt; result = client.get().uri(&quot;/events&quot;)
        .accept(TEXT_EVENT_STREAM)
        .exchange()
        .expectStatus().isOk()
        .returnResult(MyEvent.class);
</code></pre>
<p>现在你已经准备好通过来自<code>reactor-test</code>的<code>StepVerifier</code>去消耗response流了：</p>
<pre><code class="language-java">Flux&lt;Event&gt; eventFlux = result.getResponseBody();

StepVerifier.create(eventFlux)
        .expectNext(person)
        .expectNextCount(4)
        .consumeNextWith(p -&gt; ...)
        .thenCancel()
        .verify(); 
</code></pre>
<h3 id="mockmvc断言">MockMvc断言</h3>
<p><code>WebTestClient</code>是一个HTTP客户端，因此他只能验证客户端的response，包括状态，head,和body。</p>
<p>当用一个MockMVC服务配置测试一个Spring MVC应用时，你有一个额外的选择可以在服务response上执行更多的断言。通过在断言body后获取一个<code>ExchangeResult</code>来实现：</p>
<pre><code class="language-java">// For a response with a body
EntityExchangeResult&lt;Person&gt; result = client.get().uri(&quot;/persons/1&quot;)
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .returnResult();

// For a response without a body
EntityExchangeResult&lt;Void&gt; result = client.get().uri(&quot;/path&quot;)
        .exchange()
        .expectBody().isEmpty();
</code></pre>
<p>然后切换到MockMvc服务response断言：</p>
<pre><code class="language-java">MockMvcWebTestClient.resultActionsFor(result)
        .andExpect(model().attribute(&quot;integer&quot;, 3))
        .andExpect(model().attribute(&quot;string&quot;, &quot;a string value&quot;));
</code></pre>
<h1 id="7-mockmvc">7. <code>MockMvc</code></h1>
<p>Spring MVC Test 框架，也叫作MockMvc，为测试Spring MVC应用提供了支持。他执行了完整的Spring MVC请求处理，但是是通过模拟的request和response对象从而代替一个运行的服务。</p>
<p>MockMvc可以用在它自己身上去支持请求和response验证。它也可以通过<code>WebTestClient</code>来使用，他是通过插入到<code>WebTestClient</code>中作为处理请求的服务。<code>WebTestClient</code>带来的好处是可以不用再看着未加工的数据，可以将response body解码到高等级对象中，并且还可以切换到完整的端对端的HTTP测试，并且使用的是相同的测试API。</p>
<h2 id="71-大纲">7.1. 大纲</h2>
<p>你可以在普通的单元测试中使用controller，通过初始化一个controller，注入他的依赖，并调用他的方法。 但是，这样的测试不能验证 request mappings, data binding, message conversion, type conversion, validation, 并且不能涉及任何支持<code>@InitBinder</code>，<code>@ModelAttribute</code>，或者<code>@ExceptionHandler</code>的方法。</p>
<p>Spring MVC Test框架，也叫<code>MockMVC</code>，旨在不需要运行服务的情况下提供更完整的Spring MVC controller测试支持。这是通过调用<code>DispacherServlet</code>并且传递了一个来自<code>spring-test</code>模组的<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#mock-objects-servlet">模拟的Servlet API实现</a> ，它复制了完整的Spring MVC请求处理逻辑，并且不需要启动服务。</p>
<p>MockMvc 是一个服务端的测试框架，他通过使用轻量和目标性的测试可以让你验证Spring MVC应用的大多数功能。</p>
<h3 id="静态导入">静态导入</h3>
<p>当使用MockMvc直接执行请求时，你会需要静态导入：</p>
<ul>
<li>MockMvcBuilders.*</li>
<li>MockMvcRequestBuilders.*</li>
<li>MockMvcResultMatchers.*</li>
<li>MockMvcResultHandlers.*</li>
</ul>
<p>一个简单的方法去记住这些类，可以通过ide搜索<code>MockMvc*</code>。</p>
<p>当通过<code>WebTestClient</code>使用MockMvc时，你不需要静态导入。<code>WebTestClient</code>提供了流畅的API并且不需要静态导入。</p>
<h3 id="配置选择">配置选择</h3>
<p>MockMvc可以有两个方法可以配置。一个是直接指出你想要测试的controller，并且以编程的方式配置Spring MVC基础结构。另外一个是指出带有Spring MVC和controller基础结构的Spring配置。</p>
<p>配置MockMvc去测试一个指定的controller：</p>
<pre><code class="language-java">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
    }

    // ...

}
</code></pre>
<p>当通过<code>WebTestClient</code>使用时，也可以使用这个配置，它会委托给跟上面相同的构造器。</p>
<p>通过Spring配置来初始化MockMvc：</p>
<pre><code class="language-java">@SpringJUnitWebConfig(locations = &quot;my-servlet-context.xml&quot;)
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    // ...

}
</code></pre>
<p>或者在通过<code>WebTestClient</code>使用时仍然可以使用上面的配置，<code>WebTestClient</code>委托给跟上面相同的builder来完成。</p>
<p>你应该使用哪个配置选项？</p>
<p><code>webAppContextSetup</code>加载你实际的Spring MVC配置，生成一个更加完整的集成测试。因为TestContext框架加载了Spring配置，它帮助测试更快的运行，即使你在你的测试套件中引入了更多的测试。此外，你可以通过Spring配置注入模拟service到controller中以在web层测试上保持专注。下面的例子通过Mockito申明了一个模拟的service：</p>
<pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;org.mockito.Mockito&quot; factory-method=&quot;mock&quot;&gt;
    &lt;constructor-arg value=&quot;org.example.AccountService&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>然后你可以将这个模拟service注入到测试中，配置并验证你的期望结果：</p>
<pre><code class="language-java">@SpringJUnitWebConfig(locations = &quot;test-servlet-context.xml&quot;)
class AccountTests {

    @Autowired
    AccountService accountService;

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    // ...

}
</code></pre>
<p>另一方面，<code>standaloneSetup</code>更接近于单元测试。他一次测试一个controller。你可以通过模拟依赖手动注入controller，并且不会涉及加载Spring配置。这样的测试更专注于样式，使得查看被测试的controller，或是任何指定的Spring MVC配置是否是运行的必要条件等等操作更加容易。用<code>standaloneSetup</code>写临时的测试去验证指定的操作或者debug一个问题都非常方便。</p>
<p>像大多数的“集成测试和单元测试对比”的讨论，都没有完全正确或者错误的答案。但是，使用<code>standaloneSetup</code>确实会需要一些额外的<code>webAppContextSetup</code>测试，这是为了验证你的Spring MVC配置。当然，你也可以把所有的测试都用<code>webAppContextSetup</code>来写，可以让你的测试都是基于实际的Spring MVC配置进行。</p>
<h3 id="配置特征">配置特征</h3>
<p>不管使用哪种MockMvc构建方法，所有的<code>MockMvcBuilder</code>实现都提供了一些常用并且非常有用的特征。比如，你可以为所有的request申明一个<code>Accept</code>header并且假定所有response的状态都是200并且还带一个<code>Content-type</code>header：</p>
<pre><code class="language-java">// static import of MockMvcBuilders.standaloneSetup

MockMvc mockMvc = standaloneSetup(new MusicController())
    .defaultRequest(get(&quot;/&quot;).accept(MediaType.APPLICATION_JSON))
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType(&quot;application/json;charset=UTF-8&quot;))
    .build();
</code></pre>
<p>此外，第三方框架（和应用）可以预包装配置指令，就像<code>MockMvcConfigurer</code>中的一样。Spring框架也有一个继承的实现，可以帮助你在request之间保存和复用HTTP session：</p>
<pre><code class="language-java">// static import of SharedHttpSessionConfigurer.sharedHttpSession

MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
        .apply(sharedHttpSession())
        .build();

// Use mockMvc to perform requests...
</code></pre>
<p>详情参考<a href="https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html">ConfigurableMockMvcBuilder</a> 列出了所有MockMvc builder的特征。</p>
<h3 id="执行请求">执行请求</h3>
<p>这个章节讲述MockMvc自身怎样执行请求和验证response。如果是通过<code>WebTestClient</code>使用，可以参考之前的章节。</p>
<p>使用任何HTTP方法执行请求：</p>
<pre><code class="language-java">mockMvc.perform(post(&quot;/hotels/{id}&quot;, 42).accept(MediaType.APPLICATION_JSON));
</code></pre>
<p>你也可以执行文件上传请求，它内部使用的是<code>MockMultipartHttpServletRequest</code>，没有实际解析一个multipart request：</p>
<pre><code class="language-java">mockMvc.perform(multipart(&quot;/doc&quot;).file(&quot;a1&quot;, &quot;ABC&quot;.getBytes(&quot;UTF-8&quot;)));
</code></pre>
<p>你可以在URI模板样式中指定请求参数：</p>
<pre><code class="language-java">mockMvc.perform(get(&quot;/hotels?thing={thing}&quot;, &quot;somewhere&quot;));
</code></pre>
<p>你可以通过下面的方式呈现参数：</p>
<pre><code class="language-java">mockMvc.perform(get(&quot;/hotels&quot;).param(&quot;thing&quot;, &quot;somewhere&quot;));
</code></pre>
<p>如果应用代码依赖Servlet请求参数，并且没有清晰的检查请求string(大多数情况都是这样)，那么你选择那个方法都没有关系。但是，请记住，URI模板提供的请求参数是已经解码的，但是通过<code>param(...)</code>提供的请求参数 <code>are expected to already be decoded</code>。</p>
<p>在大多数情况下，更偏向于将context path和Servlet path从请求URI中分离。如果你必须测试一个完整的请求URI，那么请确保<code>contextPath</code>和<code>servletPath</code>的准确性：</p>
<pre><code class="language-java">mockMvc.perform(get(&quot;/app/main/hotels/{id}&quot;).contextPath(&quot;/app&quot;).servletPath(&quot;/main&quot;))
</code></pre>
<p>在上面的例子中，如果每个请求都附带<code>contextPath</code>和<code>servletPath</code>是十分笨重的。相对的，你可以提前设置好默认属性：</p>
<pre><code class="language-java">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        mockMvc = standaloneSetup(new AccountController())
            .defaultRequest(get(&quot;/&quot;)
            .contextPath(&quot;/app&quot;).servletPath(&quot;/main&quot;)
            .accept(MediaType.APPLICATION_JSON)).build();
    }
}
</code></pre>
<p>上面的属性通过<code>MockMvc</code>影响每一个请求执行。如果给定的请求指定了同样的属性，那么它会覆盖默认值。这就是为什么默认请求中的HTTP方法和URI无关紧要的原因，因为他们都必须在每个请求中指定。</p>
<h3 id="定义预期结果">定义预期结果</h3>
<p>你可以通过一个或者多个<code>.andExpect(..)</code>定义预期结果：</p>
<pre><code class="language-java">mockMvc.perform(get(&quot;/accounts/1&quot;)).andExpect(status().isOk());
</code></pre>
<p><code>MockMvcResultMatchers.*</code>提供了很多预期结果，他们中的一些可以嵌套为更详情的结果。</p>
<p>预期结果可以划分为两个大致的种类。一个是验证response的属性（比如，response status,header,和内容）。这是要断言的最重要的结果内容。</p>
<p>第二个断言的分类超出了response的范围。这些断言让你检查Spring MVC指定的切面，比如哪个controller方法处理了这个请求，是否有异常出现并被处理，model的具体内容，那个view被选中，什么flash属性被添加等等。他们也能让你检查Servlet指定的切面，比如说request和session属性。</p>
<p>下面的测试断言了绑定或者验证失败：</p>
<pre><code class="language-java">mockMvc.perform(post(&quot;/persons&quot;))
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors(&quot;person&quot;));
</code></pre>
<p>许多时候，转存执行测试请求后的结果都是非常有用的。你可以像下边这样做，<code>print()</code>是由<code>MockMvcResultHandlers</code>静态导入的：</p>
<pre><code class="language-java">mockMvc.perform(post(&quot;/persons&quot;))
.andDo(print())
.andExpect(status().isOk())
.andExpect(model().attributeHasErrors(&quot;person&quot;));
</code></pre>
<p>只要请求进程不会产生一个不能处理的异常，<code>print()</code>方法就会打印所有可用的结果数据到<code>System.out</code>中。这里有一个<code>log()</code>方法和两个额外的<code>print()</code>方法的变体，一个接收<code>OutputStream</code>，另外一个接收<code>Writer</code>。举个例子，调用<code>print(System.err)</code>打印结果到<code>System.err</code>，当调用<code>print(myWriter)</code>打印结果到一个自定义的writer。如果你想用log的形式而不是print，那么你可以调用<code>log()</code>方法，他会将结果数据作为一条单一的<code>DEUBG</code>信息在<code>org.springframework.test.web.servlet.result</code>logging目录下。</p>
<p>某些情况你可能想直接获得结果对象进行验证，你可以通过<code>.andReturn()</code>，在所有的expect方法之后调用：</p>
<pre><code class="language-java">MvcResult mvcResult = mockMvc.perform(post(&quot;/persons&quot;)).andExpect(status().isOk()).andReturn();
// ...
</code></pre>
<p>如果所有的测试都检测一个预期结果，那么你可以在构建<code>MockMvc</code>时就设置默认的预期结果：</p>
<pre><code class="language-java">standaloneSetup(new SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType(&quot;application/json;charset=UTF-8&quot;))
    .build()
</code></pre>
<p>注意这些通用的预期结果始终都是可用的，并且不能够被覆盖，除非创建一个单独的<code>MockMvc</code>实例。</p>
<p>当一个JSON response内容包含一个由<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a> 创建的多媒体连接，你可以通过使用JsonPath表达式来验证结果连接：</p>
<pre><code class="language-java">mockMvc.perform(get(&quot;/people&quot;).accept(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath(&quot;$.links[?(@.rel == 'self')].href&quot;).value(&quot;http://localhost:8080/people&quot;));
</code></pre>
<p>当XML response内容包含一个由<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a> 创建的多媒体连接，你可以通过使用XPath表达式验证结果连接。</p>
<pre><code class="language-java">Map&lt;String, String&gt; ns = Collections.singletonMap(&quot;ns&quot;, &quot;http://www.w3.org/2005/Atom&quot;);
mockMvc.perform(get(&quot;/handle&quot;).accept(MediaType.APPLICATION_XML))
    .andExpect(xpath(&quot;/person/ns:link[@rel='self']/@href&quot;, ns).string(&quot;http://localhost:8080/people&quot;));
</code></pre>
<h3 id="异步请求">异步请求</h3>
<p>这个章节展示怎样使用MockMvc进行异步请求处理。如果通过<code>WebTestClient</code>使用MockMvc，那么是不需要特别处理的，因为默认就是异步请求。</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Spring MVC支持Servlet 3.0 异步请求</a> ，是通过退出Servlet容器线程，并允许应用异步计算response，然后通过异步调度去完成对Servlet容器线程的处理。</p>
<p>在Spring MVC测试中，异步请求可以通过先断言产生的异步value开始，然后手动执行异步调度，并且最终验证response。下面的例子测试的controller方法返回的<code>deferredResult</code>，<code>Callable</code>，或者交互类型比如Reactor<code>Mono</code>：</p>
<pre><code class="language-java">@Test
void test() throws Exception {
    MvcResult mvcResult = this.mockMvc.perform(get(&quot;/path&quot;))
            //检测response状态是仍然未改变的
            .andExpect(status().isOk()) 
            //异步处理必须有一个started
            .andExpect(request().asyncStarted())
            //等待并断言异步结果
            .andExpect(request().asyncResult(&quot;body&quot;)) 
            .andReturn();

    //手动执行异步调度（因为没有运行的容器）
    this.mockMvc.perform(asyncDispatch(mvcResult))
            //验证最终response    
            .andExpect(status().isOk()) 
            .andExpect(content().string(&quot;body&quot;));
}
</code></pre>
<h3 id="streaming-response">Streaming Response</h3>
<p>在Spring MVC测试中是有没有选项去测试无容器的返回流的。但是你可以通过<code>WebTestClient</code>请求去测试流。在Spring Boot中你可以<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server">测试一个运行的服务</a> 通过<code>WebTestClient</code>。另外一个优势是他有能力使用来自项目Reactor的<code>StepVerifier</code>，可以允许在流数据上申明预期结果。</p>
<h3 id="过滤器注册">过滤器注册</h3>
<p>当配置一个<code>MockMvc</code>实例时，你可以注册一个或者多个Servlet<code>Filter</code>实例：</p>
<pre><code class="language-java">mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();
</code></pre>
<p>注册的过滤器是通过来自<code>spring-test</code>的<code>MockFilterChain</code>来调用的，并且最后一个过滤器委托给了<code>DispacherServlet</code>。</p>
<h3 id="更多代码实例">更多代码实例</h3>
<p><a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples">MockMvc</a> ，<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/client">WebTestClient</a></p>
<h1 id="8-测试客户端应用">8. 测试客户端应用</h1>
<p>你可以使用客户端测试，它内部使用的是<code>RestTemplate</code>。这个逻辑是申明期待的请求和提供&quot;stub&quot;response，所以你可以在不运行服务的情况下检测代码。</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(requestTo(&quot;/greeting&quot;)).andRespond(withSuccess());

// Test code that uses the above RestTemplate ...

mockServer.verify();
</code></pre>
<p>在之前的例子中，<code>MockRestServiceServer</code>（客户端REST测试的核心类）用一个自定义的<code>ClientHttpRequestFactory</code>配置了<code>RestTemplate</code>，并断言了一个预期的真实请求和返回&quot;stub&quot;response。在这个案例中，我们期待一个到<code>/greeting</code>的请求，并且希望返回一个200 response，并带着<code>text/plain</code>内容。我们可以根据需要定义其他的请求和stub response。当我们定义期待的request和stub response时，restTemplate可以照常在客户端代码中使用。在测试结束时，<code>mockServer.verify()</code>可以用来验证所有的期望结果是否都被满足了。</p>
<p>默认情况下，请求应按照expect申明期望的顺序执行。当构建服务时你可以设置<code>ignoreExpectOrder</code>选项，在这种情况下会检测所有的expect以找到一个跟给定request匹配。这意味着请求可以以任何顺序进入：</p>
<pre><code class="language-java">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();
</code></pre>
<p>即使改为无序请求，每个请求也只允许运行一次。expect方法提供一个重载变体，可以接受一个<code>ExpectedCount</code>参数以指定一个数量范围（比如说，一次，多次，max,min,between,等等）。下面的例子使用了<code>times</code>：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(2), requestTo(&quot;/something&quot;)).andRespond(withSuccess());
mockServer.expect(times(3), requestTo(&quot;/somewhere&quot;)).andRespond(withSuccess());

// ...

mockServer.verify();
</code></pre>
<p>注意，当<code>ignoreExpectOrder</code>没有设置的时候（默认情况），请求会按照expect申明期望的顺序，并且这个顺序只会对第一次出现的期望请求有效。举个例子，如果<code>/something</code>期待出现两次接下来是三次<code>/somewhere</code>，这里应该有一个<code>/something</code>请求是在<code>/somewhere</code>请求之前的，但是剩下的请求可以在任何时间进入。</p>
<p>对于上面的所有内容，还有另外一个实现方式，客户端的测试支持也提供了一个<code>ClientHttpRequestFactory</code>实现，你可以配置到一个<code>RestTemplate</code>中去将它绑定到<code>MockMvc</code>实例上。它允许你使用服务端的逻辑处理请求并且不需要运行一个服务：</p>
<pre><code class="language-java">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

// Test code that uses the above RestTemplate ...
</code></pre>
<h2 id="81-静态导入">8.1. 静态导入</h2>
<p>作为服务端的测试，要流畅测试客户端需要一些静态导入。只要搜索<code>MockRest*</code>即可。</p>
<h2 id="82-更多代码实例">8.2. 更多代码实例</h2>
<p><a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples">Client-side test</a></p>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>Permalink: </strong>
      <a href="https://www.mingaccount.com/2017/09/spring-test/" title="Spring集成测试" target="_blank" rel="external">https://www.mingaccount.com/2017/09/spring-test/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://www.mingaccount.com/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">Ming</span><small class="ml-1x">tianshiming5@outlook.com</small></a></h3>
        <div>Finally</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://www.mingaccount.com/2017/09/linux-sh-exception/" title="linux sh文件运行异常，出现异常文件结尾或者乱码字符"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;Older</span></a>
            </li>
            <li class="next">
                <a href="https://www.mingaccount.com/2017/09/mysql-create-view-exception/"
                    title="Mysql 创建视图报错：View&#39;s SELECT contains a subquery in the FROM clause"><span>Newer&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="Catalogue" role="button">
                    <span>[&nbsp;</span><span>Catalogue</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>

</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://www.mingaccount.com/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2015  -
    2021
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js" defer></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>
<script src="https://www.mingaccount.com/js/application.min.bdeb64b910570b6c41badc6a05b7afb0c8ad9efd8525de3c7257d59e786326a3.js"></script>
<script src="https://www.mingaccount.com/js/plugin.min.51ff8c7317566f82259170fa36e09c4493adc9b9378b427a01ad3f017ebac7dd.js"></script>

<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            ROOT_URL: 'https:\/\/www.mingaccount.com',
            CONTENT_URL: 'https:\/\/www.mingaccount.com\/searchindex.json ',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script type="text/javascript" src="https://www.mingaccount.com/js/insight.min.a343cd9a5a7698336b28ef3a7c16a3a1b1d2d5fb17dc8ed04022bbe08cc5459073a15bdafa3a8a58cdd56080784bdd69fa70b1ae8597565c799c57ed00f0e120.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    tocbot.init({
        
        tocSelector: '.js-toc',
        
        contentSelector: '.js-toc-content',
        
        headingSelector: 'h1, h2, h3',
        
        hasInnerContainers: true,
    });
</script>


  </body>
</html>
