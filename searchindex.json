{"categories":[],"posts":[{"content":"The ASCII letter \u0026ldquo;P\u0026rdquo; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix.\nThe sections have suffixes in ASCII of \u0026ldquo;D\u0026rdquo;, \u0026ldquo;H\u0026rdquo;, \u0026ldquo;M\u0026rdquo; and \u0026ldquo;S\u0026rdquo; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order.\nThe ASCII letter \u0026ldquo;T\u0026rdquo; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if \u0026ldquo;T\u0026rdquo; is present there must be at least one section after the \u0026ldquo;T\u0026rdquo;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to an long. The number of seconds must parse to an long with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.\nExamples:\n \u0026quot;PT20.345S\u0026quot; -- parses as \u0026quot;20.345 seconds\u0026quot;\r\u0026quot;PT15M\u0026quot; -- parses as \u0026quot;15 minutes\u0026quot; (where a minute is 60 seconds)\r\u0026quot;PT10H\u0026quot; -- parses as \u0026quot;10 hours\u0026quot; (where an hour is 3600 seconds)\r\u0026quot;P2D\u0026quot; -- parses as \u0026quot;2 days\u0026quot; (where a day is 24 hours or 86400 seconds)\r\u0026quot;P2DT3H4M\u0026quot; -- parses as \u0026quot;2 days, 3 hours and 4 minutes\u0026quot;\r ","id":0,"section":"posts","summary":"The ASCII letter \u0026ldquo;P\u0026rdquo; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix.\nThe sections have suffixes in ASCII of \u0026ldquo;D\u0026rdquo;, \u0026ldquo;H\u0026rdquo;, \u0026ldquo;M\u0026rdquo; and \u0026ldquo;S\u0026rdquo; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order.\nThe ASCII letter \u0026ldquo;T\u0026rdquo; must occur before the first occurrence, if any, of an hour, minute or second section.","tags":["protocol"],"title":"Duration format PnDTnHnMn.nS ISO-8601","uri":"https://www.mingaccount.com/2021/02/duration-format/","year":"2021"},{"content":"Hyper-v powershell admin\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All\r  Install Hyper-V on Windows 10\n Containers Prep windows for containers\n","id":1,"section":"posts","summary":"Hyper-v powershell admin Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All Install Hyper-V on Windows 10 Containers Prep windows for containers","tags":["windows"],"title":"启用Windows Hyper-v和containers","uri":"https://www.mingaccount.com/2020/10/windows-hyper-v-and-container/","year":"2020"},{"content":"背景：windows npm install失败 错误信息：pngquant failed to build, make sure that libpng-dev is installed 解决方案 npm install --global windows-build-tools 如果仍然失败，参考github回答\n","id":2,"section":"posts","summary":"背景：windows npm install失败 错误信息：pngquant failed to build, make sure that libpng-dev is installed 解决方案 npm install --global windows-build-tools 如果仍然失败，参考github回答","tags":["windows","npm"],"title":"Windows CMD 错误pngquant failed to build, make sure that libpng-dev is installed","uri":"https://www.mingaccount.com/2020/10/windows-npm-exception/","year":"2020"},{"content":"WSL ubuntu20.04官方问题，为了稳定推荐18.04\n参考官方说明\n","id":3,"section":"posts","summary":"WSL ubuntu20.04官方问题，为了稳定推荐18.04 参考官方说明","tags":["windows"],"title":"WIN10 UBUNTU 异常：sleep: cannot read realtime clock: Invalid argument","uri":"https://www.mingaccount.com/2020/08/wsl-exception/","year":"2020"},{"content":"当提取字段为Date类型时，extract只能读取年月日，提取时分秒会报错\n要提取年月日，需要将Date类型转为timestamp\n","id":4,"section":"posts","summary":"当提取字段为Date类型时，extract只能读取年月日，提取时分秒会报错 要提取年月日，需要将Date类型转为timestamp","tags":["oracle"],"title":"Oracle extract函数提取时分秒的问题","uri":"https://www.mingaccount.com/2020/07/oracle-extract/","year":"2020"},{"content":"Setting中有个选项setRenderSchema(true)，但是这种只适用于表是由JOOQ代码生成器生成的表对象。\n如果是自己声明的表对象（DSL.table()），想要让JOOQ在渲染时自己加上schema，稍微麻烦一点。\n这里假设需要加上的默认schema为：liuneng\nSettings settings = new Settings()\r.withRenderMapping(new RenderMapping()\r.withSchemata(new MappedSchema().withInput(\u0026quot;\u0026quot;).withOutput(\u0026quot;liuneng\u0026quot;)));\r 这样设置后,JOOQ在渲染表名的时候会把未设置schema的表，统一加上liuneng，但是还有一个前提，你的表必须要按照以下方式声明：\nDSL.table(name(\u0026quot;my_table\u0026quot;))\r ","id":5,"section":"posts","summary":"Setting中有个选项setRenderSchema(true)，但是这种只适用于表是由JOOQ代码生成器生成的表对象。 如果是自己声明的表","tags":["jooq"],"title":"JOOQ默认schema","uri":"https://www.mingaccount.com/2020/07/jooq-default-schema/","year":"2020"},{"content":"Restart-Service LxssManager\r ","id":6,"section":"posts","summary":"Restart-Service LxssManager","tags":["windows"],"title":"win10 linux子系统如何重启","uri":"https://www.mingaccount.com/2020/07/wsl-restart/","year":"2020"},{"content":"需提前设置BreakAfterAcquireFailure为true，不然连接重试次数限制无效 还需要设置FailFast为true，不然原始线程会一直阻塞\ndataSource.setBreakAfterAcquireFailure(true);\rdataSource.setFailFast(true);\rdataSource.setConnectionErrorRetryAttempts(3);\r ","id":7,"section":"posts","summary":"需提前设置BreakAfterAcquireFailure为true，不然连接重试次数限制无效 还需要设置FailFast为true，不然原始","tags":["druid"],"title":"Druid数据库连接失败，无限尝试问题","uri":"https://www.mingaccount.com/2020/06/druid-connection-retry/","year":"2020"},{"content":"原因是hive版本太老，不能识别integer，只能识别int\n官方说明\n生效版本是0.8.0\n","id":8,"section":"posts","summary":"原因是hive版本太老，不能识别integer，只能识别int 官方说明 生效版本是0.8.0","tags":["hive"],"title":"hive cast( as integer)报错 in primitive type specification","uri":"https://www.mingaccount.com/2020/05/hive-cast-exception/","year":"2020"},{"content":"用spark写csv的时候碰见一个问题，join后未匹配的单元应该是null，但是spark写出来全部都为\u0026quot;\u0026quot;\nF23338994668,F23338994669,F23338995220\r12,1,1\r1,7,\u0026quot;\u0026quot;\r13,1,1\r6,1,1\r16,1,1\r 在之后hive加载的时候，由于该列是数字类型，空字符无法匹配数字字段类型，导致有空串的整行都展示为null\nF23338994668,F23338994669,F23338995220\r12,1,1\r,,,\r13,1,1\r6,1,1\r16,1,1\r 追踪代码发现在未写入之前，sql没有问题，也没有执行na().fill()操作，但在write过后，null就变成了\u0026quot;\u0026quot;\n解决办法，在sparkDF.write之前追加配置.config(\u0026ldquo;emptyValue\u0026rdquo;,\u0026quot;\u0026quot;)即可\n","id":9,"section":"posts","summary":"用spark写csv的时候碰见一个问题，join后未匹配的单元应该是null，但是spark写出来全部都为\u0026quot;\u0026quot; F23338994668,F23338994669,F23338995220 12,1,1 1,7,\u0026quot;\u0026quot; 13,1,1 6,1,1","tags":["spark"],"title":"spark dataset写csv的时候将null值写为空字符串","uri":"https://www.mingaccount.com/2020/05/spark-write-null-to-empty-str/","year":"2020"},{"content":"spark decimal列进行计算时，可能丢失精度\n在默认情况下[spark.sql.decimalOperations.allowPrecisionLoss]配置为true，会导致精度丢失的列展示为null\n一般情况下，修改spark配置即可解决：\nspark.sql.decimalOperations.allowPrecisionLoss=false\r 参考官方说明\n但是在如下例子中还会出现结果列为null的情况：\nIF(column1 IS NULL,0,column1) - IF(column2 IS NULL,0,column2)\r 去掉IF判断，就能正常获取结果\n","id":10,"section":"posts","summary":"spark decimal列进行计算时，可能丢失精度 在默认情况下[spark.sql.decimalOperations.allowPrecision","tags":["spark"],"title":"spark精度丢失，导致列查询为null的解决办法","uri":"https://www.mingaccount.com/2020/04/spark-precision-loss/","year":"2020"},{"content":"实现方式是自定义触发器\ndrop trigger if exists trigger_name;\rdelimiter |\rCREATE TRIGGER trigger_name BEFORE INSERT ON table_name\rFOR EACH ROW BEGIN\rdeclare original_column_name varchar(255);\rdeclare column_name_counter int;\rset original_column_name = new.column_name;\rset column_name_counter = 1;\rwhile exists (select true from pc_volumes where name = new.column_name) do\rset new.column_name = concat(original_column_name, '-', column_name_counter);\rset column_name_counter = column_name_counter + 1;\rend while;\rEND;\r|\rdelimiter ;\r ","id":11,"section":"posts","summary":"实现方式是自定义触发器 drop trigger if exists trigger_name; delimiter | CREATE TRIGGER trigger_name BEFORE INSERT ON table_name FOR EACH ROW BEGIN declare original_column_name varchar(255); declare column_name_counter int; set original_column_name = new.column_name; set column_name_counter = 1; while exists (select true from pc_volumes where name = new.column_name) do set new.column_name = concat(original_column_name, '-', column_name_counter); set column_name_counter = column_name_counter + 1; end while; END; |","tags":["mysql"],"title":"Mysql插入重复值追加后缀","uri":"https://www.mingaccount.com/2020/04/mysql-duplicate-value-add-appendix/","year":"2020"},{"content":"一、打开sbt安装路径找到conf\\sbtconfig.txt，在文件末尾添加仓库文件地址 -Dsbt.repository.config=%SBT_HOME/sbt/conf/repository.properties\r 二、在对应目录创建repository.properties，并添加如下内容 [repositories]\rlocal\raliyun-nexus: http://maven.aliyun.com/nexus/content/groups/public/ ibiblio-maven: http://maven.ibiblio.org/maven2/\rtypesafe-ivy: https://dl.bintray.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]\ruk-repository: http://uk.maven.org/maven2/\rjboss-repository: http://repository.jboss.org/nexus/content/groups/public/\rtypesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly\rsonatype-oss-releases\rmaven-central\rsonatype-oss-snapshots\r 三、同时在~/.sbt(windows在“用户/.sbt”)下创建文件repositories，并添加上面的内容 ","id":12,"section":"posts","summary":"一、打开sbt安装路径找到conf\\sbtconfig.txt，在文件末尾添加仓库文件地址 -Dsbt.repository.config=%SBT_HOME/sbt/conf/repository.properties 二、在对应目录创建repository.prop","tags":["scala"],"title":"SBT仓库镜像配置","uri":"https://www.mingaccount.com/2020/02/sbt-repository-mirror/","year":"2020"},{"content":"这里主要参照NameCheap，其他域名服务商大同小异 host:\n@代表在浏览器输入yourdomain.tld想跳转到的地址\nwww代表在浏览器输入www.yourdomain.tld想跳转到的地址\n跳转到指定IP    type host target     A Record @ 11.22.33.44   A Record www 11.22.33.44    跳转到指定域名    type host target     CNAME Record @ [name].github.io   CNAME Record www [name].github.io    NameCheap的详细说明\n","id":13,"section":"posts","summary":"这里主要参照NameCheap，其他域名服务商大同小异 host: @代表在浏览器输入yourdomain.tld想跳转到的地址 www代表在浏览器输入w","tags":["website build"],"title":"怎么给自己的域名指定IP","uri":"https://www.mingaccount.com/2020/02/how-to-bind-ip-to-domain/","year":"2020"},{"content":"select\ra.date\r, a.measure\r, case\rwhen b.measure is null\ror b.measure=0\rthen null\relse concat( cast( cast((if(a.measure is null, 0, a.measure)-if(b.measure is null,0,b.measure))*100/b.measure as decimal(10,2))　as string)　,'%')\rend as ratio_column\rfrom\rtest_table a\rleft join\rtest_table b\ron\r(\rto_date(from_unixtime(unix_timestamp(concat(a.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')) = add_months(to_date(from_unixtime(unix_timestamp(concat(b.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')),+1)\rand 1 = 1\r)\r 提醒： 　1. 第一个join条件的\u0026rsquo;yyyyMM\u0026rsquo;可以根据字段date的具体格式改变，\u0026lsquo;yyyy-MM-dd HH:mm:ss\u0026rsquo;不需要改变\n　2. 该同环比没有任何分组和汇总，所以一旦date字段有重复值，很容易出现笛卡尔积，解决方案是确保join条件能够确定一条数据在表中的唯一性\n","id":14,"section":"posts","summary":"select a.date , a.measure , case when b.measure is null or b.measure=0 then null else concat( cast( cast((if(a.measure is null, 0, a.measure)-if(b.measure is null,0,b.measure))*100/b.measure as decimal(10,2)) as string) ,'%') end as ratio_column from test_table a left join test_table b on ( to_date(from_unixtime(unix_timestamp(concat(a.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')) = add_months(to_date(from_unixtime(unix_timestamp(concat(b.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')),+1) and 1 = 1 ) 提醒： 1. 第一个join条件的\u0026rsqu","tags":["hive"],"title":"Hive同环比实现","uri":"https://www.mingaccount.com/2020/02/hive-ratio-implement/","year":"2020"},{"content":"hive的日期格式可由String类型保存，只能识别两种格式yyyy-MM-dd和yyyy-MM-dd HH:mm:ss。\n只要将日期转为这两种格式hive就能识别为日期。也就是不管to_date、to_char都是将日期格式化为字符串。\nunix_timestamp(日期字符串,日期格式) 返回日期时间戳\nfrom_unixtime(日期时间戳,日期格式) 返回日期字符串\nto_date，to_char都用的一个公式，唯一不同的是to_date的目标日期格式是写死的\n1.to_date\nfrom_unixtime(unix_timestamp(来源日期，来源日期格式),\u0026lsquo;yyyy-MM-dd HH:mm:ss\u0026rsquo;)\n例：\nfrom_unixtime(unix_timestamp('2020/02/03 17:35:00','yyyy/MM/dd HH-mm-ss'),'yyyy-MM-dd HH:mm:ss')\r 2.to_char\nfrom_unixtime(unix_timestamp(来源日期，来源日期格式),目标日期格式)\n例：\nfrom_unixtime(unix_timestamp('2020/02/03 17:35:00','yyyy/MM/dd HH-mm-ss'),'yyyy-MM-dd HH:mm:ss')\r ","id":15,"section":"posts","summary":"hive的日期格式可由String类型保存，只能识别两种格式yyyy-MM-dd和yyyy-MM-dd HH:mm:ss。 只要将日期转为这两种","tags":["hive"],"title":"Hive中的to_date和to_char","uri":"https://www.mingaccount.com/2020/02/hive-todate-tochar/","year":"2020"},{"content":"String.format(\u0026quot;(?\u0026lt;![\\\\u4E00-\\\\u9FA5aa-zA-Z0-9_])%s(?![\\\\u4E00-\\\\u9FA5a-zA-Z0-9_])\u0026quot;,\u0026quot;独立字符不与任何其他字符相连\u0026quot;)\r ","id":16,"section":"posts","summary":"String.format(\u0026quot;(?\u0026lt;![\\\\u4E00-\\\\u9FA5aa-zA-Z0-9_])%s(?![\\\\u4E00-","tags":["regexp"],"title":"像IDEA一样匹配一个WORDS","uri":"https://www.mingaccount.com/2020/01/regex-match-words-like-idea/","year":"2020"},{"content":"根据版本不同，官方文档有详细说明\n使用参照文档\n查询结果对照文档\n","id":17,"section":"posts","summary":"根据版本不同，官方文档有详细说明 使用参照文档 查询结果对照文档","tags":["mysql"],"title":"Mysql Explain用法详解","uri":"https://www.mingaccount.com/2019/12/mysql-explain/","year":"2019"},{"content":"切记！！！！！\n没有比官网教程更详细，更靠谱的教程！！！！！\n其他的基本都是官网的翻译，但是官网的教程是实时更新的，要是不注意版本，坑根本就踩不完！！！\n附上官网部署教程：\nhttps://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html\n$\\color{#DAA520}{单节点的安装只需要关注两个点：}$\n1.linux安装的java版本，各个版本的hadoop对java版本是要求的，具体信息如下： https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions\n　2.在多次执行hdfs dfs -format后，namenode和datanode的clusterid可能对不上，在format之前需要删除tmp/hadoop-hadoop目录\n","id":18,"section":"posts","summary":"切记！！！！！ 没有比官网教程更详细，更靠谱的教程！！！！！ 其他的基本都是官网的翻译，但是官网的教程是实时更新的，要是不注意版本，坑根本就踩不","tags":["hadoop"],"title":"Hadoop安装踩坑","uri":"https://www.mingaccount.com/2019/12/hadoop-shit/","year":"2019"},{"content":"Spring依赖注入方式  直接修饰成员变量，也就是提醒不推荐的情况  @RestController\rpublic class TestController{\r@Autowired\rprivate TestService testService;\r}\r 修饰构造函数，@Autowired可省略  @RestController\rpublic class TestController{\rprivate TestService testService;\rpublic TestController(TestService testService) {\rthis.testService = testService;\r}\r}\r 修饰setter函数，@Autowired可省略  @RestController\rpublic class TestController{\rprivate TestService testService;\rpublic void SetTestService(TestService testService) {\rthis.testService = testService;\r}\r}\r 不推荐直接修饰的原因  @Autowired不能作用在final的成员变量上 直接修饰成员变量会导致变量直接依赖Spring容器，脱离Spring容器就无法初始化，然而通过构造函数或setter函数的方式都是可以脱离Spring容器的使用的 直接修饰的方式会让你忽略当前类有多少依赖，不利于代码重构和优化  ","id":19,"section":"posts","summary":"Spring依赖注入方式 直接修饰成员变量，也就是提醒不推荐的情况 @RestController public class TestController{ @Autowired private TestService testService; } 修饰构造函数，@Autowired可省略 @RestController public class TestController{ private TestService testService; public TestController(TestService","tags":["spring"],"title":"@Autowired注解直接修饰在成员变量时提醒Field injection is not recommended","uri":"https://www.mingaccount.com/2019/12/field-injection-not-recommended/","year":"2019"},{"content":"首先确保安装SSH server：\nsudo apt-get install openssh-server\r 启动SSH server:\nsudo service ssh start\r#检查ssh是否正常启动\rssh localhost\r 安装后，可以使用如下命令登陆本机：\nssh localhost\r 此时会有SSH首次登陆提示，输入 yes 。然后按提示输入密码 hadoop，这样就登陆到本机了。\n但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆。\n有以下两种实现方法：\n　一、首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：\n# 退出刚才的 ssh localhost\rexit\r# 若没有该目录，请先执行一次ssh localhost\rcd ~/.ssh/\r# 会有提示，都按回车就可\rssh-keygen -t rsa\r# 加入授权\rcat ./id_rsa.pub \u0026gt;\u0026gt; ./authorized_keys  　二、　#1\rssh localhost\r #2\rssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa\rcat ~/.ssh/id_dsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys\r #3\rssh localhost\r #4 要保证：~/.ssh需要是700权限 authorized_keys需要是644权限\rchmod 700 ~/.ssh\rchmod 644 ~/.ssh/authorized_keys\r #5 此时进入到~/.ssh目录下，会看到多了一个文件know_hosts文件\r #6 退出exit，重新打开shell\r #7.最后ssh localhost验证一下\r 　","id":20,"section":"posts","summary":"首先确保安装SSH server： sudo apt-get install openssh-server 启动SSH server: sudo service ssh start #检查ssh是否正常启动 ssh localhost 安装后，可以使用如下命令登陆本机： ssh localhost 此时会有SSH","tags":["hadoop"],"title":"Hadoop ssh localhost 无密码登录","uri":"https://www.mingaccount.com/2019/12/hadoop-ssh-local-host-no-paw/","year":"2019"},{"content":"完整异常 [42611][-604] The length, precision, or scale attribute for column, distinct type, structured type, array type, attribute of structured type, routine, cast target type, type mapping, or global variable \u0026quot;decimal(38, 2)\u0026quot; is not valid.. SQLCODE=-604, SQLSTATE=42611, DRIVER=4.26.14 [56098][-727] An error occurred during implicit system action type \u0026quot;2\u0026quot;. Information returned for the error includes SQLCODE \u0026quot;-604\u0026quot;, SQLSTATE \u0026quot;42611\u0026quot; and message tokens \u0026quot;decimal(38, 2)\u0026quot;.. SQLCODE=-727, SQLSTATE=56098, DRIVER=4.26.14\r 报错sql SELECT cast(a as decimal(38,2)) from table\r 报错原因 DECIMAL (p, s) p = 1 to 31; s = 1 to 31\n","id":21,"section":"posts","summary":"完整异常 [42611][-604] The length, precision, or scale attribute for column, distinct type, structured type, array type, attribute of structured type, routine, cast target type, type mapping, or global variable \u0026quot;decimal(38, 2)\u0026quot; is not valid.. SQLCODE=-604, SQLSTATE=42611, DRIVER=4.26.14 [56098][-727] An error occurred during implicit system action type \u0026quot;2\u0026quot;. Information returned for the error includes SQLCODE \u0026quot;-604\u0026quot;, SQLSTATE \u0026quot;42611\u0026quot; and message tokens \u0026quot;decimal(38, 2)\u0026quot;.. SQLCODE=-727, SQLSTATE=56098, DRIVER=4.26.14 报错","tags":["db2"],"title":"db2 cast decimal异常","uri":"https://www.mingaccount.com/2019/11/db2-cast-decimal-exception/","year":"2019"},{"content":"完整异常  Arithmetic overflow or other arithmetic exception occurred.. SQLCODE=-802, SQLSTATE=22003, DRIVER=4.26.14\n 报错sql SELECT SUM(C_1788) FROM table\r c_1788列是integer类型\n报错原因 c_1788列数值长度为9，sum值肯定溢出\n","id":22,"section":"posts","summary":"完整异常 Arithmetic overflow or other arithmetic exception occurred.. SQLCODE=-802, SQLSTATE=22003, DRIVER=4.26.14 报错sql SELECT SUM(C_1788) FROM table c_1788列是integer类型 报错原因 c_1788列数值长度为9，sum值肯定溢出","tags":["db2"],"title":"db2 sum函数报错Arithmetic overflow...","uri":"https://www.mingaccount.com/2019/11/db2sumerror/","year":"2019"},{"content":"作者：孤独烟\n链接：https://zhuanlan.zhihu.com/p/73260510\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nOK，具体有下面这些问题\n1.为什么一定要设一个主键？\n2.你们主键是用自增还是UUID?\n3.主键为什么不推荐有业务含义?\n4.表示枚举的字段为什么不用enum类型？\n5.货币字段用什么类型? 6.时间字段用什么类型?\n7.为什么不直接存储图片、音频、视频等大容量内容?\n8.字段为什么要定义为NOT NULL?\n其实上面这些问题，我最早想法是，每个问题都可以啰嗦出一篇文章。后来由于良心发现，烟哥就决定用一篇文章将这些问题都讲明白。 当然，我给的回答可能并非标准答案，毕竟是自己的一些工作总结。各位读者有更好的回答，也欢迎交流！\n这里我要说一下，我用mysql只用过innodb存储引擎，其他的引擎真没用过。因此我的回答，都是基于innodb存储引擎中的。\n正文 问题1:为什么一定要设一个主键？ 回答:因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，在有些情况下，就能显式的用上主键索引，提高查询效率！\n问题2:主键是用自增还是UUID? 回答:肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。\n上面那句话看不懂没事，大白话一句就是:用自增插入性能好！\n另外，附一个测试表给你们，表名带uuid的就是用uuid作为主键。大家看一下就知道性能差距了:\n如上图所示，当主键是UUID的时候，插入时间更长，而且占用空间更大！\nps：这个问题，你要是能把UUID讲出合理的理由也行。\n问题3:主键为什么不推荐有业务含义? 回答:有如下两个原因\n 因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。 带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。  问题4:表示枚举的字段为什么不用enum类型？ 回答:在工作中表示枚举的字段，一般用tinyint类型。\n那为什么不用enum类型呢？下面两个原因\n(1)ENUM类型的ORDER BY操作效率低，需要额外操作\n(2)如果枚举值是数值，有陷阱 举个例子，表结构如下\nCREATE TABLE test (foobar ENUM('0', '1', '2'));\r 此时，你执行语句\nmysql\u0026gt; INSERT INTO test VALUES (1);\r 查询出的结果为\n就产生了一个坑爹的结果。 插入语句应该像下面这么写，插入的才是1\nmysql\u0026gt; INSERT INTO test VALUES (`1`);\r 问题5:货币字段用什么类型? 回答:如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。\n千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。 打个比方，你建一个列如下\nCREATE TABLE `t` (\r`price` float(10,2) DEFAULT NULL,\r) ENGINE=InnoDB DEFAULT CHARSET=utf8\r 然后insert给price列一个数据为1234567.23，你会发现显示出来的数据变为1234567.25，精度失准！\n问题6:时间字段用什么类型? 回答:此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！\n(1)varchar，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为2013111的数据，请问这是代表2013年1月11日，还是2013年11月1日？ 其次，做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！\n(2)timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。 但是它有一个优势，timestamp类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区\nSET TIME_ZONE = \u0026ldquo;america/new_york\u0026rdquo;; 你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！\n(3)datetime，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！\n(4)bigint，也是8个字节，自己维护一个时间戳，表示范围比timestamp大多了，就是要自己维护，不大方便。\n问题7:为什么不直接存储图片、音频、视频等大容量内容? 回答:我们在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是text和blob类型。但是，我们在生产中，基本不用这两个类型！\n主要原因有如下两点\n(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢\n(2)binlog内容太多。因为你数据内容比较大，就会造成binlog内容比较多。大家也知道，主从同步是靠binlog进行同步，binlog太大了，就会导致主从同步效率问题！\n因此，不推荐使用text和blob类型！\n问题8:字段为什么要定义为NOT NULL? 回答:OK，这问题从两个角度来答\n(1)索引性能不好\nMysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。 —— 出自《高性能mysql第二版》\r (2)查询会出现一些不可预料的结果 这里举一个例子，大家就懂了。假设，表结构如下\ncreate table table_2 (\r`id` INT (11) NOT NULL,\rname varchar(20)\r)\r 表数据是这样的\n你执行语句\nselect count(name) from table_2;\r 你会发现结果为非NULL的总数\n类似的查询问题，其实有很多，不一一列举。 记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.\n","id":23,"section":"posts","summary":"作者：孤独烟 链接：https://zhuanlan.zhihu.com/p/73260510 来源：知乎 著作权归作者所有。商业转载请联系作者获","tags":["mysql"],"title":"[转]Mysql表设计注意事项","uri":"https://www.mingaccount.com/2019/10/mysql-table-design/","year":"2019"},{"content":"转自公众号“孤独烟”\n引言 我们先来讲一个段子\n面试官：“有并发的经验没？” 应聘者：“有一点。” 面试官：“那你们为了处理并发，做了哪些优化？” 应聘者：“前后端分离啊，限流啊，分库分表啊。。” 面试官:\u0026quot;谈谈分库分表吧？\u0026quot; 应聘者：“bala。bala。bala。。” 面试官心理活动:这个仁兄讲的怎么这么像网上的博客抄的，容我再问问。\r面试官:“你们分库分表后，如何部署上线的？” 应聘者：“这！！！！！！”\r 不要惊讶，我写这篇文章前，我特意去网上看了下分库分表的文章，很神奇的是，都在讲怎么进行分库分表，却不说分完以后，怎么部署上线的。这样在面试的时候就比较尴尬了。\n你们自己摸着良心想一下，如果你真的做过分库分表，你会不知道如何部署的么？因此我们来学习一下如何部署吧。\nps:我发现一个很神奇的现象。因为很多公司用的技术比较low，那么一些求职者为了提高自己的竞争力，就会将一些高大上的技术写进自己的low项目中。然后呢，他出去面试害怕碰到从这个公司出来的人，毕竟从这个公司出来的人，一定知道自己以前公司的项目情形。因此为了圆谎，他就会说：“他们从事的是这个公司的老项目改造工作，用了很多新技术进去！”\n那么，请你好好思考一下，你们的老系统是如何平滑升级为新系统的！\n如何部署 停机部署法 大致思路就是，挂一个公告，半夜停机升级，然后半夜把服务停了，跑数据迁移程序，进行数据迁移。\n步骤如下:\n(1)出一个公告，比如“今晚00:00～6:00进行停机维护，暂停服务”\n(2)写一个迁移程序，读db-old数据库，通过中间件写入新库db-new1和db-new2，具体如下图所示\n(3)校验迁移前后一致性，没问题就切该部分业务到新库。\n顺便科普一下，这个中间件。现在流行的分库分表的中间件有两种，一种是proxy形式的，例如mycat，是需要额外部署一台服务器的。还有一种是client形式的，例如当当出的Sharding-JDBC，就是一个jar包，使用起来十分轻便。我个人偏向Sharding-JDBC，这种方式，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式。\n评价：\n大家不要觉得这种方法low，我其实一直觉得这种方法可靠性很强。而且我相信各位读者所在的公司一定不是什么很牛逼的互联网公司，如果你们的产品凌晨1点的用户活跃数还有超过1000的，你们握个爪！毕竟不是所有人都在什么电商公司的，大部分产品半夜都没啥流量。所以此方案，并非没有可取之处。\n但是此方案有一个缺点，累！不止身体累，心也累！你想想看，本来定六点结束，你五点把数据库迁移好，但是不知怎么滴，程序切新库就是有点问题。于是，眼瞅着天就要亮了，赶紧把数据库切回老库。第二个晚上继续这么干，简直是身心俱疲。\nps：这里教大家一些技巧啊，如果你真的没做过分库分表，又想吹一波，涨一下工资，建议答这个方案。因为这个方案比较low，low到没什么东西可以深挖的，所以答这个方案，比较靠谱。\n另外，如果面试官的问题是\n你们怎么进行分库分表的？ 这个问题问的很泛，所以回答这个问题建议自己主动把分表的策略，以及如何部署的方法讲出来。因为这么答，显得严谨一些。\n不过，很多面试官为了卖弄自己的技术，喜欢这么问\n分表有哪些策略啊？你们用哪种啊？ ok。。这个问题具体指向了分库分表的某个方向了，你不要主动答如何进行部署的。等面试官问你，你再答。如果面试官没问，在面试最后一个环节，面试官会让你问让几个问题。你就问\n你刚才刚好有提到分库分表的相关问题，我们当时部署的时候，先停机。然后半夜迁移数据，然后第二天将流量切到新库，这种方案太累，不知道贵公司有没有什么更好的方案？ 那么这种情况下，面试官会有两种回答。第一种，面试官硬着头皮随便扯。第二种，面试官真的做过，据实回答。记住，面试官怎么回答的不重要。重点的是，你这个问题出去，会给面试官一种错觉:\u0026ldquo;这个小伙子真的做过分库分表。\u0026rdquo;\n如果你担心进去了，真派你去做分库分表怎么办？OK，不要怕。我赌你试用期碰不到这个活。因为能进行分库分表，必定对业务非常熟。还在试用期的你，必定对业务不熟，如果领导给你这种活，我只能说他有一颗大心脏。\nok，指点到这里。面试本来就是一场斗智斗勇的过程，扯远了，回到我们的主题。\n双写部署法(一) 这个就是不停机部署法，这里我需要先引进两个概念:历史数据和增量数据。\n假设，我们是对一张叫做test_tb的表进行拆分，因为你要进行双写，系统里头和test_tb表有关的业务之前必定会加入一段双写代码，同时往老库和新库中写，然后进行部署，那么\n历史数据:在该次部署前，数据库表test_tb的有关数据，我们称之为历史数据。\n增量数据:在该次部署后，数据库表test_tb的新产生的数据，我们称之为增量数据。\n然后迁移流程如下\n(1)先计算你要迁移的那张表的max(主键)。在迁移过程中，只迁移db-old中test_tb表里，主键小等于该max(主键)的值，也就是所谓的历史数据。\n这里有特殊情况，如果你的表用的是uuid，没法求出max(主键)，那就以创建时间作为划分历史数据和增量数据的依据。如果你的表用的是uuid,又没有创建时间这个字段，我相信机智的你，一定有办法区分出历史数据和增量数据。\n(2)在代码中，与test_tb有关的业务，多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中，至于消息体如何组装，大家自行考虑。需要注意的是，只发写请求的sql，只发写请求的sql，只发写请求的sql。重要的事情说三遍！\n原因有二:\n(1)只有写请求的sql对恢复数据才有用。\n(2)系统中，绝大部分的业务需求是读请求，写请求比较少。\n注意了，在这个阶段，我们不消费消息队列里的数据。我们只发写请求，消息队列的消息堆积情况不会太严重！\n(3)系统上线。另外，写一段迁移程序，迁移db-old中test_tb表里，主键小于该max(主键)的数据，也就是所谓的历史数据。\n上面步骤(1)～步骤(3)的过程如下\n等到db-old中的历史数据迁移完毕，则开始迁移增量数据，也就是在消息队列里的数据。\n(4)将迁移程序下线，写一段订阅程序订阅消息队列中的数据\n(5)订阅程序将订阅到到数据，通过中间件写入新库\n(6)新老库一致性验证，去除代码中的双写代码，将涉及到test_tb表的读写操作，指向新库。\n上面步骤(4)～步骤(6)的过程如下\n这里大家可能会有一个问题，在步骤(1)～步骤(3),系统对历史数据进行操作，会造成不一致的问题么？\nOK，不会。这里我们对delete操作和update操作做分析，因为只有这两个操作才会造成历史数据变动，insert进去的数据都是属于增量数据。\n(1)对db-old中test_tb表的历史数据发出delete操作，数据还未删除，就被迁移程序给迁走了。此时delete操作在消息队列里还有记录，后期订阅程序订阅到该delete操作，可以进行删除。\n(2)对db-old中test_tb表的历史数据发出delete操作，数据已经删除，迁移程序迁不走该行数据。此时delete操作在消息队列里还有记录，后期订阅程序订阅到该delete操作，再执行一次delete，并不会对一致性有影响。\n对update的操作类似，不赘述。\n双写部署法(二) 上面的方法有一个硬伤，注意我有一句话\n(2)在代码中，与test_tb有关的业务，多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中，至于消息体如何组装，大家自行考虑。\n大家想一下，这么做，是不是造成了严重的代码入侵。将非业务代码嵌入业务代码，这么做，后期删代码的时候特别累。\n有没什么方法，可以避免这个问题的?\n有的，订阅binlog日志。关于binlog日志，我尽量下周写一篇《研发应该掌握的binlog知识》，这边我就介绍一下作用\n记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。binlog不会记录SELECT和SHOW这类操作，因为这类操作对据本身并没有修改。\n还记得我们在双写部署法(一)里介绍的，往消息队列里发的消息，都是写操作的消息。而binlog日志记录的也是写操作。所以订阅该日志，也能满足我们的需求。\n于是步骤如下\n(1)打开binlog日志，系统正常上线就好\n(2)还是写一个迁移程序，迁移历史数据。步骤和上面类似，不啰嗦了。\n步骤(1)~步骤(2)流程图如下\n(3)写一个订阅程序，订阅binlog(mysql中有canal。至于oracle中，大家就随缘自己写吧)。然后将订阅到的数据通过中间件，写入新库。\n(4)检验一致性，没问题就切库。\n步骤(3)~步骤(4)流程图如下\n怎么验数据一致性\n这里大概介绍一下吧，这篇的篇幅太长了，大家心里有底就行。\n(1)先验数量是否一致，因为验数量比较快。\n至于验具体的字段，有两种方法:\n(2.1)有一种方法是，只验关键性的几个字段是否一致。\n(2.2)还有一种是 ，一次取50条(不一定50条，具体自己定，我只是举例),然后像拼字符串一样，拼在一起。用md5进行加密，得到一串数值。新库一样如法炮制，也得到一串数值，比较两串数值是否一致。如果一致，继续比较下50条数据。如果发现不一致，用二分法确定不一致的数据在0-25条，还是26条-50条。以此类推，找出不一致的数据，进行记录即可。\nok，啰嗦完毕。\n","id":24,"section":"posts","summary":"转自公众号“孤独烟” 引言 我们先来讲一个段子 面试官：“有并发的经验没？” 应聘者：“有一点。” 面试官：“那你们为了处理并发，做了哪些优化？” 应聘","tags":["mysql"],"title":"[转]分库分表如何部署上线","uri":"https://www.mingaccount.com/2019/10/divide-table-how-to-deploy/","year":"2019"},{"content":"转自微信公众号“孤独烟”\n简单版\n我们先明白一点，在mysql中，Int整型的范围如下\n我们以无符号整型为例，存储范围为0～4294967295，约43亿！我们先说一下，一旦自增id达到最大值，此时数据继续插入是会报一个主键冲突异常如下所示\n//Duplicate entry \u0026lsquo;4294967295\u0026rsquo; for key \u0026lsquo;PRIMARY\u0026rsquo;\n那解决方法也是很简单的，将Int类型改为BigInt类型，BigInt的范围如下\n就算你每秒10000条数据，跑100年，单表的数据也才\n10000243600365100=31536000000000\n这数字距离BigInt的上限还差的远，因此你将自增ID设为BigInt类型，你是不用考虑自增ID达到最大值这个问题！\n然而，如果你在面试中的回答如果是\n你:\u0026quot;简单啊，把自增主键的类型改为BigInt类型就好了！\u0026quot; 接下来，面试官可以问你一个更坑的问题！ 面试官:\u0026quot;你在线上怎么修改列的数据类型的？\u0026quot; 你:\u0026quot;what！我还是回等通知吧！\u0026quot;  怎么改\n目前业内在线修改表结构的方案，据我了解，一般有如下三种\n方式一:使用mysql5.6+提供的在线修改功能\n所谓的mysql自己提供的功能也就是mysql自己原生的语句，例如我们要修改原字段名称及类型。\nmysql\u0026gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;\r 那么，在mysql5.5这个版本之前，这是通过临时表拷贝的方式实现的。执行ALTER语句后，会新建一个带有新结构的临时表，将原表数据全部拷贝到临时表，然后Rename，完成创建操作。这个方式过程中，原表是可读的，不可写。\n在5.6+开始，mysql支持在线修改数据库表，在修改表的过程中，对绝大部分操作，原表可读，也可以写。\n那么，对于修改列的数据类型这种操作，原表还能写么？来来来，烟哥特意去官网找了mysql8.0版本的一张图\n如图所示，对于修改数据类型这种操作，是不支持并发的DML操作！也就是说，如果你直接使用ALTER这样的语句在线修改表数据结构，会导致这张表无法进行更新类操作(DELETE、UPDATE、DELETE)。\n因此，直接ALTER是不行滴！\n那我们只能用方式二或者方式三\n方式二:借助第三方工具 业内有一些第三方工具可以支持在线修改表结构，使用这些第三发工具，能够让你在执行ALTER操作的时候，表不会阻塞！比较出名的有两个\npt-online-schema-change，简称pt-osc\nGitHub正式宣布以开源的方式发布的工具，名为gh-ost\n以pt-osc为例，它的原理如下\n1、创建一个新的表，表结构为修改后的数据表，用于从源数据表向新表中导入数据。\n2、创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，用于数据拷贝结束后，执行这些操作，保证数据不会丢失。\n3、拷贝数据，从源数据表中拷贝数据到新表中。\n4、rename源数据表为old表，把新表rename为源表名，并将old表删除。\n5、删除触发器。\n然而这两个有意(KENG)思(B)的工具，居然。。。居然。。。唉！如果你的表里有触发器和外键，这两个工具是不行滴！\n如果真碰上了数据库里有触发器和外键，只能硬杠了，请看方式三\n方式三:改从库表结构，然后主从切换\n此法极其麻烦，需要专业水平的选手进行操作。因为我们的mysql架构一般是读写分离架构，从机是用来读的。我们直接在从库上进行表结构修改，不会阻塞从库的读操作。改完之后，进行主从切换即可。唯一需要注意的是，主从切换过程中可能会有数据丢失的情况！\n高深版\n其实答完上面的问题后，这篇文章差不多完了。但是，还记得我在开头说的么。这是一个很有意(KENG)思(B)的问题，为什么呢？\n假设啊，你的表里的自增字段为有符号的Int类型的，也就是说，你的字段范围为-2147483648到2147483648。\n一切又那么刚好，你的自增ID是从0开始的，也就是说，现在你的可以用的范围为0～2147483648。\n我们明确一点，表中真实的数据ID，肯定会出现一些意外，ID不一定是连续的。例如，有如下情形的出现\nCREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`), ) ENGINE=InnoDB;  执行下列SQL\ninsert into t values(null);\r// 插入的行是 (1)\rbegin;\rinsert into t values(null);\rrolllack;\rinsert into t values(null);\r// 插入的行是 (3)\r 因此，表中的真实id必然会出现断续的情况。\n好，那这会你的自增主键id的数据范围为0～2147483648，也就是单表21亿条数据！考虑id会出现断续，真实数据顶多18亿条吧。\n老哥，都单表18亿条了，还不分库分表？你一旦分库分表了，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。此时，我们就需要提供一 个全局唯一的ID号生成策略来支持分库分表的环境。\n因此在实际中，你根本等不到自增主键用完到情形！因此，你需要关注的文章应该是分库分表后如何部署上线\n所以，专业版回答如下\n面试官:\u0026quot;那自增主键达到最大值了，用完了怎么办？\u0026quot; 你:\u0026quot;这问题没遇到过，因为自增主键我们用int类型，一般达不到最大值，我们就分库分表了，所以不曾遇见过！\u0026quot;  ","id":25,"section":"posts","summary":"转自微信公众号“孤独烟” 简单版 我们先明白一点，在mysql中，Int整型的范围如下 我们以无符号整型为例，存储范围为0～4294967295，","tags":["mysql"],"title":"[转]自增主键用完了该怎么办","uri":"https://www.mingaccount.com/2019/10/auto-increment-id-is-dry/","year":"2019"},{"content":"执行转换命令 gradle init\r 问题 idea构建控制台乱码 菜单 Help-\u0026gt;Edit Custom VM Options\n添加以下VM参数\n-Dfile.encoding=utf-8\r gradle build失败  idea清除所有失效缓存 File-\u0026gt;invalidate caches/restart gradle输出目录默认为build跟maven的out有区别，确保project structure中配置正确 maven中如果有依赖lombok，光靠默认init命令生成的lombok依赖是不够的，需要重新配置lombok依赖：  dependencies {\rcompileOnly 'org.projectlombok:lombok:1.18.16'\rannotationProcessor 'org.projectlombok:lombok:1.18.16'\rtestCompileOnly 'org.projectlombok:lombok:1.18.16'\rtestAnnotationProcessor 'org.projectlombok:lombok:1.18.16'\r}\r  引用自lombok gradle\n ","id":26,"section":"posts","summary":"执行转换命令 gradle init 问题 idea构建控制台乱码 菜单 Help-\u0026gt;Edit Custom VM Options 添加以下VM参数 -Dfile.encoding=utf-8 gradle build失败 idea清除所有失效缓存 File-\u0026gt;invalidate caches/restart gradle输出目录默认","tags":["gradle"],"title":"Maven项目转为Gradle","uri":"https://www.mingaccount.com/2019/09/gradle-init/","year":"2019"},{"content":"\u0026ldquo;\\ufeff\u0026quot;是UTF-8 BOM编码的文件头，代表该文件按照什么字节顺序排序\n调用java的工具类 [UnicodeInputStream]即可解决这个问题\n//第二个参数targetEncoding为null时在getDetectedEncoding方法中会自动检测编码类型\rUnicodeInputStream unicodeInputStream = new UnicodeInputStream(inputStream, null);\rString enc = unicodeInputStream.getDetectedEncoding();\r//UnicodeInputStream内部由PushbackInputStream实现，跳过了无意义的文件头\rbufferedReader = new BufferedReader(new InputStreamReader(unicodeInputStream, enc));\r ","id":27,"section":"posts","summary":"\u0026ldquo;\\ufeff\u0026quot;是UTF-8 BOM编码的文件头，代表该文件按照什么字节顺序排序 调用java的工具类 [UnicodeIn","tags":["java"],"title":"Java读取文件内容文件头有﻿","uri":"https://www.mingaccount.com/2019/09/java-stream-bom/","year":"2019"},{"content":"原因是spark有两个文件头\n　[file://]代表本地\n　[hdfs://]代表hdfs路径\n如果路径没有文件头，spark会将该路径默认添加上\u0026quot;hdfs://\u0026quot;\n所以如果要访问本地csv文件，需要确保路径前面有\u0026quot;file://\u0026quot;\n//java代码，告诉spark这是本地文件\r\u0026quot;file:///\u0026quot; + url\r ","id":28,"section":"posts","summary":"原因是spark有两个文件头 [file://]代表本地 [hdfs://]代表hdfs路径 如果路径没有文件头，spark会将该路径默认添加上\u0026","tags":["spark"],"title":"SparkSession.read().csv()无法定位本地文件的问题","uri":"https://www.mingaccount.com/2019/09/spark-session-cant-read-local-file/","year":"2019"},{"content":"正确的调用方式为：\n@Component\rpublic class IconProperties {\r@Value(\u0026quot;${icon.url}\u0026quot;)\rprivate String url;\r}\rpublic class test{\r@Autowired\rIconProperties icon;\rpublic void test(){ String url = icon.url; }\r}\r 这里有三个需要注意的点：\n1.@Value赋值是否正确\n2.IconProperties是否有@Component，或者其他代表着该类交于Spring容器管理的注解\n3.在调用参数时通过@Autowired实例化类来调取\n","id":29,"section":"posts","summary":"正确的调用方式为： @Component public class IconProperties { @Value(\u0026quot;${icon.url}\u0026quot;) private String url; } public class test{ @Autowired IconProperties icon; public void test(){ String url = icon.url; } } 这里有三个需要注意的点： 1.@Value赋值是否正确 2.IconProp","tags":["spring"],"title":"Spring @Value注解无法正确赋值问题","uri":"https://www.mingaccount.com/2019/09/spring-value-anno-cant-set-value/","year":"2019"},{"content":"基于Spring 的@Transactional注解，JOOQ可以非常简单的实现事务管理，详细参考JOOQ-Spring Transactional Management\n这里主要讨论如Spring注解不能介入的情况，或者事务范围小于方法\ncreate.transaction(configuration -\u0026gt; {\rAuthorRecord author =\rDSL.using(configuration)\r.insertInto(AUTHOR, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)\r.values(\u0026quot;George\u0026quot;, \u0026quot;Orwell\u0026quot;)\r.returning()\r.fetchOne();\rDSL.using(configuration)\r.insertInto(BOOK, BOOK.AUTHOR_ID, BOOK.TITLE)\r.values(author.getId(), \u0026quot;1984\u0026quot;)\r.values(author.getId(), \u0026quot;Animal Farm\u0026quot;)\r.execute();\r// Implicit commit executed here\r});\r 注意上面例子中的create虽然就是一个DslContext，但是你不能直接用于实现中，需要获取到他的configuration，重新构造一个\n 详细参考Jooq Transactional Management\n ","id":30,"section":"posts","summary":"基于Spring 的@Transactional注解，JOOQ可以非常简单的实现事务管理，详细参考JOOQ-Spring Transactional Management 这里主要讨论如Sp","tags":["jooq"],"title":"JOOQ事务处理","uri":"https://www.mingaccount.com/2019/08/jooq-transaction/","year":"2019"},{"content":"delimiter // #定义标识符为双斜杠\rdrop procedure if exists test; #如果存在test存储过程则删除\rcreate procedure test() #创建无参存储过程,名称为test\rbegin\rdeclare i int; #申明变量\rset i = 0; #变量赋值\rwhile i \u0026lt; 50 do #结束循环的条件: 当i大于10时跳出while循环\rINSERT INTO table_test\r( name\r)\rVALUES\r(\r'123'\r);\rSET i=i+1;　#循环条件不能丢\rend while; #结束while循环\rselect * from test; #查看test表数据\rend\r// #结束定义语句\rcall test(); #调用存储过程\r 以上是mysql循环语句，但我在执行的时候忘了加上SET 循环条件，导致SQL无限循环往表里插入数据\n这种情况光是关闭SQL窗口，是不管用的，SQL会在后台继续运行，需要找到对应线程，手动杀死\n#展示所有运行中的线程，线程信息里会展示对应SQL\rSHOW PROCESSLIST;\r#杀掉对应线程id\rKILL 123456;\r ","id":31,"section":"posts","summary":"delimiter // #定义标识符为双斜杠 drop procedure if exists test; #如果存在test存储过程则删除 create procedure test() #创建无参存储过程,名称为test begin declare i int; #申明变量 set i = 0; #变量赋","tags":["mysql"],"title":"Mysql循环语句，死循环解决办法","uri":"https://www.mingaccount.com/2019/08/mysql-dead-cycle/","year":"2019"},{"content":"Jenkinsfile pipeline {\ragent any\rstages {\rstage('Test') {\rsteps {\rsh './mvnw test'\r}\r}\r}\rpost {\ralways {\rjunit 'target/surefire-reports/*.xml'\r}\r}\r}\r 异常 ./mvnw: Permission denied\r 解决方案 git update-index --chmod +x mvnw  ","id":32,"section":"posts","summary":"Jenkinsfile pipeline { agent any stages { stage('Test') { steps { sh './mvnw test' } } } post { always { junit 'target/surefire-reports/*.xml' } } } 异常 ./mvnw: Permission denied 解决方案 git update-index --chmod +x mvnw","tags":["jenkins","git"],"title":"jenkins sh permission denied","uri":"https://www.mingaccount.com/2019/08/jenkins-sh-permission-denied/","year":"2019"},{"content":"问题 最近项目小组在重新规划工程的业务缓存，其中涉及到部分代码重构，过程中发现有些工具类中的静态方法需要依赖别的对象实例（该实例已配置在xml成Spring bean，非静态可以用@Autowired加载正常使用），而我们知道，类加载后静态成员是在内存的共享区，静态方法里面的变量必然要使用静态成员变量，这就有了如下代码：\n@Component\rpublic class TestClass {\r@Autowired\rprivate static AutowiredTypeComponent component;\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 编译正常，但运行时报java.lang.NullPointerException: null异常，显然在调用testMethod()方法时，component变量还没被初始化，报NPE。\n原因 所以，在Springframework里，我们是不能@Autowired一个静态变量，使之成为一个Spring bean的。为什么？其实很简单，因为当类加载器加载静态变量时，Spring上下文尚未加载。所以类加载器不会在bean中正确注入静态类，并且会失败。\n解决方案 方式一 将@Autowired 注解到类的构造函数上。很好理解，Spring扫描到AutowiredTypeComponent的bean，然后赋给静态变量component。示例如下：\n@Component\rpublic class TestClass {\rprivate static AutowiredTypeComponent component;\r@Autowired\rpublic TestClass(AutowiredTypeComponent component) {\rTestClass.component = component;\r}\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 方式二 给静态组件加setter方法，并在这个方法上加上@Autowired。Spring能扫描到AutowiredTypeComponent的bean，然后通过setter方法注入。示例如下：\n@Component\rpublic class TestClass {\rprivate static AutowiredTypeComponent component;\r@Autowired\rpublic void setComponent(AutowiredTypeComponent component){\rTestClass.component = component;\r}\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 方式三 定义一个静态组件，定义一个非静态组件并加上@Autowired注解，再定义一个初始化组件的方法并加上@PostConstruct注解。这个注解是JavaEE引入的，作用于servlet生命周期的注解，你只需要知道，用它注解的方法在构造函数之后就会被调用。示例如下：\n@Component\rpublic class TestClass {\rprivate static AutowiredTypeComponent component;\r@Autowired\rprivate AutowiredTypeComponent autowiredComponent;\r@PostConstruct\rprivate void beforeInit() {\rcomponent = this.autowiredComponent;\r}\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 方式四 直接用Spring框架工具类获取bean，定义成局部变量使用。但有弊端：如果该类中有多个静态方法多次用到这个组件则每次都要这样获取，个人不推荐这种方式。示例如下：\npublic class TestClass {\r// 调用静态组件的方法\rpublic static void testMethod() {\rAutowiredTypeComponent component = SpringApplicationContextUtil.getBean(\u0026quot;component\u0026quot;);\rcomponent.callTestMethod();\r}\r}\r 原文：https://blog.csdn.net/RogueFist/article/details/79575665\n","id":33,"section":"posts","summary":"问题 最近项目小组在重新规划工程的业务缓存，其中涉及到部分代码重构，过程中发现有些工具类中的静态方法需要依赖别的对象实例（该实例已配置在xml","tags":["spring"],"title":"[转]Spring中使用@Autowired注解静态实例对象","uri":"https://www.mingaccount.com/2019/07/spring-autowired-static-object/","year":"2019"},{"content":"1.数据库url后追加\n\u0026amp;serverTimezone=Asia/Shanghai\r 2.修改数据库默认时区\nshow variables like \u0026quot;%time_zone%\u0026quot;;#查询当前时区\rset global time_zone = '+8:00'; #修改mysql全局时区为北京时间，即我们所在的东8区\rset time_zone = '+8:00'; #修改当前会话时区\rflush privileges; #立即生效\r ","id":34,"section":"posts","summary":"1.数据库url后追加 \u0026amp;serverTimezone=Asia/Shanghai 2.修改数据库默认时区 show variables like \u0026quot;%time_zone%\u0026quot;;#查询当前时区 set global time_zone = '+8:00'; #修改mysql","tags":["mysql"],"title":"Mysql 日期TIMESTAMP类型插入，与系统时间有差异","uri":"https://www.mingaccount.com/2019/07/mysql-timestamp-time-zone/","year":"2019"},{"content":"public class EncryptUtils {\rprivate static final String SECRET_KEY_1 = \u0026quot;YIORGA4dBYp6y7u8\u0026quot;;\rprivate static final String SECRET_KEY_2 = \u0026quot;C6B8r5y7u7Uh37Sy\u0026quot;;\rprivate IvParameterSpec ivParameterSpec;\rprivate SecretKeySpec secretKeySpec;\rprivate Cipher cipher;\rpublic EncryptUtils() throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException {\rivParameterSpec = new IvParameterSpec(SECRET_KEY_1.getBytes(\u0026quot;UTF-8\u0026quot;));\rsecretKeySpec = new SecretKeySpec(SECRET_KEY_2.getBytes(\u0026quot;UTF-8\u0026quot;), \u0026quot;AES\u0026quot;);\rcipher = Cipher.getInstance(\u0026quot;AES/CBC/PKCS5PADDING\u0026quot;);\r}\r/**\r* Encrypt the string with this internal algorithm.\r*\r* @param toBeEncrypt string object to be encrypt.\r* @return returns encrypted string.\r* @throws NoSuchPaddingException\r* @throws NoSuchAlgorithmException\r* @throws InvalidAlgorithmParameterException\r* @throws InvalidKeyException\r* @throws BadPaddingException\r* @throws IllegalBlockSizeException\r*/\rpublic String encrypt(String toBeEncrypt) throws NoSuchPaddingException, NoSuchAlgorithmException,\rInvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\rcipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\rbyte[] encrypted = cipher.doFinal(toBeEncrypt.getBytes());\rreturn Base64.encodeBase64String(encrypted);\r}\r/**\r* Decrypt this string with the internal algorithm. The passed argument should be encrypted using\r* {@link #encrypt(String) encrypt} method of this class.\r*\r* @param encrypted encrypted string that was encrypted using {@link #encrypt(String) encrypt} method.\r* @return decrypted string.\r* @throws InvalidAlgorithmParameterException\r* @throws InvalidKeyException\r* @throws BadPaddingException\r* @throws IllegalBlockSizeException\r*/\rpublic String decrypt(String encrypted) throws InvalidAlgorithmParameterException, InvalidKeyException,\rBadPaddingException, IllegalBlockSizeException {\rcipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);\rbyte[] decryptedBytes = cipher.doFinal(Base64.decodeBase64(encrypted));\rreturn new String(decryptedBytes);\r}\r}\r ","id":35,"section":"posts","summary":"public class EncryptUtils { private static final String SECRET_KEY_1 = \u0026quot;YIORGA4dBYp6y7u8\u0026quot;; private static final String SECRET_KEY_2 = \u0026quot;C6B8r5y7u7Uh37Sy\u0026quot;; private IvParameterSpec ivParameterSpec; private SecretKeySpec secretKeySpec; private Cipher cipher; public EncryptUtils() throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException { ivParameterSpec = new IvParameterSpec(SECRET_KEY_1.getBytes(\u0026quot;UTF-8\u0026quot;)); secretKeySpec = new SecretKeySpec(SECRET_KEY_2.getBytes(\u0026quot;UTF-8\u0026quot;), \u0026quot;AES\u0026quot;); cipher = Cipher.getInstance(\u0026quot;AES/CBC/PKCS5PADDING\u0026quot;); } /** * Encrypt the string with this internal algorithm. * * @param toBeEncrypt string object to be encrypt. * @return returns encrypted string.","tags":["java"],"title":"Java加密类Cipher的使用","uri":"https://www.mingaccount.com/2019/07/java-cipher/","year":"2019"},{"content":"配置有@ConfigurationProperties 注解的类，有如下提示 spring boot configuration annotation processor not found in classpath\npom追加配置如下依赖即可\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt;\r\u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt;\r\u0026lt;/dependency\u0026gt;\r ","id":36,"section":"posts","summary":"配置有@ConfigurationProperties 注解的类，有如下提示 spring boot configuration annotation processor not found in classpath pom追加配置如下依赖即可 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;","tags":["spring"],"title":"spring boot configuration annotation processor not found in classpath","uri":"https://www.mingaccount.com/2019/07/spring-boot-configuration-exception/","year":"2019"},{"content":"配置复杂，比较臃肿，推荐使用idea的插件easyCode\npom.xml配置：\n\u0026lt;!-- mybatis自动生成 start --\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;!--配置文件的位置--\u0026gt;\r\u0026lt;configurationFile\u0026gt;src/main/resources/generatorConfig.xml\u0026lt;/configurationFile\u0026gt;\r\u0026lt;verbose\u0026gt;true\u0026lt;/verbose\u0026gt;\r\u0026lt;overwrite\u0026gt;true\u0026lt;/overwrite\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;Generate MyBatis Artifacts\u0026lt;/id\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;generate\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis-generator-core\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;!-- mybatis自动生成 end --\u0026gt;\r 配置文件generatorConfig.xml：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE generatorConfiguration\rPUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot;\r\u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt;\r\u0026lt;generatorConfiguration\u0026gt;\r\u0026lt;classPathEntry location=\u0026quot;/Program Files/IBM/SQLLIB/java/db2java.zip\u0026quot; /\u0026gt;\r\u0026lt;context id=\u0026quot;DB2Tables\u0026quot; targetRuntime=\u0026quot;MyBatis3\u0026quot;\u0026gt;\r\u0026lt;!--optional,旨在创建class时，对注释进行控制--\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;property name=\u0026quot;suppressDate\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026gt; \u0026lt;property name=\u0026quot;suppressAllComments\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/commentGenerator\u0026gt;\r\u0026lt;jdbcConnection driverClass=\u0026quot;COM.ibm.db2.jdbc.app.DB2Driver\u0026quot;\rconnectionURL=\u0026quot;jdbc:db2:TEST\u0026quot;\ruserId=\u0026quot;db2admin\u0026quot;\rpassword=\u0026quot;db2admin\u0026quot;\u0026gt;\r\u0026lt;/jdbcConnection\u0026gt;\r\u0026lt;javaTypeResolver \u0026gt;\r\u0026lt;property name=\u0026quot;forceBigDecimals\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt;\r\u0026lt;/javaTypeResolver\u0026gt;\r\u0026lt;javaModelGenerator targetPackage=\u0026quot;test.model\u0026quot; targetProject=\u0026quot;\\MBGTestProject\\src\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;enableSubPackages\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;property name=\u0026quot;trimStrings\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;/javaModelGenerator\u0026gt;\r\u0026lt;sqlMapGenerator targetPackage=\u0026quot;test.xml\u0026quot; targetProject=\u0026quot;\\MBGTestProject\\src\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;enableSubPackages\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;/sqlMapGenerator\u0026gt;\r\u0026lt;javaClientGenerator type=\u0026quot;XMLMAPPER\u0026quot; targetPackage=\u0026quot;test.dao\u0026quot; targetProject=\u0026quot;\\MBGTestProject\\src\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;enableSubPackages\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;/javaClientGenerator\u0026gt;\r\u0026lt;table schema=\u0026quot;DB2ADMIN\u0026quot; tableName=\u0026quot;ALLTYPES\u0026quot; domainObjectName=\u0026quot;Customer\u0026quot; \u0026gt;\r\u0026lt;property name=\u0026quot;useActualColumnNames\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;generatedKey column=\u0026quot;ID\u0026quot; sqlStatement=\u0026quot;DB2\u0026quot; identity=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;columnOverride column=\u0026quot;DATE_FIELD\u0026quot; property=\u0026quot;startDate\u0026quot; /\u0026gt;\r\u0026lt;ignoreColumn column=\u0026quot;FRED\u0026quot; /\u0026gt;\r\u0026lt;columnOverride column=\u0026quot;LONG_VARCHAR_FIELD\u0026quot; jdbcType=\u0026quot;VARCHAR\u0026quot; /\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;/context\u0026gt;\r\u0026lt;/generatorConfiguration\u0026gt;\r 配置文件的注意事项： 这个文件指定得事DB2的驱动，也可以配置其他驱动的路径。\n \u0026ldquo;Java Type Resolver\u0026quot;的属性force bigDecimal为false - 这意味着整形（Short,Integer,Long,etc.)在可能的情况下将会被替换。这个属性是为了更好地处理数据库的DECIMAL和NUMERIC类型的列。 \u0026ldquo;javaModelGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026quot;为true。这意味着生成的PO类将会被放到\u0026quot;test.model.db2admin\u0026quot;这个目录下（因为表是在DB2ADMIN这个schema下）。如果\u0026quot;enableSubPackage\u0026quot;属性为false，这个包就会变为\u0026quot;test.model\u0026rdquo;。同样在\u0026quot;javaModelGenerator\u0026quot;属性下的\u0026quot;trimStrings\u0026quot;意味着在设置po的任何字符串属性时会调用trim方法，这在数据库返回列信息中有空字符串时会有用到。 \u0026ldquo;sqlMapGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026rdquo;，跟\u0026quot;javaModelGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026quot;原理相同。 \u0026ldquo;javaClientGenerator的属性\u0026quot;enableSubPackages\u0026rdquo;，跟\u0026quot;javaModelGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026quot;原理相同。DAO的生成器会生成mapper接口，它为MyBatis引用了一个XML的配置。 这个文件只指定了一个表将被内省，但也可以指定多个。关于指定表的注意事项如下：  生成的PO的名称将基于Customer(CustomerKey,Customer,CustoerMapper,etc.)-而不是基于表名。 \u0026ldquo;useActualColumnNames\u0026quot;属性。如果这个属性设为false（或者未被指定），MBG将会取列的驼峰命名。无论何总情况PO的列明都会被属性覆盖。 列有一个\u0026quot;generatedKey\u0026rdquo;，它是一个标识列，而且\u0026quot;sqlStatement\u0026quot;是DB2。MBG会在生成语句时生成一个元素，以便新生成的key能够被返回（使用DB2特定的SQL)。 \u0026ldquo;columnOverrid\u0026quot;属性中的\u0026quot;date_field\u0026quot;将映射到属性\u0026quot;startDate\u0026rdquo;。这回覆盖默认的\u0026quot;useActualColumnNames\u0026quot;属性所设定的规则。 \u0026ldquo;ignoredColumn\u0026quot;属性中的\u0026quot;FRED\u0026quot;字段将被忽略，没有SQL会列出这个字段，也没有Java属性将被生成。 \u0026ldquo;LONG_VARCHAR_FIELD\u0026quot;将被当作一个\u0026quot;VARCHAR\u0026quot;处理，忽略掉它实际的数据类型。    （原文）Important notes about this file follow:  The file specifies that the legacy DB2 CLI driver will be used to connect to the database, and also specifies where the driver can be found. The Java Type Resolver should not force the use of BigDecimal fields - this means that integral types (Short, Integer, Long, etc.) will be substituted if possible. This feature is an attempt to make database DECIMAL and NUMERIC columns easier to deal with. The Java model generator should use sub-packages. This means that the generated model objects will be placed in a package called test.model.db2admin in this case (because the table is in the DB2ADMIN schema). If the enableSubPackages attribute was set to false, then the package would be test.model. The Java model generator should also trim strings. This means that the setters for any String properties will call the trim function - this is useful if your database might return blank characters at the end of character columns. The SQL Map generator should use sub-packages. This means that the generated XML files will be placed in a package called test.xml.db2admin in this case (because the table is in the DB2ADMIN schema). If the enableSubPackages attribute was set to false, then the package would be test.xml. The DAO generator should use sub-packages. This means that the generated DAO classes will be placed in a package called test.dao.db2admin in this case (because the table is in the DB2ADMIN schema). If the enableSubPackages attribute was set to false, then the package would be test.dao. The DAO generator should generate mapper interfaces that reference an XML configuration for MyBatis. The file specifies only one table will be introspected, but many more could be specified. Important notes about the specified table include: The generated objects will be based on the name Customer (CustomerKey, Customer, CustomerMapper, etc.) - rather than on the table name. Actual column names will be used as properties. If this property were set to false (or not specified), then MBG would attempt to camel case the column names. In either case, the name can be overridden by the element The column has a generated key, it is an identity column, and the database type is DB2. This will cause MBG to generate the proper element in the generated statement so that the newly generated key can be returned (using DB2 specific SQL). The column DATE_FIELD will be mapped to a property called startDate. This will override the default property which would be DATE_FIELD in this case, or dateFieldif the useActualColumnNames property was set to false. The column FRED will be ignored. No SQL will list the field, and no Java property will be generated. The column LONG_VARCHAR_FIELD will be treated as a VARCHAR field, regardless of the actual data type.  ","id":37,"section":"posts","summary":"配置复杂，比较臃肿，推荐使用idea的插件easyCode pom.xml配置： \u0026lt;!-- mybatis自动生成 start --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--配置文件的","tags":["mybatis"],"title":"Mybatis Generator配置","uri":"https://www.mingaccount.com/2019/07/mybatis-generator/","year":"2019"},{"content":"问题是由mysql的编码问题造成，因为建表的时候没有指定utf-8作为字符集 建议重新建表，或者直接调整对应字段的字符集\n1.修改mysql编码的 　查看mysql的字符集：\nshow variables where Variable_name like '%char%';\r 　修改mysql的字符集：　mysql\u0026gt; set character_set_client=utf8;\rmysql\u0026gt; set character_set_connection=utf8;\rmysql\u0026gt; set character_set_database=utf8;\rmysql\u0026gt; set character_set_results=utf8;\rmysql\u0026gt; set character_set_server=utf8;\rmysql\u0026gt; set character_set_system=utf8;\rmysql\u0026gt; set collation_connection=utf8;\rmysql\u0026gt; set collation_database=utf8;\rmysql\u0026gt; set collation_server=utf8;\r 2.修改数据库的编码 　查看数据库的字符集：\nshow create database enterprises;\r 　修改数据库的字符集：\nalter database enterprises character set utf8\r 3.修改表的编码 　查看表的字符集：\n#位于建表语句的末尾\rshow create table employees;\r 　修改表的字符集：\nalter table employees character set utf8\r 　修改字段的字符集：\nalter table employees change name name char(10) character set utf-8;\r ","id":38,"section":"posts","summary":"问题是由mysql的编码问题造成，因为建表的时候没有指定utf-8作为字符集 建议重新建表，或者直接调整对应字段的字符集 1.修改mysql编码","tags":["mysql"],"title":"mySql 插入中文异常 Incorrect string value: '***' for column","uri":"https://www.mingaccount.com/2019/07/mysql-insert-chinese-exception/","year":"2019"},{"content":"简介 Nexus repository Manager可以作为Maven的私服，意味着在Maven中央仓库和你本地项目之间多了一层代理。在本地访问已经加载过的jar包时，私服不需要再重新从中央仓库下载，直接内网传输给本地项目。如果私服中没有，再从中央仓库中下载。此外，因为是私服，你可以直接使用mvn deploy命令，将本地包推到私服中，便于复用和版本管理。\n 下载和文档参考nexus oss doc\n maven deploy maven deploy命令是将本地项目生成的jar包推送到远程仓库，这里可以通过pom.xml中的\u0026lt;distributionManagement \u0026gt;将远程仓库配置为nexus\n 参考maven distributionManagement\n ","id":39,"section":"posts","summary":"简介 Nexus repository Manager可以作为Maven的私服，意味着在Maven中央仓库和你本地项目之间多了一层代理。在本地访问已经加载过的jar包时，私","tags":["nexus","maven"],"title":"nexus简介","uri":"https://www.mingaccount.com/2019/07/nexus/","year":"2019"},{"content":"val 精简变量修饰，类似Scala，但是默认追加了final修饰符 val list = new ArrayList\u0026lt;String\u0026gt;();\r//等同于\rfinal ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();\r var 精简变量修饰，类似Scala，修饰变量 val list = new ArrayList\u0026lt;String\u0026gt;();\r//等同于\rArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();\r NonNull 修饰方法或者构造方法的参数，以及成员变量 public NonNullExample(@NonNull Person person) {\rsuper(\u0026quot;Hello\u0026quot;);\rthis.name = person.getName();\r}\r//等同于\rpublic NonNullExample(@NonNull Person person) {\rsuper(\u0026quot;Hello\u0026quot;);\rif (person == null) {\rthrow new NullPointerException(\u0026quot;person is marked @NonNull but is null\u0026quot;);\r}\rthis.name = person.getName();\r}\r Cleanup 修饰局部变量，用于关闭资源 默认触发修饰变量的close方法，但是如果目标对象没有close方法，可以直接指定关闭方法的名称 但是要求关闭方法不能有参数\n@Cleanup(\u0026quot;dispose\u0026quot;) org.eclipse.swt.widgets.CoolBar bar = new CoolBar(parent, 0);\r import lombok.Cleanup;\rimport java.io.*;\rpublic class CleanupExample {\rpublic static void main(String[] args) throws IOException {\r@Cleanup InputStream in = new FileInputStream(args[0]);\r@Cleanup OutputStream out = new FileOutputStream(args[1]);\rbyte[] b = new byte[10000];\rwhile (true) {\rint r = in.read(b);\rif (r == -1) break;\rout.write(b, 0, r);\r}\r}\r}\r 等同于\n import java.io.*;\rpublic class CleanupExample {\rpublic static void main(String[] args) throws IOException {\rInputStream in = new FileInputStream(args[0]);\rtry {\rOutputStream out = new FileOutputStream(args[1]);\rtry {\rbyte[] b = new byte[10000];\rwhile (true) {\rint r = in.read(b);\rif (r == -1) break;\rout.write(b, 0, r);\r}\r} finally {\rif (out != null) {\rout.close();\r}\r}\r} finally {\rif (in != null) {\rin.close();\r}\r}\r}\r}\r Getter/Setter 修饰成员变量或者类，已生成GetSet方法  当修饰类时，将生成类中所有的非静态成员变量的Get/Set类 Getter/Setter都有AccessLevel参数，可设置生成的方法的修饰符(PUBLIC, PROTECTED, PACKAGE, and PRIVATE) 如果类被注解修饰，但是某个成员变量不想生成方法，可以设置AccessLevel参数值为NONE  import lombok.AccessLevel;\rimport lombok.Getter;\rimport lombok.Setter;\rpublic class GetterSetterExample {\r/**\r* Age of the person. Water is wet.\r* * @param age New value for this person's age. Sky is blue.\r* @return The current value of this person's age. Circles are round.\r*/\r@Getter @Setter private int age = 10;\r/**\r* Name of the person.\r* -- SETTER --\r* Changes the name of this person.\r* * @param name The new value.\r*/\r@Setter(AccessLevel.PROTECTED) private String name;\r@Override public String toString() {\rreturn String.format(\u0026quot;%s (age: %d)\u0026quot;, name, age);\r}\r}\r 等同于\n public class GetterSetterExample {\r/**\r* Age of the person. Water is wet.\r*/\rprivate int age = 10;\r/**\r* Name of the person.\r*/\rprivate String name;\r@Override public String toString() {\rreturn String.format(\u0026quot;%s (age: %d)\u0026quot;, name, age);\r}\r/**\r* Age of the person. Water is wet.\r*\r* @return The current value of this person's age. Circles are round.\r*/\rpublic int getAge() {\rreturn age;\r}\r/**\r* Age of the person. Water is wet.\r*\r* @param age New value for this person's age. Sky is blue.\r*/\rpublic void setAge(int age) {\rthis.age = age;\r}\r/**\r* Changes the name of this person.\r*\r* @param name The new value.\r*/\rprotected void setName(String name) {\rthis.name = name;\r}\r}\r ToString 修饰类和方法，重写toString方法  默认格式类名(字段值1，字段值2) 可通过设置includeFieldNames=true，在字段值前面加上字段名: 默认所有非静态字段都会被打印，可以通过注解@ToString.Exclude来排除字段 如果只展示目标字段，可以在类的注解上追加参数onlyExplicitlyIncluded=true，然后在字段上加注解ToString.Include 如果需要打印父类的字段，可以设置参数callSuper=true 打印方法的输出，在方法上追加注解ToString.Include，注意必须是非静态方法，并且没有参数  import lombok.ToString;\r@ToString\rpublic class ToStringExample {\rprivate static final int STATIC_VAR = 10;\rprivate String name;\rprivate Shape shape = new Square(5, 10);\rprivate String[] tags;\r@ToString.Exclude private int id;\rpublic String getName() {\rreturn this.name;\r}\r@ToString(callSuper=true, includeFieldNames=true)\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r}\r}\r 等同于\n import java.util.Arrays;\rpublic class ToStringExample {\rprivate static final int STATIC_VAR = 10;\rprivate String name;\rprivate Shape shape = new Square(5, 10);\rprivate String[] tags;\rprivate int id;\rpublic String getName() {\rreturn this.name;\r}\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r@Override public String toString() {\rreturn \u0026quot;Square(super=\u0026quot; + super.toString() + \u0026quot;, width=\u0026quot; + this.width + \u0026quot;, height=\u0026quot; + this.height + \u0026quot;)\u0026quot;;\r}\r}\r@Override public String toString() {\rreturn \u0026quot;ToStringExample(\u0026quot; + this.getName() + \u0026quot;, \u0026quot; + this.shape + \u0026quot;, \u0026quot; + Arrays.deepToString(this.tags) + \u0026quot;)\u0026quot;;\r}\r}\r EqualsAndHashCode 生成equals和hashCode方法  默认使用非静态和非transient修饰的字段 排除指定字段：注解@EqualsAndHashCode.Exclude 只选择指定字段：类注解@EqualsAndHashCode(onlyExplicitlyIncluded = true)，和字段注解@EqualsAndHashCode.Include 如果包含非Object父类，设置属性callSuper=true  import lombok.EqualsAndHashCode;\r@EqualsAndHashCode\rpublic class EqualsAndHashCodeExample {\rprivate transient int transientVar = 10;\rprivate String name;\rprivate double score;\r@EqualsAndHashCode.Exclude private Shape shape = new Square(5, 10);\rprivate String[] tags;\r@EqualsAndHashCode.Exclude private int id;\rpublic String getName() {\rreturn this.name;\r}\r@EqualsAndHashCode(callSuper=true)\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r}\r}\r 等同于\n import java.util.Arrays;\rpublic class EqualsAndHashCodeExample {\rprivate transient int transientVar = 10;\rprivate String name;\rprivate double score;\rprivate Shape shape = new Square(5, 10);\rprivate String[] tags;\rprivate int id;\rpublic String getName() {\rreturn this.name;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof EqualsAndHashCodeExample)) return false;\rEqualsAndHashCodeExample other = (EqualsAndHashCodeExample) o;\rif (!other.canEqual((Object)this)) return false;\rif (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;\rif (Double.compare(this.score, other.score) != 0) return false;\rif (!Arrays.deepEquals(this.tags, other.tags)) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal long temp1 = Double.doubleToLongBits(this.score);\rresult = (result*PRIME) + (this.name == null ? 43 : this.name.hashCode());\rresult = (result*PRIME) + (int)(temp1 ^ (temp1 \u0026gt;\u0026gt;\u0026gt; 32));\rresult = (result*PRIME) + Arrays.deepHashCode(this.tags);\rreturn result;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof EqualsAndHashCodeExample;\r}\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof Square)) return false;\rSquare other = (Square) o;\rif (!other.canEqual((Object)this)) return false;\rif (!super.equals(o)) return false;\rif (this.width != other.width) return false;\rif (this.height != other.height) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rresult = (result*PRIME) + super.hashCode();\rresult = (result*PRIME) + this.width;\rresult = (result*PRIME) + this.height;\rreturn result;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof Square;\r}\r}\r}\r @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor 生成构造函数  NoArgsConstructor 注意有参数被final修饰的情况，需要加上参数(force = true) RequiredArgsConstructor 只对两类变量有效，一种是final修饰的并且没有初始化的变量，另外一类是NonNull注解修饰并且没有初始化的变量 AllArgsConstructor 生成一个包括所有参数的构造方法，并且有NonNull注解的会进行非空检查 @RequiredArgsConstructor(staticName=\u0026quot;of\u0026quot;) 生成一个私有的构造方法，并提供一个静态方法of包装私有构造方法 以上注解只对非static字段生效  import lombok.AccessLevel;\rimport lombok.RequiredArgsConstructor;\rimport lombok.AllArgsConstructor;\rimport lombok.NonNull;\r@RequiredArgsConstructor(staticName = \u0026quot;of\u0026quot;)\r@AllArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class ConstructorExample\u0026lt;T\u0026gt; {\rprivate int x, y;\r@NonNull private T description;\r@NoArgsConstructor\rpublic static class NoArgsExample {\r@NonNull private String field;\r}\r}\r 等同于\n public class ConstructorExample\u0026lt;T\u0026gt; {\rprivate int x, y;\r@NonNull private T description;\rprivate ConstructorExample(T description) {\rif (description == null) throw new NullPointerException(\u0026quot;description\u0026quot;);\rthis.description = description;\r}\rpublic static \u0026lt;T\u0026gt; ConstructorExample\u0026lt;T\u0026gt; of(T description) {\rreturn new ConstructorExample\u0026lt;T\u0026gt;(description);\r}\r@java.beans.ConstructorProperties({\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;description\u0026quot;})\rprotected ConstructorExample(int x, int y, T description) {\rif (description == null) throw new NullPointerException(\u0026quot;description\u0026quot;);\rthis.x = x;\rthis.y = y;\rthis.description = description;\r}\rpublic static class NoArgsExample {\r@NonNull private String field;\rpublic NoArgsExample() {\r}\r}\r}\r Data 大集合  相当于一个快捷方式，包括之前的toString,EqualsAndHashCode,所有字段的Getter,非final字段的Setter，和RequiredArgsConstructor Data无法像单个注解一样添加自定义属性，但是可以再次追加单个注解，以覆盖Data对应的方法 如果有任何同名的方法存在，Data不会再生成对应的方法 如果有任意一个构造方法，Data注解将不会生成RequiredArgsConstructor对应的构造方法  import lombok.AccessLevel;\rimport lombok.Setter;\rimport lombok.Data;\rimport lombok.ToString;\r@Data public class DataExample {\rprivate final String name;\r@Setter(AccessLevel.PACKAGE) private int age;\rprivate double score;\rprivate String[] tags;\r@ToString(includeFieldNames=true)\r@Data(staticConstructor=\u0026quot;of\u0026quot;)\rpublic static class Exercise\u0026lt;T\u0026gt; {\rprivate final String name;\rprivate final T value;\r}\r}\r 等同于\n import java.util.Arrays;\rpublic class DataExample {\rprivate final String name;\rprivate int age;\rprivate double score;\rprivate String[] tags;\rpublic DataExample(String name) {\rthis.name = name;\r}\rpublic String getName() {\rreturn this.name;\r}\rvoid setAge(int age) {\rthis.age = age;\r}\rpublic int getAge() {\rreturn this.age;\r}\rpublic void setScore(double score) {\rthis.score = score;\r}\rpublic double getScore() {\rreturn this.score;\r}\rpublic String[] getTags() {\rreturn this.tags;\r}\rpublic void setTags(String[] tags) {\rthis.tags = tags;\r}\r@Override public String toString() {\rreturn \u0026quot;DataExample(\u0026quot; + this.getName() + \u0026quot;, \u0026quot; + this.getAge() + \u0026quot;, \u0026quot; + this.getScore() + \u0026quot;, \u0026quot; + Arrays.deepToString(this.getTags()) + \u0026quot;)\u0026quot;;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof DataExample;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof DataExample)) return false;\rDataExample other = (DataExample) o;\rif (!other.canEqual((Object)this)) return false;\rif (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;\rif (this.getAge() != other.getAge()) return false;\rif (Double.compare(this.getScore(), other.getScore()) != 0) return false;\rif (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal long temp1 = Double.doubleToLongBits(this.getScore());\rresult = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());\rresult = (result*PRIME) + this.getAge();\rresult = (result*PRIME) + (int)(temp1 ^ (temp1 \u0026gt;\u0026gt;\u0026gt; 32));\rresult = (result*PRIME) + Arrays.deepHashCode(this.getTags());\rreturn result;\r}\rpublic static class Exercise\u0026lt;T\u0026gt; {\rprivate final String name;\rprivate final T value;\rprivate Exercise(String name, T value) {\rthis.name = name;\rthis.value = value;\r}\rpublic static \u0026lt;T\u0026gt; Exercise\u0026lt;T\u0026gt; of(String name, T value) {\rreturn new Exercise\u0026lt;T\u0026gt;(name, value);\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic T getValue() {\rreturn this.value;\r}\r@Override public String toString() {\rreturn \u0026quot;Exercise(name=\u0026quot; + this.getName() + \u0026quot;, value=\u0026quot; + this.getValue() + \u0026quot;)\u0026quot;;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof Exercise;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof Exercise)) return false;\rExercise\u0026lt;?\u0026gt; other = (Exercise\u0026lt;?\u0026gt;) o;\rif (!other.canEqual((Object)this)) return false;\rif (this.getName() == null ? other.getValue() != null : !this.getName().equals(other.getName())) return false;\rif (this.getValue() == null ? other.getValue() != null : !this.getValue().equals(other.getValue())) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rresult = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());\rresult = (result*PRIME) + (this.getValue() == null ? 43 : this.getValue().hashCode());\rreturn result;\r}\r}\r}\r Value修饰类，生成一个final类，并且成员变量全是private final修饰  Value是个快捷方式，完整的注解：final @ToString @EqualsAndHashCode @AllArgsConstructor @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE) @Getter  在修饰类和成员变量的同时，Value会生成toString、equals、hashCode方法，还有包括所有参数的构造方法以及所有成员变量的get方法 如果有任何自定义的构造方法，Value将不会再生成一个所有参数的构造方法  import lombok.AccessLevel;\rimport lombok.experimental.NonFinal;\rimport lombok.experimental.Value;\rimport lombok.experimental.Wither;\rimport lombok.ToString;\r@Value public class ValueExample {\rString name;\r@Wither(AccessLevel.PACKAGE) @NonFinal int age;\rdouble score;\rprotected String[] tags;\r@ToString(includeFieldNames=true)\r@Value(staticConstructor=\u0026quot;of\u0026quot;)\rpublic static class Exercise\u0026lt;T\u0026gt; {\rString name;\rT value;\r}\r}\r 等同于\n import java.util.Arrays;\rpublic final class ValueExample {\rprivate final String name;\rprivate int age;\rprivate final double score;\rprotected final String[] tags;\r@java.beans.ConstructorProperties({\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;, \u0026quot;score\u0026quot;, \u0026quot;tags\u0026quot;})\rpublic ValueExample(String name, int age, double score, String[] tags) {\rthis.name = name;\rthis.age = age;\rthis.score = score;\rthis.tags = tags;\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic int getAge() {\rreturn this.age;\r}\rpublic double getScore() {\rreturn this.score;\r}\rpublic String[] getTags() {\rreturn this.tags;\r}\r@java.lang.Override\rpublic boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof ValueExample)) return false;\rfinal ValueExample other = (ValueExample)o;\rfinal Object this$name = this.getName();\rfinal Object other$name = other.getName();\rif (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;\rif (this.getAge() != other.getAge()) return false;\rif (Double.compare(this.getScore(), other.getScore()) != 0) return false;\rif (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;\rreturn true;\r}\r@java.lang.Override\rpublic int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal Object $name = this.getName();\rresult = result * PRIME + ($name == null ? 43 : $name.hashCode());\rresult = result * PRIME + this.getAge();\rfinal long $score = Double.doubleToLongBits(this.getScore());\rresult = result * PRIME + (int)($score \u0026gt;\u0026gt;\u0026gt; 32 ^ $score);\rresult = result * PRIME + Arrays.deepHashCode(this.getTags());\rreturn result;\r}\r@java.lang.Override\rpublic String toString() {\rreturn \u0026quot;ValueExample(name=\u0026quot; + getName() + \u0026quot;, age=\u0026quot; + getAge() + \u0026quot;, score=\u0026quot; + getScore() + \u0026quot;, tags=\u0026quot; + Arrays.deepToString(getTags()) + \u0026quot;)\u0026quot;;\r}\rValueExample withAge(int age) {\rreturn this.age == age ? this : new ValueExample(name, age, score, tags);\r}\rpublic static final class Exercise\u0026lt;T\u0026gt; {\rprivate final String name;\rprivate final T value;\rprivate Exercise(String name, T value) {\rthis.name = name;\rthis.value = value;\r}\rpublic static \u0026lt;T\u0026gt; Exercise\u0026lt;T\u0026gt; of(String name, T value) {\rreturn new Exercise\u0026lt;T\u0026gt;(name, value);\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic T getValue() {\rreturn this.value;\r}\r@java.lang.Override\rpublic boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof ValueExample.Exercise)) return false;\rfinal Exercise\u0026lt;?\u0026gt; other = (Exercise\u0026lt;?\u0026gt;)o;\rfinal Object this$name = this.getName();\rfinal Object other$name = other.getName();\rif (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;\rfinal Object this$value = this.getValue();\rfinal Object other$value = other.getValue();\rif (this$value == null ? other$value != null : !this$value.equals(other$value)) return false;\rreturn true;\r}\r@java.lang.Override\rpublic int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal Object $name = this.getName();\rresult = result * PRIME + ($name == null ? 43 : $name.hashCode());\rfinal Object $value = this.getValue();\rresult = result * PRIME + ($value == null ? 43 : $value.hashCode());\rreturn result;\r}\r@java.lang.Override\rpublic String toString() {\rreturn \u0026quot;ValueExample.Exercise(name=\u0026quot; + getName() + \u0026quot;, value=\u0026quot; + getValue() + \u0026quot;)\u0026quot;;\r}\r}\r}\r Builder 构造者模式生成实体类，可修饰类，构造方法和一般方法 类似\nPerson.builder().name(\u0026quot;Adam Savage\u0026quot;).city(\u0026quot;San Francisco\u0026quot;).job(\u0026quot;Mythbusters\u0026quot;).job(\u0026quot;Unchained Reaction\u0026quot;).build();\r  当一个方法被Builder注解修饰（以下简称target)，会有七个要素生成  一个内部静态类叫做 FooBuilder ，有着和静态方法一样的类型参数(以下简称builder) 在builder里，target方法的每一个参数都对应了一个私有的非静态非final的成员变量 在builder里，包含一个package范围的私有无参的空构造方法 在builder里，每一个target的参数都对应了一个类似setter的方法，但是这个setter方法跟target方法的参数名一样，并且返回了builder自身，以形成链式结构 在builder里，包含一个build方法，用对应的参数调用target方法，最终生成target方法的返回值 在builder里，包含一个合理的toString实现 在target方法所在的类，会包含一个builder方法，他会创建类builder的实例   以上的7个要素如果在检测到有同名的要素时会自动跳过（只对比名称） 当Builder作用于类时，请确保该类没有任何显性的构造函数。如果有任意显性构造函数，请直接将Builder作用于构造函数上 当Builder和Value同时作用于一个类时，Builder想要生成的Package范围的构造函数会覆盖Value想要生成的private范围的构造函数 如果参数的值需要从某个字段或者方法获取，可以在字段或者参数上添加注解@Builder.ObtainVia(method = \u0026quot;\u0026quot;) Builder可配置的方面包括  静态内部类的名称(默认是type + \u0026ldquo;Builder\u0026rdquo;) build方法的名称 builder方法的名称 是否需要toBuilder()方法 生成元素的访问范围 如果你的构造链方法需要一个前缀，比如Person.builder().setName   关于以上配置项，下面是个实例\n@Builder(builderClassName = \u0026quot;HelloWorldBuilder\u0026quot;, buildMethodName = \u0026quot;execute\u0026quot;, builderMethodName = \u0026quot;helloWorld\u0026quot;, toBuilder = true, access = AccessLevel.PRIVATE, setterPrefix = \u0026quot;set\u0026quot;) 当Builder注解作用于类，某些成员变量不需要set的时候，可以设置成员变量默认值\n成员变量上用注解@Builder.Default实现\n@Builder.Default private final long created = System.currentTimeMillis(); @Singular 注解作用于参数或者成员变量时，会吧对应参数当做集合。  不会生成setter而会生成两个adder方法，一个新增单个，一个新增整个集合 还会生成一个clear方法，一旦build方法被调用，生成的集合不能再被修改 可指定新增单个的方法名@Singular(\u0026quot;axis\u0026quot;) List\u0026lt;Line\u0026gt; axes; 如果追加的集合为null会抛出异常，可设置忽略空集合@Singular(ignoreNullCollections = true)    import lombok.Builder;\rimport lombok.Singular;\rimport java.util.Set;\r@Builder\rpublic class BuilderExample {\r@Builder.Default private long created = System.currentTimeMillis();\rprivate String name;\rprivate int age;\r@Singular private Set\u0026lt;String\u0026gt; occupations;\r}\r 等同于\n import java.util.Set;\rpublic class BuilderExample {\rprivate long created;\rprivate String name;\rprivate int age;\rprivate Set\u0026lt;String\u0026gt; occupations;\rBuilderExample(String name, int age, Set\u0026lt;String\u0026gt; occupations) {\rthis.name = name;\rthis.age = age;\rthis.occupations = occupations;\r}\rprivate static long $default$created() {\rreturn System.currentTimeMillis();\r}\rpublic static BuilderExampleBuilder builder() {\rreturn new BuilderExampleBuilder();\r}\rpublic static class BuilderExampleBuilder {\rprivate long created;\rprivate boolean created$set;\rprivate String name;\rprivate int age;\rprivate java.util.ArrayList\u0026lt;String\u0026gt; occupations;\rBuilderExampleBuilder() {\r}\rpublic BuilderExampleBuilder created(long created) {\rthis.created = created;\rthis.created$set = true;\rreturn this;\r}\rpublic BuilderExampleBuilder name(String name) {\rthis.name = name;\rreturn this;\r}\rpublic BuilderExampleBuilder age(int age) {\rthis.age = age;\rreturn this;\r}\rpublic BuilderExampleBuilder occupation(String occupation) {\rif (this.occupations == null) {\rthis.occupations = new java.util.ArrayList\u0026lt;String\u0026gt;();\r}\rthis.occupations.add(occupation);\rreturn this;\r}\rpublic BuilderExampleBuilder occupations(Collection\u0026lt;? extends String\u0026gt; occupations) {\rif (this.occupations == null) {\rthis.occupations = new java.util.ArrayList\u0026lt;String\u0026gt;();\r}\rthis.occupations.addAll(occupations);\rreturn this;\r}\rpublic BuilderExampleBuilder clearOccupations() {\rif (this.occupations != null) {\rthis.occupations.clear();\r}\rreturn this;\r}\rpublic BuilderExample build() {\r// complicated switch statement to produce a compact properly sized immutable set omitted.\rSet\u0026lt;String\u0026gt; occupations = ...;\rreturn new BuilderExample(created$set ? created : BuilderExample.$default$created(), name, age, occupations);\r}\r@java.lang.Override\rpublic String toString() {\rreturn \u0026quot;BuilderExample.BuilderExampleBuilder(created = \u0026quot; + this.created + \u0026quot;, name = \u0026quot; + this.name + \u0026quot;, age = \u0026quot; + this.age + \u0026quot;, occupations = \u0026quot; + this.occupations + \u0026quot;)\u0026quot;;\r}\r}\r}\r SneakyThrows checked Exception不用再try catch 不推荐\nSynchronized 用户成员方法或者静态方法 关键字synchronized锁的是this，但是该注解锁的是不同的对象\nimport lombok.Synchronized;\rpublic class SynchronizedExample {\rprivate final Object readLock = new Object();\r@Synchronized\rpublic static void hello() {\rSystem.out.println(\u0026quot;world\u0026quot;);\r}\r@Synchronized\rpublic int answerToLife() {\rreturn 42;\r}\r@Synchronized(\u0026quot;readLock\u0026quot;)\rpublic void foo() {\rSystem.out.println(\u0026quot;bar\u0026quot;);\r}\r}\r 等同于\n public class SynchronizedExample {\rprivate static final Object $LOCK = new Object[0];\rprivate final Object $lock = new Object[0];\rprivate final Object readLock = new Object();\rpublic static void hello() {\rsynchronized($LOCK) {\rSystem.out.println(\u0026quot;world\u0026quot;);\r}\r}\rpublic int answerToLife() {\rsynchronized($lock) {\rreturn 42;\r}\r}\rpublic void foo() {\rsynchronized(readLock) {\rSystem.out.println(\u0026quot;bar\u0026quot;);\r}\r}\r}\r With用于成员变量或者类上，表示可修改类中的任何或者指定字段，即使该字段是final 其实就是clone了一个当前类，并修改对应成员变量的值\nimport lombok.AccessLevel;\rimport lombok.NonNull;\rimport lombok.With;\rpublic class WithExample {\r@With(AccessLevel.PROTECTED) @NonNull private final String name;\r@With private final int age;\rpublic WithExample(String name, int age) {\rif (name == null) throw new NullPointerException();\rthis.name = name;\rthis.age = age;\r}\r}\r import lombok.NonNull;\rpublic class WithExample {\rprivate @NonNull final String name;\rprivate final int age;\rpublic WithExample(String name, int age) {\rif (name == null) throw new NullPointerException();\rthis.name = name;\rthis.age = age;\r}\rprotected WithExample withName(@NonNull String name) {\rif (name == null) throw new java.lang.NullPointerException(\u0026quot;name\u0026quot;);\rreturn this.name == name ? this : new WithExample(name, age);\r}\rpublic WithExample withAge(int age) {\rreturn this.age == age ? this : new WithExample(name, age);\r}\r}\r Getter(lazy=true) 修饰private final 成员变量，获取一次，并缓存，之后都取缓存 当一个成员变量的计算需要消耗大量资源，可以将它设置为private final，并加上该注解\n这个注解会在第一次计算后缓存结果，他要求计算方法是非线程安全的\nimport lombok.Getter;\rpublic class GetterLazyExample {\r@Getter(lazy=true) private final double[] cached = expensive();\rprivate double[] expensive() {\rdouble[] result = new double[1000000];\rfor (int i = 0; i \u0026lt; result.length; i++) {\rresult[i] = Math.asin(i);\r}\rreturn result;\r}\r}\r 等同于\n public class GetterLazyExample {\rprivate final java.util.concurrent.AtomicReference\u0026lt;java.lang.Object\u0026gt; cached = new java.util.concurrent.AtomicReference\u0026lt;java.lang.Object\u0026gt;();\rpublic double[] getCached() {\rjava.lang.Object value = this.cached.get();\rif (value == null) {\rsynchronized(this.cached) {\rvalue = this.cached.get();\rif (value == null) {\rfinal double[] actualValue = expensive();\rvalue = actualValue == null ? this.cached : actualValue;\rthis.cached.set(value);\r}\r}\r}\rreturn (double[])(value == this.cached ? null : value);\r}\rprivate double[] expensive() {\rdouble[] result = new double[1000000];\rfor (int i = 0; i \u0026lt; result.length; i++) {\rresult[i] = Math.asin(i);\r}\rreturn result;\r}\r}\r Log修饰类，增加成员变量log 多个注解，以适配多种Logger:\n @CommonsLog\nprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class); @Flogger\nprivate static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass(); @JBossLog private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class); @Log\nprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName()); @Log4j\nprivate static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class); @Log4j2\nprivate static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class); @Slf4j\nprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class); @XSlf4j\nprivate static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); @CustomLog\n可自定义log，详情参考结尾的官方链接  import lombok.extern.java.Log;\rimport lombok.extern.slf4j.Slf4j;\r@Log\rpublic class LogExample {\rpublic static void main(String... args) {\rlog.severe(\u0026quot;Something's wrong here\u0026quot;);\r}\r}\r@Slf4j\rpublic class LogExampleOther {\rpublic static void main(String... args) {\rlog.error(\u0026quot;Something else is wrong here\u0026quot;);\r}\r}\r@CommonsLog(topic=\u0026quot;CounterLog\u0026quot;)\rpublic class LogExampleCategory {\rpublic static void main(String... args) {\rlog.error(\u0026quot;Calling the 'CounterLog' with a message\u0026quot;);\r}\r}\r 相当于\n public class LogExample {\rprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());\rpublic static void main(String... args) {\rlog.severe(\u0026quot;Something's wrong here\u0026quot;);\r}\r}\rpublic class LogExampleOther {\rprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);\rpublic static void main(String... args) {\rlog.error(\u0026quot;Something else is wrong here\u0026quot;);\r}\r}\rpublic class LogExampleCategory {\rprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(\u0026quot;CounterLog\u0026quot;);\rpublic static void main(String... args) {\rlog.error(\u0026quot;Calling the 'CounterLog' with a message\u0026quot;);\r}\r}\r  详细参考 lombok官方文档\n ","id":40,"section":"posts","summary":"val 精简变量修饰，类似Scala，但是默认追加了final修饰符 val list = new ArrayList\u0026lt;String\u0026gt;(); //等同于 final ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); var 精简变量修饰，类似Scala，修饰变量 val list =","tags":["lombok","java"],"title":"lombok详解","uri":"https://www.mingaccount.com/2019/07/lombok/","year":"2019"},{"content":"问题背景 项目的两个依赖，包含了同一个路径，然而因为项目原因还不能删除其中任何一个\n代码在本地和线上都能正常通过编译\n但是一执行到对应代码就会抛出如下error:\n java.lang.NoClassDefFoundError:\r 问题原因 跟踪代码后得知，报错代码引用的是pom中的第二个依赖\r引用位置低于第一个\r然而maven的逻辑是谁的\u0026lt;dependency\u0026gt;在前，就优先选择哪个依赖\r 解决方案 调整\u0026lt;dependency\u0026gt;的顺序，得以解决 ","id":41,"section":"posts","summary":"问题背景 项目的两个依赖，包含了同一个路径，然而因为项目原因还不能删除其中任何一个 代码在本地和线上都能正常通过编译 但是一执行到对应代码就会抛出","tags":["maven"],"title":"Maven jar包冲突导致NoClassDefFoundError","uri":"https://www.mingaccount.com/2019/07/maven-jar-clash/","year":"2019"},{"content":"在协作开发时，从接口获取到的json实体部分为空，但是在调试时发现原对象没有任何问题，但是经过解析成为json后，部分属性变为：\n\u0026ldquo;$ref\u0026rdquo;:\u0026quot;$.*******“\n改变解析方式为Gson问题解决，经查是fastjson在解析json时，会将json中相同的内容改为引用导致\n这么做的原因是防止实体类中有自引用，解析的时候出现死循环，从而导致栈内存溢出\n可以通过设置取消fastjson的引用，但是可能出现内存溢出风险，需要自行评估\nJSONArray.toJSONString(jsonArray, SerializerFeature.DisableCircularReferenceDetect);\rJSONObject.parse(JSONArray.toJSONString(jsonArray, SerializerFeature.DisableCircularReferenceDetect));\r ","id":42,"section":"posts","summary":"在协作开发时，从接口获取到的json实体部分为空，但是在调试时发现原对象没有任何问题，但是经过解析成为json后，部分属性变为： \u0026ldquo","tags":["java"],"title":"FastJson解析结果部分属性为null的问题","uri":"https://www.mingaccount.com/2019/07/fastjson-undes-property-isnull/","year":"2019"},{"content":"spark sql也支持函数，但与通常的数据库函数有些区别，附上官方api文档，以作备忘：\nhttp://spark.apache.org/docs/latest/api/sql/index.html#acos\n","id":43,"section":"posts","summary":"spark sql也支持函数，但与通常的数据库函数有些区别，附上官方api文档，以作备忘： http://spark.apache.org/docs/latest/api/sql/index.html#acos","tags":["spark"],"title":"SparkSql函数文档","uri":"https://www.mingaccount.com/2019/07/spark-sql-api/","year":"2019"},{"content":"pom设置 \u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-install-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.5.1\u0026lt;/version\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;install-jar-lib\u0026lt;/id\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;install-file\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;!--在mvn package的时候将jar包追加到本地仓库，可修改为validate，以线上容器编译执行的mvn命令为准--\u0026gt;\r\u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;groupId\u0026gt;custom\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;custom\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;\r\u0026lt;file\u0026gt;${project.basedir}/src/main/resources/lib/custom.jar\u0026lt;/file\u0026gt;\r\u0026lt;generatePom\u0026gt;true\u0026lt;/generatePom\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r 然后像一般的包一样加上依赖即可\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;custom\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;custom\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r 可能遇到的问题  本地编译不通过   本地环境执行一下mvn package(对应pom填写的\u0026lt;phase\u0026gt;)\r 线上编译不通过   检查\u0026lt;phase\u0026gt;中的mvn语句，线上打包时是否运行\r 本地和线上环境编译都通过，但是执行到对应代码就报错，提示找不到类   确保\u0026lt;dependency\u0026gt;正确填写，如果有多个module使用，\u0026lt;plugin\u0026gt;可以只写一次，但是每个module都要填写对应\u0026lt;dependency\u0026gt;\r如果导入的本地包与现有包冲突也会出现这种问题，如果以本地包为准，需要保证本地包的\u0026lt;dependency\u0026gt;在文本顺序上要先于已有的包\r 打好包在另外一个系统上运行报错\npom加上如下依赖  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;custom\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;custom\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt;\r\u0026lt;systemPath\u0026gt;${project.basedir}/src/main/resources/lib/custom.jar\u0026lt;/systemPath\u0026gt;\r\u0026lt;/dependency\u0026gt;\r ","id":44,"section":"posts","summary":"pom设置 \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-install-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;install-jar-lib\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;install-file\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;!--在mvn package的时候将jar包追加到本地仓库，可修改为validate，以线上容器编译","tags":["maven"],"title":"Maven如何正确导入本地包，保证在线上正常运行","uri":"https://www.mingaccount.com/2019/06/maven-how-to-import-local-jar/","year":"2019"},{"content":"脚本：\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh \u0026amp;\u0026amp; chmod +x bbr.sh \u0026amp;\u0026amp; ./bbr.sh\r 查看结果：\nsysctl net.ipv4.tcp_available_congestion_control\r ","id":45,"section":"posts","summary":"脚本： wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh \u0026amp;\u0026amp; chmod +x bbr.sh \u0026amp;\u0026amp; ./bbr.sh 查看结果： sysctl net.ipv4.tcp_available_congestion_control","tags":["linux"],"title":"为服务开启BBR加速","uri":"https://www.mingaccount.com/2019/05/server-bbr/","year":"2019"},{"content":"","id":46,"section":"posts","summary":"","tags":["scala"],"title":"Scala基础类结构图","uri":"https://www.mingaccount.com/2019/05/scala-base-class-stucture/","year":"2019"},{"content":"运算符的优先级由其第一个字符决定\n以下列出的字符按优先级从高到低的顺序排列\n (all letters) | ^ \u0026amp; \u0026lt; \u0026gt; = !   + -\n* / %\n(all other special characters)\n","id":47,"section":"posts","summary":"运算符的优先级由其第一个字符决定 以下列出的字符按优先级从高到低的顺序排列 (all letters) | ^ \u0026amp; \u0026lt; \u0026gt; = ! + - * / % (all other special characters)","tags":["scala"],"title":"Scala运算符优先顺序","uri":"https://www.mingaccount.com/2019/05/scala-operation-order/","year":"2019"},{"content":"简介 Bucket4j 是一个基于令牌桶算法的限流工具\n 官网git hub\n 实例 下面实例的场景是，限制被第三方调用的频率，每个app在一个秒钟之内只能有10次请求，但是允许暂时的过载，瞬时最大的访问量是50。\nimport io.github.bucket4j.Bucket4j;\rpublic class ThrottlingFilter implements javax.servlet.Filter {\rprivate Bucket createNewBucket() {\rlong overdraft = 50; Refill refill = Refill.greedy(10, Duration.ofSeconds(1));\rBandwidth limit = Bandwidth.classic(overdraft, refill);\rreturn Bucket4j.builder().addLimit(limit).build();\r}\r@Override\rpublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\rHttpServletRequest httpRequest = (HttpServletRequest) servletRequest;\rHttpSession session = httpRequest.getSession(true);\rString appKey = SecurityUtils.getThirdPartyAppKey();\rBucket bucket = (Bucket) session.getAttribute(\u0026quot;throttler-\u0026quot; + appKey);\rif (bucket == null) {\rbucket = createNewBucket();\rsession.setAttribute(\u0026quot;throttler-\u0026quot; + appKey, bucket);\r}\r// tryConsume returns false immediately if no tokens available with the bucket\rHttpServletResponse httpResponse = (HttpServletResponse) servletResponse;\rConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);\rif (probe.isConsumed()) {\r// the limit is not exceeded\rhttpResponse.setHeader(\u0026quot;X-Rate-Limit-Remaining\u0026quot;, \u0026quot;\u0026quot; + probe.getRemainingTokens());\rfilterChain.doFilter(servletRequest, servletResponse);\r} else {\r// limit is exceeded\rHttpServletResponse httpResponse = (HttpServletResponse) servletResponse;\rhttpResponse.setStatus(429);\rhttpResponse.setHeader(\u0026quot;X-Rate-Limit-Retry-After-Seconds\u0026quot;, \u0026quot;\u0026quot; + TimeUnit.NANOSECONDS.toSeconds(probe.getNanosToWaitForRefill()));\rhttpResponse.setContentType(\u0026quot;text/plain\u0026quot;);\rhttpResponse.getWriter().append(\u0026quot;Too many requests\u0026quot;);\r}\r}\r}\r  更多实例参考Bucket4j examples\n ","id":48,"section":"posts","summary":"简介 Bucket4j 是一个基于令牌桶算法的限流工具 官网git hub 实例 下面实例的场景是，限制被第三方调用的频率，每个app在一个秒钟之内只能有10次请求，但是","tags":["website build"],"title":"Bucket4j 实例","uri":"https://www.mingaccount.com/2019/04/bucket4j-example/","year":"2019"},{"content":"判断用户上传文件的合法性仅仅通过后缀名是完全不够的，谁也不知道后缀名是否被更改，服务器保存一个不知道真实类型的文件有极大的风险。\n因此需要后台进行进一步的文件类型校验，这里有两种情况：\n　1）一般的文件类型例如：jpg、png、xlsx等等是有固定文件头的，提取出用户上传文件的文件头与固定文件头进行对比，就可以得到文件的准确类型。\n　2）文本文件：txt、csv等等。文本文件具有特殊性，文本头无明显标志。但是文本文件百分百具有业务特殊性。可以在对文本进行格式验证时，判断是否为目标类型；或者通过编码校验，看文本是否正确编码，是否有乱码存在（正确编辑的文件，不可能存在乱码），有第三方插件cpdetector可以检测当前文件的编码；最后还可以通过提供文件模板，固定文本文件的头尾等方式来进行校验。\n这里主要说明第一种情况，第二种文本情况根据业务具体环境不同，有不同的处理方式。\n文件类型枚举:\npackage com.uti.utilEnum;\rpublic enum FileTypeEnum {\rJPG(\u0026quot;ffd8ffe000104a464946\u0026quot;),\rPNG(\u0026quot;89504e470d0a1a0a0000\u0026quot;),\rGIF(\u0026quot;47494638396126026f01\u0026quot;),\rTIF(\u0026quot;49492a00227105008037\u0026quot;),\rBMP_1(\u0026quot;424d228c010000000000\u0026quot;),//16色位图(bmp)\rBMP_2(\u0026quot;424d8240090000000000\u0026quot;),//24位位图(bmp)\rBMP_3(\u0026quot;424d8e1b030000000000\u0026quot;),//256色位图(bmp)\rDWG(\u0026quot;41433130313500000000\u0026quot;),\rHTML(\u0026quot;3c21444f435459504520\u0026quot;),\rHTM(\u0026quot;3c21646f637479706520\u0026quot;),\rCSS(\u0026quot;48544d4c207b0d0a0942\u0026quot;),\rJS(\u0026quot;696b2e71623d696b2e71\u0026quot;),\rRTF(\u0026quot;7b5c727466315c616e73\u0026quot;),\rPSD(\u0026quot;38425053000100000000\u0026quot;),\rEML(\u0026quot;46726f6d3a203d3f6762\u0026quot;),\rDOC(\u0026quot;d0cf11e0a1b11ae10000\u0026quot;),\rVSD(\u0026quot;d0cf11e0a1b11ae10000\u0026quot;),\rMDB(\u0026quot;5374616E64617264204A\u0026quot;),\rPS(\u0026quot;252150532D41646F6265\u0026quot;),\rPDF(\u0026quot;255044462d312e350d0a\u0026quot;),\rRMVB(\u0026quot;2e524d46000000120001\u0026quot;),\rRM(\u0026quot;2e524d46000000120001\u0026quot;),\rFLV(\u0026quot;464c5601050000000900\u0026quot;),\rF4V(\u0026quot;464c5601050000000900\u0026quot;),\rMP4(\u0026quot;00000020667479706d70\u0026quot;),\rMP3(\u0026quot;49443303000000002176\u0026quot;),\rMPG(\u0026quot;000001ba210001000180\u0026quot;),\rWMV(\u0026quot;3026b2758e66cf11a6d9\u0026quot;),\rASF(\u0026quot;3026b2758e66cf11a6d9\u0026quot;),\rWAV(\u0026quot;52494646e27807005741\u0026quot;),\rAVI(\u0026quot;52494646d07d60074156\u0026quot;),\rMID(\u0026quot;4d546864000000060001\u0026quot;),\rZIP(\u0026quot;504b0304140000000800\u0026quot;),\rRAR(\u0026quot;526172211a0700cf9073\u0026quot;),\rINI(\u0026quot;235468697320636f6e66\u0026quot;),\rJAR(\u0026quot;504b03040a0000000000\u0026quot;),\rEXE(\u0026quot;4d5a9000030000000400\u0026quot;),\rJSP(\u0026quot;3c25402070616765206c\u0026quot;),\rMF(\u0026quot;4d616e69666573742d56\u0026quot;),\rXML(\u0026quot;3c3f786d6c2076657273\u0026quot;),\rSQL(\u0026quot;494e5345525420494e54\u0026quot;),\rJAVA(\u0026quot;7061636b616765207765\u0026quot;),\rBAT(\u0026quot;406563686f206f66660d\u0026quot;),\rGZ(\u0026quot;1f8b0800000000000000\u0026quot;),\rPROPERTIES(\u0026quot;6c6f67346a2e726f6f74\u0026quot;),\rCLASS(\u0026quot;cafebabe0000002e0041\u0026quot;),\rCHM(\u0026quot;49545346030000006000\u0026quot;),\rMXP(\u0026quot;04000000010000001300\u0026quot;),\rDOCX(\u0026quot;504b0304140006000800\u0026quot;),\rWPS(\u0026quot;d0cf11e0a1b11ae10000\u0026quot;),\rTORRENT(\u0026quot;6431303a637265617465\u0026quot;),\rMOV(\u0026quot;6D6F6F76\u0026quot;),\rWPD(\u0026quot;FF575043\u0026quot;),\rDBX(\u0026quot;CFAD12FEC5FD746F\u0026quot;),\rPST(\u0026quot;2142444E\u0026quot;),\rQDF(\u0026quot;AC9EBD8F\u0026quot;),\rPWL(\u0026quot;E3828596\u0026quot;),\rRAM(\u0026quot;2E7261FD\u0026quot;);\rprivate String value = \u0026quot;\u0026quot;;\rprivate FileTypeEnum(String value) {\rthis.value = value;\r}\rpublic String getValue() {\rreturn value;\r}\rpublic void setValue(String value) {\rthis.value = value;\r}\r}\r 具体代码:\nprivate boolean notTextFileTypeCheck(InputStream inputStream, String specifiedType) throws IOException {\rboolean fileTypeIsVaild = false;\rbyte[] buffer = new byte[10];\rinputStream.read(buffer);\r//获取当前文件的真实类型\rString curfileType = getTrueFileType(bytesToHexFileTypeString(buffer));\r//指定文件类型中是否匹配当前文件类型\rif(specifiedType.toUpperCase().equals(curfileType)){\rfileTypeIsVaild = true;\r}\rreturn fileTypeIsVaild;\r}\rprivate String getTrueFileType(String s) {\rfor (FileTypeEnum fileTypeEnum : FileTypeEnum.values()) {\rif (s.startsWith(fileTypeEnum.getValue())) {\rreturn fileTypeEnum.toString();\r}\r}\rreturn null;\r}\rprivate String bytesToHexFileTypeString(byte[] buffer) {\rStringBuilder hexFileTypeStr = new StringBuilder();\rfor (byte b : buffer) {\rString hexString = Integer.toHexString(b \u0026amp; 0xFF);\rif (hexString.length() \u0026lt; 2) {\rhexFileTypeStr.append(\u0026quot;0\u0026quot;);\r}\rhexFileTypeStr.append(hexString);\r}\rreturn hexFileTypeStr.toString();\r}\r 关于为什么要\u0026amp;0xFF，推荐一篇文章https://www.cnblogs.com/think-in-java/p/5527389.html，加上评论更好理解，还能回顾下“原码反码补码”的知识\n","id":49,"section":"posts","summary":"判断用户上传文件的合法性仅仅通过后缀名是完全不够的，谁也不知道后缀名是否被更改，服务器保存一个不知道真实类型的文件有极大的风险。 因此需要后台","tags":["java"],"title":"Java上传文件格式判断","uri":"https://www.mingaccount.com/2019/03/java-upload-file-verify-format/","year":"2019"},{"content":"原因 编码问题，可能是application.properties和类似的属性文件中有非UTF-8字符（参考spring-boot-issue ）\n或者某个依赖包有问题，没有按照utf-8来构建\n方案 ","id":50,"section":"posts","summary":"原因 编码问题，可能是application.properties和类似的属性文件中有非UTF-8字符（参考spring-boot-issue","tags":["maven"],"title":"Maven compile异常 Failed to execute goal maven-resources-plugin:3.2.0:resources  Input length = 1 ","uri":"https://www.mingaccount.com/2019/03/markdown-compile-error/","year":"2019"},{"content":"最大公约数： @tailrec\rdef gcd(a: Int, b: Int): Int =\rif (b == 0) a else gcd(b, a % b)\r 阶乘: def factorial(n: Int): Int = {\r@tailrec\rdef iter(x: Int, result: Int): Int =\rif (x == 0) result else iter(x - 1, result * x)\riter(n, 1)\r}\r @tailrec注解可以检测当前递归方法是否满足尾递归，不满足会报编译错误\n","id":51,"section":"posts","summary":"最大公约数： @tailrec def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) 阶乘: def factorial(n: Int): Int = { @tailrec def iter(x: Int, result: Int): Int = if (x == 0) result else iter(x - 1, result * x) iter(n, 1) } @tailrec注解可以检测","tags":["scala"],"title":"Scala实现的尾递归","uri":"https://www.mingaccount.com/2019/02/scala-tail-recursive/","year":"2019"},{"content":"markdown语法大多数符号需要加一个空格和正式内容区分开才会生效   横线  -\u0026ndash; *** ___   标题  # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题   文本  文本块，在文本行开头加一个tab缩进 文字高亮，用符号`包裹文本 文本换行，行末尾加两个空格 文字斜体*斜体* _斜体_ 文字粗体**粗体** __粗体__ 删除线 ~~删除线~~ 斜粗体 ***斜粗体*** ___斜粗体___ 斜粗体删除线 ***~~斜粗体删除线***~~ 图片，![alt](URL \u0026quot;title\u0026quot;) 外部链接 [链接名称](www.baidu.com)也可以链接本地文件 锚点 [回到顶部](#top) top代表任意标题，注意都是小写 空格 \u0026amp;nbsp;   列表  无序列表 一段文本前加符号*或者- 多级无序列表，下一级只需要在无序列表前加一个缩进 有序列表 一段文本前加数字和. 类似1. 多级有序列表，下一级只需要在有序列表前加一个缩进 复选框列表 [ ]未勾选 [x]已勾选 位于列头需要加-和空格- [ ]   块引用  \u0026gt; 引用块 块有多级引用\u0026gt;\u0026gt; 第二级引用 \u0026gt;\u0026gt;\u0026gt; 第三季引用\u0026hellip;\u0026hellip;   表格  格式:\r|表头1|表头2|\r|---|---|\r|表格单元|表格单元|\r|表格单元|表格单元|\r对齐：\r调整第二行的斜线\r:---是左对齐\r---:是右对齐\r:---:是居中\r|左对齐|居中|右对齐|\r|:---|:---:|---:|\r|表格单元|表格单元|表格单元|\r表格内容：\r表格中也可以用文本加粗，文本高亮等文本效果。同时也可以插入图片和链接\r ","id":52,"section":"posts","summary":"markdown语法大多数符号需要加一个空格和正式内容区分开才会生效 横线 -\u0026ndash; *** ___ 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标","tags":["markdown"],"title":"Markdown常用语法备忘","uri":"https://www.mingaccount.com/2019/01/markdown-common-symbol/","year":"2019"},{"content":"背景 controller的全局异常处理可以通过@RestControllerAdvice @ExceptionHandler来处理。但是如果filter中出了异常，controller的全局异常是无法捕获的。\n解决方案 找到filter chain中执行的第一个filter，在他的chain.doFilter()方法上加try-catch进行filter全局异常处理。这个filter就是OncePerRequestFilter。\n但这只在没有指定filter顺序的时候生效，如果你给任何Filter手动指定了顺序（比如通过Order(1)），那么OncePerRequestFilter就无法保证第一个执行。\npublic class ExceptionHandlerFilter extends OncePerRequestFilter {\rprivate final ObjectMapper objectMapper;\rpublic ExceptionHandlerFilter(ObjectMapper objectMapper) {\rthis.objectMapper = objectMapper;\r}\r@Override\rprotected void doFilterInternal(@NotNull HttpServletRequest httpServletRequest, @NotNull HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {\rtry {\rfilterChain.doFilter(httpServletRequest, httpServletResponse);\r} catch (BaseException e) {\rwriteException(e, httpServletResponse, objectMapper.writeValueAsString(e.getResultEntity()));\r} catch (Exception e) {\rwriteException(e, httpServletResponse, objectMapper.writeValueAsString(ResponseInfoEnum.UNKNOWN_EXCEPTION.buildResultEntity()));\r}\r}\rprivate void writeException(Exception e, HttpServletResponse httpServletResponse, String writeValueAsString) throws IOException {\rlog.error(e.getMessage(), e);\rhttpServletResponse.setStatus(HttpStatus.HTTP_OK);\rhttpServletResponse.setContentType(ContentType.JSON.toString());\rhttpServletResponse.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);\rhttpServletResponse.getWriter().append(writeValueAsString);\r}\r}\r 注意BaseException是业务异常的顶级父类，因此在自定义的filter中，可以抛出业务异常，向调用方展示业务异常信息。\n另外未发现的异常也会被捕获，作为UNKNOWN_EXCEPTION抛出。\n如果有其他Filter手动指定了顺序，那么上面的方法就不起作用了。这时需要通过@Order(Ordered.HIGHEST_PRECEDENCE)修饰（推荐此方法），OncePerRequestFilter不再是必要条件：\n@Order(Ordered.HIGHEST_PRECEDENCE)\r@Slf4j\r@Component\rpublic class ExceptionHandlerFilter implements Filter {\rprivate final ObjectMapper objectMapper;\rpublic ExceptionHandlerFilter(ObjectMapper objectMapper) {\rthis.objectMapper = objectMapper;\r}\r@Override\rpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\rHttpServletResponse httpServletResponse = (HttpServletResponse) response;\rtry {\rchain.doFilter(request, response);\r} catch (BaseException e) {\rwriteException(e,httpServletResponse,objectMapper.writeValueAsString(e.getResultEntity()));\r} catch (Exception e) {\rwriteException(e,httpServletResponse,objectMapper.writeValueAsString(ResponseInfoEnum.UNKNOWN_EXCEPTION.buildResultEntity()));\r}\r}\rprivate void writeException(Exception e, HttpServletResponse httpServletResponse, String writeValueAsString) throws IOException {\rlog.error(e.getMessage(), e);\rhttpServletResponse.setStatus(HttpStatus.HTTP_OK);\rhttpServletResponse.setContentType(ContentType.JSON.toString());\rhttpServletResponse.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);\rhttpServletResponse.getWriter().append(writeValueAsString);\r}\r}\r ","id":53,"section":"posts","summary":"背景 controller的全局异常处理可以通过@RestControllerAdvice @ExceptionHandler来处理。但是如果f","tags":["spring"],"title":"Springboot filter异常全局处理","uri":"https://www.mingaccount.com/2019/01/spring-boot-filter-exception-global-handler/","year":"2019"},{"content":"h2有多种数据库兼容模式，例如Mysql：jdbc:h2:mem:testdb;MODE=MYSQL。\n但是兼容模式并不可靠，还是有部分特有语句会直接报错，比如mysql的collate。因此最好还是直接使用h2原模式，使用标准sql语法。\n 参考h2 command\n ","id":54,"section":"posts","summary":"h2有多种数据库兼容模式，例如Mysql：jdbc:h2:mem:testdb;MODE=MYSQL。 但是兼容模式并不可靠，还是有部分特有语","tags":["h2"],"title":"h2兼容模式","uri":"https://www.mingaccount.com/2018/12/h2-compatible/","year":"2018"},{"content":" 参考h2 feature\n ","id":55,"section":"posts","summary":"参考h2 feature","tags":["h2"],"title":"h2 url参数","uri":"https://www.mingaccount.com/2018/12/h2-url/","year":"2018"},{"content":"@BeforeAll @BeforeEach @AfterAll @AfterEach @DisplayName 自定义的展示名称\n@IndicativeSentencesGeneration(separator = \u0026quot; -\u0026gt; \u0026ldquo;, generator = DisplayNameGenerator.ReplaceUnderscores.class) 更改生成测试名称规则，根据类名和方法名生成，并可以指定替换策略，比如上面的替换下划线为空格\n@Disabled 屏蔽整个类的测试，或者单个测试方法\n@EnabledOnOs/@DisabledOnOs 根据系统启用或者弃用\n@EnabledOnJre/@DisabledOnJre/@EnabledForJreRange/@DisabledForJreRange 指定jre版本或者范围启用或者弃用\n@EnabledIfSystemProperty/@DisabledIfSystemProperty 根据JVM系统参数启用或者弃用\n@Test\r@EnabledIfSystemProperty(named = \u0026quot;os.arch\u0026quot;, matches = \u0026quot;.*64.*\u0026quot;)\rvoid onlyOn64BitArchitectures() {\r// ...\r}\r@Test\r@DisabledIfSystemProperty(named = \u0026quot;ci-server\u0026quot;, matches = \u0026quot;true\u0026quot;)\rvoid notOnCiServer() {\r// ...\r}\r @EnabledIfEnvironmentVariable/@DisabledIfEnvironmentVariable 根据底层操作系统参数启用或者弃用\n@Test\r@EnabledIfEnvironmentVariable(named = \u0026quot;ENV\u0026quot;, matches = \u0026quot;staging-server\u0026quot;)\rvoid onlyOnStagingServer() {\r// ...\r}\r@Test\r@DisabledIfEnvironmentVariable(named = \u0026quot;ENV\u0026quot;, matches = \u0026quot;.*development.*\u0026quot;)\rvoid notOnDeveloperWorkstation() {\r// ...\r}\r @EnabledIf/@DisabledIf @Test\r@EnabledIf(\u0026quot;customCondition\u0026quot;)\rvoid enabled() {\r// ...\r}\r@Test\r@DisabledIf(\u0026quot;customCondition\u0026quot;)\rvoid disabled() {\r// ...\r}\rboolean customCondition() {\rreturn true;\r}\r @Tag 打标签跟@Filter配合使用\n@TestMethodOrder 指定测试方法执行顺序\nimport org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\rimport org.junit.jupiter.api.Order;\rimport org.junit.jupiter.api.Test;\rimport org.junit.jupiter.api.TestMethodOrder;\r@TestMethodOrder(OrderAnnotation.class)\rclass OrderedTestsDemo {\r@Test\r@Order(1)\rvoid nullValues() {\r// perform assertions against null values\r}\r@Test\r@Order(2)\rvoid emptyValues() {\r// perform assertions against empty values\r}\r@Test\r@Order(3)\rvoid validValues() {\r// perform assertions against valid values\r}\r}\r @TestInstance(Lifecycle.PER_CLASS) 默认Junit5是一个方法对应一个实例，意思就是实例中的参数被任何方法改变也不会影响其他方法。但通过上面的注解可以将其改为一个类对应一个实例，这样可能造成实例中的参数污染，可以通过@BeforeEach和@AfterEach来解决。\n改为一个类对应一个实例，可以让@BeforeAll @AfterAll声明在非static方法上，也可以在@Nested集成类中声明@BeforeAll @AfterAll\n@Nested 内部测试类\n@RepeatedTest 重复测试\n@ParameterizedTest 以给定的参数列表重复执行测试\n@ParameterizedTest\r@ValueSource(strings = { \u0026quot;racecar\u0026quot;, \u0026quot;radar\u0026quot;, \u0026quot;able was I ere I saw elba\u0026quot; })\rvoid palindromes(String candidate) {\rassertTrue(StringUtils.isPalindrome(candidate));\r}\r @ValueSource 测试方法只有单个参数，并且参数是以下类型：\n  short\n  byte\n  int\n  long\n  float\n  double\n  char\n  boolean\n  java.lang.String\n  java.lang.Class\n  @NullSource 单个参数，并且不能是原始类型\n@EmptySource 单个参数，并且类型是数组，集合，String，Set，Map\n注意以上类型的子类型不受支持\n@NullAndEmptySource @NullSource和@EmptySource的复合注解\n下面的测试方法接受了所有类型的空值\n@ParameterizedTest\r@NullAndEmptySource\r@ValueSource(strings = { \u0026quot; \u0026quot;, \u0026quot; \u0026quot;, \u0026quot;\\t\u0026quot;, \u0026quot;\\n\u0026quot; })\rvoid nullEmptyAndBlankStrings(String text) {\rassertTrue(text == null || text.trim().isEmpty());\r}\r @EnumSource 忽略names枚举的所有常量都会作为参数\n@ParameterizedTest\r@EnumSource\rvoid testWithEnumSourceWithAutoDetection(ChronoUnit unit) {\rassertNotNull(unit);\r}\r @ParameterizedTest\r@EnumSource(names = { \u0026quot;DAYS\u0026quot;, \u0026quot;HOURS\u0026quot; })\rvoid testWithEnumSourceInclude(ChronoUnit unit) {\rassertTrue(EnumSet.of(ChronoUnit.DAYS, ChronoUnit.HOURS).contains(unit));\r}\r 除了明确指定names还可以通过mode属性去匹配常量\n@ParameterizedTest\r@EnumSource(mode = EXCLUDE, names = { \u0026quot;ERAS\u0026quot;, \u0026quot;FOREVER\u0026quot; })\rvoid testWithEnumSourceExclude(ChronoUnit unit) {\rassertFalse(EnumSet.of(ChronoUnit.ERAS, ChronoUnit.FOREVER).contains(unit));\r}\r @ParameterizedTest\r@EnumSource(mode = MATCH_ALL, names = \u0026quot;^.*DAYS$\u0026quot;)\rvoid testWithEnumSourceRegex(ChronoUnit unit) {\rassertTrue(unit.name().endsWith(\u0026quot;DAYS\u0026quot;));\r}\r @MethodSource @ParameterizedTest\r@MethodSource(\u0026quot;stringProvider\u0026quot;)\rvoid testWithExplicitLocalMethodSource(String argument) {\rassertNotNull(argument);\r}\rstatic Stream\u0026lt;String\u0026gt; stringProvider() {\rreturn Stream.of(\u0026quot;apple\u0026quot;, \u0026quot;banana\u0026quot;);\r}\r MethodSource如果没有明确指定方法名称，会自动定位跟当前方法名相同的工厂方法（没有参数，并返回Stream\u0026lt;?\u0026gt;）\n@ParameterizedTest\r@MethodSource\rvoid testWithDefaultLocalMethodSource(String argument) {\rassertNotNull(argument);\r}\rstatic Stream\u0026lt;String\u0026gt; testWithDefaultLocalMethodSource() {\rreturn Stream.of(\u0026quot;apple\u0026quot;, \u0026quot;banana\u0026quot;);\r}\r 下面的例子是一个原始类型的例子\n@ParameterizedTest\r@MethodSource(\u0026quot;range\u0026quot;)\rvoid testWithRangeMethodSource(int argument) {\rassertNotEquals(9, argument);\r}\rstatic IntStream range() {\rreturn IntStream.range(0, 20).skip(10);\r}\r 上面都是一个参数的例子，下面的实例展示的是多个参数时的情况：\n@ParameterizedTest\r@MethodSource(\u0026quot;stringIntAndListProvider\u0026quot;)\rvoid testWithMultiArgMethodSource(String str, int num, List\u0026lt;String\u0026gt; list) {\rassertEquals(5, str.length());\rassertTrue(num \u0026gt;=1 \u0026amp;\u0026amp; num \u0026lt;=2);\rassertEquals(2, list.size());\r}\rstatic Stream\u0026lt;Arguments\u0026gt; stringIntAndListProvider() {\rreturn Stream.of(\rarguments(\u0026quot;apple\u0026quot;, 1, Arrays.asList(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;)),\rarguments(\u0026quot;lemon\u0026quot;, 2, Arrays.asList(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;))\r);\r}\r 如果引用的是外部方法，那么就需要该方法的完全限定名\npackage example;\rimport java.util.stream.Stream;\rimport org.junit.jupiter.params.ParameterizedTest;\rimport org.junit.jupiter.params.provider.MethodSource;\rclass ExternalMethodSourceDemo {\r@ParameterizedTest\r@MethodSource(\u0026quot;example.StringsProviders#tinyStrings\u0026quot;)\rvoid testWithExternalMethodSource(String tinyString) {\r// test with tiny string\r}\r}\rclass StringsProviders {\rstatic Stream\u0026lt;String\u0026gt; tinyStrings() {\rreturn Stream.of(\u0026quot;.\u0026quot;, \u0026quot;oo\u0026quot;, \u0026quot;OOO\u0026quot;);\r}\r}\r @CsvSource 多个参数的另一个解决方案：\n@ParameterizedTest\r@CsvSource({\r\u0026quot;apple, 1\u0026quot;,\r\u0026quot;banana, 2\u0026quot;,\r\u0026quot;'lemon, lime', 0xF1\u0026quot;\r})\rvoid testWithCsvSource(String fruit, int rank) {\rassertNotNull(fruit);\rassertNotEquals(0, rank);\r}\r @CsvSource可以自定义空值的别名，下面是一些@CsvSource使用的具体实例\n   Example Input Resulting Argument List     @CsvSource({ \u0026ldquo;apple, banana\u0026rdquo; }) \u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;   @CsvSource({ \u0026ldquo;apple, \u0026lsquo;lemon, lime\u0026rsquo;\u0026rdquo; }) \u0026ldquo;apple\u0026rdquo;, \u0026ldquo;lemon, lime\u0026rdquo;   @CsvSource({ \u0026ldquo;apple, \u0026lsquo;'\u0026rdquo; }) \u0026ldquo;apple\u0026rdquo;, \u0026quot;\u0026rdquo;   @CsvSource({ \u0026ldquo;apple, \u0026quot; }) \u0026ldquo;apple\u0026rdquo;, null   @CsvSource(value = { \u0026ldquo;apple, banana, NIL\u0026rdquo; }, nullValues = \u0026ldquo;NIL\u0026rdquo;) \u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, null    CsvFileSource 根据csv文件内容生成测试参数，注意任何以#开头的行都会被视作为注释\n@ParameterizedTest\r@CsvFileSource(resources = \u0026quot;/two-column.csv\u0026quot;, numLinesToSkip = 1)\rvoid testWithCsvFileSourceFromClasspath(String country, int reference) {\rassertNotNull(country);\rassertNotEquals(0, reference);\r}\r@ParameterizedTest\r@CsvFileSource(files = \u0026quot;src/test/resources/two-column.csv\u0026quot;, numLinesToSkip = 1)\rvoid testWithCsvFileSourceFromFile(String country, int reference) {\rassertNotNull(country);\rassertNotEquals(0, reference);\r}\r two-column.csv\nCountry, reference\rSweden, 1\rPoland, 2\r\u0026quot;United States of America\u0026quot;, 3\r 跟@CsvSource不同，这里的分隔符是双引号，不是之前的单引号。\n这里判空的方式跟@CsvSource类似，并且也有nullValues作为控制别名。\n@ArgumentsSource 可以用来制定一个自定义的看，可重用的ArgumentsProvider注意这个注解只能修饰顶级类，或者静态的集成类。\n@ParameterizedTest\r@ArgumentsSource(MyArgumentsProvider.class)\rvoid testWithArgumentsSource(String argument) {\rassertNotNull(argument);\r}\r public class MyArgumentsProvider implements ArgumentsProvider {\r@Override\rpublic Stream\u0026lt;? extends Arguments\u0026gt; provideArguments(ExtensionContext context) {\rreturn Stream.of(\u0026quot;apple\u0026quot;, \u0026quot;banana\u0026quot;).map(Arguments::of);\r}\r}\r ","id":56,"section":"posts","summary":"@BeforeAll @BeforeEach @AfterAll @AfterEach @DisplayName 自定义的展示名称 @IndicativeSentencesGeneration(separator = \u0026quot; -\u0026gt; \u0026ldquo;, generator = DisplayNameGenerator.ReplaceUnderscores.class) 更改生成测试名称规则，根据类名和方法名生成，并可以指定替换策略，比如上面的替换下划线为空格 @Disabled 屏蔽整","tags":["junit5"],"title":"Junit5常用注解","uri":"https://www.mingaccount.com/2018/11/junit5-common-annotation/","year":"2018"},{"content":"参照官方文档，有详细说明和使用实例\nMaven plugins\n","id":57,"section":"posts","summary":"参照官方文档，有详细说明和使用实例 Maven plugins","tags":["maven"],"title":"Maven Plugins","uri":"https://www.mingaccount.com/2018/11/maven-plugin/","year":"2018"},{"content":"背景 使用AutoConfigure*或者SpringBootTest进行测试的时候，如果不手动设置@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)，那么SpringBoot会默认在classpath下寻找集成数据库。\n集成数据库可以直接通过初始化脚本，在没有数据库环境的情况下，就能进行功能测试。并且你不需要对集成数据库进行任何配置。\nSpring boot 集成h2 想要使用spirngboot集成的h2，只需要引入依赖：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r 在properties文件中，不需要任何配置（当然也可以手动指定）Springboot就能直接使用h2。\n如果想自己配置h2，以替换Spring-boot集成的，可以进行如下配置：\nspring:\rdatasource:\rurl: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false;DATABASE_TO_LOWER=TRUE;CASE_INSENSITIVE_IDENTIFIERS=TRUE;MODE=MYSQL\rtest:\rdatabase:\rreplace: NONE\r 注意，因为有test.database.replace=NONE的存在，不需要在测试类上再申明@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n实例 下面是一个测试类的父类(基于Junit5)，是在所有测试之前初始化表结果和测试数据\n@AutoConfigureTestDatabase\r@TestInstance(TestInstance.Lifecycle.PER_CLASS)\rpublic class SuperTestConfiguration {\r@Autowired\rprivate DataSource dataSource;\r@BeforeAll\rvoid beforeAll() {\rResourceDatabasePopulator populator = new ResourceDatabasePopulator();\rpopulator.addScripts(\rnew ClassPathResource(\u0026quot;/sql/h2/init/init.sql\u0026quot;),\rnew ClassPathResource(\u0026quot;/sql/h2/test/test.sql\u0026quot;));\rpopulator.setSeparator(\u0026quot;;\u0026quot;);\rpopulator.execute(dataSource);\r}\r}\r ","id":58,"section":"posts","summary":"背景 使用AutoConfigure*或者SpringBootTest进行测试的时候，如果不手动设置@AutoConfigureTestDat","tags":["spring","h2"],"title":"Spring boot h2集成数据库进行测试","uri":"https://www.mingaccount.com/2018/10/spring-boot-h2-test/","year":"2018"},{"content":"问题背景 DROP VIEW temp_view;\r 报错信息：\nCan't drop temp_view,because *** depend on it\r 解决方案 DROP VIEW temp_view CASCADE ;\r 该sql会删除所有依赖的视图\n","id":59,"section":"posts","summary":"问题背景 DROP VIEW temp_view; 报错信息： Can't drop temp_view,because *** depend on it 解决方案 DROP VIEW temp_view CASCADE ; 该sql会删除所有依赖的视图","tags":["h2","postgresql"],"title":"删除视图失败，提示有其他视图依赖于该视图","uri":"https://www.mingaccount.com/2018/10/h2-drop-exception/","year":"2018"},{"content":"问题背景 错误日志：\norg.apache.thrift.TApplicationException: [?] : out of sequence response\r 问题原因 hive连接在连接池中，同时两个线程去获取并执行，两个都有close操作。 参考hive jira\n","id":60,"section":"posts","summary":"问题背景 错误日志： org.apache.thrift.TApplicationException: [?] : out of sequence response 问题原因 hive连接在连接池中，同时两个线程去获取并执行，两个都有close操作。 参考hive jira","tags":["hive"],"title":"hive 执行sql时报错out of sequence","uri":"https://www.mingaccount.com/2018/09/hive-out-of-sequence/","year":"2018"},{"content":"@Configuration\r@MapperScan(basePackages = MysqlDatasourceConfig.PACKAGE, sqlSessionFactoryRef = \u0026quot;mysqlSessionFactory\u0026quot;)\rpublic class MysqlDatasourceConfig {\rpublic static final String PACKAGE = \u0026quot;com.ming.mapper.mysql1\u0026quot;;\rpublic static final String MAPPER_LOCATION = \u0026quot;classpath:mapper/mysql1/*.xml\u0026quot;;\r@Primary\r@Bean(name = \u0026quot;mysqlDatasource\u0026quot;)\r@ConfigurationProperties(\u0026quot;spring.datasource.druid.mysql1\u0026quot;)\rpublic DataSource mysqlDataSource(){\rreturn DruidDataSourceBuilder.create().build();\r}\r@Bean(name = \u0026quot;mysqlTransactionManager\u0026quot;)\r@Primary\rpublic DataSourceTransactionManager mysqlTransactionManager() {\rreturn new DataSourceTransactionManager(mysqlDataSource());\r}\r@Bean(name = \u0026quot;mysqlSessionFactory\u0026quot;)\r@Primary\rpublic SqlSessionFactory mysqlSessionFactory(@Qualifier(\u0026quot;mysqlDatasource\u0026quot;) DataSource dataSource) throws Exception {\rfinal SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();\rsessionFactory.setDataSource(dataSource);\rsessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MysqlDatasourceConfig.MAPPER_LOCATION));\rreturn sessionFactory.getObject();\r}\r}\r 配置文件中有多少个数据源就新建多少个上面的配置类 配置类中设置了当前数据源对应的mapper路径和xml路径 在service中使用时，只需要调用对应的mapper即可 ","id":61,"section":"posts","summary":"@Configuration @MapperScan(basePackages = MysqlDatasourceConfig.PACKAGE, sqlSessionFactoryRef = \u0026quot;mysqlSessionFactory\u0026quot;) public class MysqlDatasourceConfig { public static final String PACKAGE = \u0026quot;com.ming.mapper.mysql1\u0026quot;; public static final String MAPPER_LOCATION = \u0026quot;classpath:mapper/mysql1/*.xml\u0026quot;; @Primary @Bean(name = \u0026quot;mysqlDatasource\u0026quot;) @ConfigurationProperties(\u0026quot;spring.datasource.druid.mysql1\u0026quot;) public DataSource mysqlDataSource(){ return DruidDataSourceBuilder.create().build(); } @Bean(name = \u0026quot;mysqlTransactionManager\u0026quot;) @Primary public DataSourceTransactionManager mysqlTransactionManager() { return new DataSourceTransactionManager(mysqlDataSource()); } @Bean(name = \u0026quot;mysqlSessionFactory\u0026quot;) @Primary public SqlSessionFactory mysqlSessionFactory(@Qualifier(\u0026quot;mysqlDatasource\u0026quot;) DataSource dataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MysqlDatasourceConfig.MAPPER_LOCATION)); return","tags":["spring"],"title":"SpringBoot Mybatis配置多数据源","uri":"https://www.mingaccount.com/2018/09/spring-boot-mybatis-multi-source/","year":"2018"},{"content":"ehcache.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;ehcache xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:noNamespaceSchemaLocation=\u0026quot;http://ehcache.org/ehcache.xsd\u0026quot;\u0026gt;\r\u0026lt;defaultCache\rmaxElementsInMemory=\u0026quot;10000\u0026quot;\reternal=\u0026quot;false\u0026quot;\rtimeToIdleSeconds=\u0026quot;3600\u0026quot;\rtimeToLiveSeconds=\u0026quot;0\u0026quot;\roverflowToDisk=\u0026quot;false\u0026quot;\rdiskPersistent=\u0026quot;false\u0026quot;\rdiskExpiryThreadIntervalSeconds=\u0026quot;120\u0026quot; /\u0026gt;\r\u0026lt;cache name=\u0026quot;myCache\u0026quot;\rmaxEntriesLocalHeap=\u0026quot;2000\u0026quot;\reternal=\u0026quot;false\u0026quot;\rtimeToIdleSeconds=\u0026quot;3600\u0026quot;\rtimeToLiveSeconds=\u0026quot;0\u0026quot;\roverflowToDisk=\u0026quot;false\u0026quot;\rstatistics=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;/ehcache\u0026gt;\r 属性简介：\n name：缓存名称。 maxElementsInMemory：缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal：对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk：是否保存到磁盘。 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据，默认值为false。 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy：Ehcache的三种清空策略：FIFO，first in first out，这个是大家最熟的，先进先出。LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。  application.yml spring:\rcache:\rehcache:\rconfig: 'classpath:ehcache.xml'\r 可以强制指定缓存类型\nspring:\rcache:\rtype: ehcache\r ","id":62,"section":"posts","summary":"ehcache.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:noNamespaceSchemaLocation=\u0026quot;http://ehcache.org/ehcache.xsd\u0026quot;\u0026gt; \u0026lt;defaultCache maxElementsInMemory=\u0026quot;10000\u0026quot; eternal=\u0026quot;false\u0026quot; timeToIdleSeconds=\u0026quot;3600\u0026quot; timeToLiveSeconds=\u0026quot;0\u0026quot; overflowToDisk=\u0026quot;false\u0026quot; diskPersistent=\u0026quot;false\u0026quot; diskExpiryThreadIntervalSeconds=\u0026quot;120\u0026quot; /\u0026gt; \u0026lt;cache name=\u0026quot;myCache\u0026quot; maxEntriesLocalHeap=\u0026quot;2000\u0026quot; eternal=\u0026quot;false\u0026quot; timeToIdleSeconds=\u0026quot;3600\u0026quot; timeToLiveSeconds=\u0026quot;0\u0026quot; overflowToDisk=\u0026quot;false\u0026quot; statistics=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/ehcache\u0026gt; 属性简介： name：缓存名称。 maxElementsInMemory：缓存最大数目 maxE","tags":["ehcache","spring"],"title":"SpringBoot Ehcache集成","uri":"https://www.mingaccount.com/2018/09/spring-boot-ehcache/","year":"2018"},{"content":"application.yml spring:\rredis:\rdatabase: 0\rhost: localhost\rprot: 6379\rpool:\rmax-active: 8\rmax-wait: -1\rmax-idle: 8\rmin-idle: 0\rtimeout: 0\r 更多配置参考Spring官网配置参数\nRedisConfig @Configuration\r@EnableCaching\rpublic class RedisConfig extends CachingConfigurerSupport {\r@Bean\r@Override\rpublic CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {\rreturn RedisCacheManager.create(redisConnectionFactory);\r}\r}\r ","id":63,"section":"posts","summary":"application.yml spring: redis: database: 0 host: localhost prot: 6379 pool: max-active: 8 max-wait: -1 max-idle: 8 min-idle: 0 timeout: 0 更多配置参考Spring官网配置参数 RedisConfig @Configuration @EnableCaching public class RedisConfig extends CachingConfigurerSupport { @Bean @Override public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { return RedisCacheManager.create(redisConnectionFactory); } }","tags":["redis","spring"],"title":"SpringBoot Redis集成","uri":"https://www.mingaccount.com/2018/09/spring-boot-redis/","year":"2018"},{"content":"1.了解缓存概念  缓存和缓冲(Cache vs Buffer)\r缓存和缓冲一般来说都是交替使用的，需要知道的是他们是两个完全不同的东西。\rbuffer(缓冲)是用在快慢介质中间作临时数据存储用，介质一方将会等待另一方的操作，这会造成性能损耗，为了缓解，buffer用整块数据的移动代替小块数据多次移动。\r这样buffer数据读写只有一次，并且buffer对介质双方来说至少有一方是可见的。\rcache(缓存)根据定义他是隐藏的，双方都不知道缓存发生了。他提高性能体现在一个数据被多次读取的情况\r Spring缓存针对是java的方法，根据缓存里的信息减少执行的次数。每一次目标方法执行前都会判断该方法是否已经被调用过，并且参数一致。如果已经被调用，那么目标方法不会被执行，直接从缓存中获取结果。\n 这种方式对方法有要求，需要确保方法一组参数只返回唯一个结果，不论调用多少次该方法\n Spring只提供了缓存的逻辑，意味着你需要提供一个缓存的实现，来完成实际的数据储存。对应的实现接口是org.springframework.cache.Cache和org.springframework.cache.CacheManager\n当然Spring提供了现成的缓存实现：\n JDKjava.util.concurrent.ConcurrentMap为基础的缓存 Ehcache 2.x Gemfire cache Caffeine 符合JSR-107的缓存(Ehcache 3.x)   缓存的抽象并没有特别的处理多线程和多进程的环境，是由缓存的实现去处理\n 如果你处在多进程环境，你需要正确的配置你的缓存实现。多个节点相同数据的备份应该是足够的，但还是要依赖于你的具体情况。\n但是，如果你在应用的处理过程中改变了数据，那你另外需要一个的传播机制。\n缓存的过程就是一个查找是否存在，然后执行目标方法，最后保存结果的过程。这个过程是没有锁的，如果多线程的情况下并发保存或者删除数据，数据可能会被污染。\n某些缓存提供者对这种情况有专门处理，详细参考缓存提供者的文档\n要使用Spring的缓存集成，你需要注意这两个方面：\n 缓存声明：确定需要缓存的方法和其策略 缓存配置：后台缓存数据是怎么存储和怎么读取的  2.声明式的基于注解的缓存 Spring对于缓存声明提供了一系列的java注解：\n @Cacheable:触发缓存填充 @CacheEvict:触发缓存释放 @CachePut:在不干扰方法执行的前提下更新缓存 @Caching:重新分组多个缓存操作并应用到一个方法上 @CacheConfig:在类上配置一些公用的缓存配置  2.1 @Cacheable注解 这个注解的是用来指定方法是可以缓存的\n默认参数name是缓存的名称用来和注解的方法关联：\n@Cacheable(\u0026quot;books\u0026quot;)\rpublic Book findBook(ISBN isbn) {...}\r 在上面的例子中，findBook方法是与缓存名称books相关联的。每次方法调用都会检测这个方法是否已经运行过并且不需要重复调用。\n虽然大多数情况下缓存只声明一个，但是注解是允许多个名称的，意味着对应的缓存也有多个。这种情况下，在方法调用前检查每个缓存，如果至少有一个缓存命中，那他关联的缓存都会被返回。\n@Cacheable({\u0026quot;books\u0026quot;, \u0026quot;isbns\u0026quot;})\rpublic Book findBook(ISBN isbn) {...}\r 2.1.1 默认主键生成 因为缓存本质上是一个key-value结果的储存，因此每次调用一个缓存方法，都需要将它转为一个合适的key用于缓存访问。\nSpring用的KeyGenerator基于一下算法：\n 如果没有给定参数，返回SimpleKey.EMPTY 如果只有一个参数，那么直接返回那个实例 如果超过一个参数，那么返回SimpleKey，它包含了所有的参数  这种方法在大多数使用场景都能胜任，只要参数有natural key并且实现了hashCode()和equals()方法。如果没有，那么你需要改变策略。\n提供不同的默认主键生成器，你需要实现org.springframework.cache.interceptor.KeyGenerator接口\n Spring 4.0.Earlier版本改变了默认的主键生成策略，如果有多个参数，只考虑了hashCode()没有考虑equals()。这可能造成主键冲突(参考SPR-10237)\n新的SimpleKeyGenerator使用了复合的主键来应对这种场景\n如果你仍然想使用之前的主键策略，你可以配置org.springframework.cache.interceptor.DefaultKeyGenerator类，或者创建一个自定义基于hash的KeyGenerator实现\n 2.1.2 自定义主键生成策略 实际情况中，方法的多个参数并不是每一个都需要用于主键生成，像下面的例子:\n@Cacheable(\u0026quot;books\u0026quot;)\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r isbn明显是生成主键的关键属性，而另外两个boolean值应该是可有可无\n在这种情况下可以使用@Cacheable的属性key值来指定哪些用来生成主键。你可以使用SpEL来选择参数（或者是他们的嵌套属性），运行操作，或者是调用任意的方法不用写任何的代码或者实现任何的接口。\n随着代码量的增多，之前的默认主键生成方法可能适合一部分方法，但是很难适应所有方法\n下面的例子使用不同的SpEL表达式声明：\n@Cacheable(cacheNames=\u0026quot;books\u0026quot;, key=\u0026quot;#isbn\u0026quot;)\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r@Cacheable(cacheNames=\u0026quot;books\u0026quot;, key=\u0026quot;#isbn.rawNumber\u0026quot;)\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r@Cacheable(cacheNames=\u0026quot;books\u0026quot;, key=\u0026quot;T(someType).hash(#isbn)\u0026quot;)\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r 上面的例子展示了选择某个参数，或者某个参数的属性，以及任意一个随机的静态方法\n如果负责生成主键的方法十分特殊或者他需要共享，你可以定义一个自定义的keyGenerator。需要@Cacheable的属性keyGenerator，他需要一个bean name作为参数：\n@Cacheable(cacheNames=\u0026quot;books\u0026quot;, keyGenerator=\u0026quot;myKeyGenerator\u0026quot;)\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r  key和keyGenerator只能声明一个，同时声明会跑错\n 2.1.3 默认缓存解析 缓存抽象类使用了一个简单的CacheResolver，它使用CacheManager检索操作层面的缓存定义\n如果要提供其他的缓存解析器，你需要实现org.springframework.cache.interceptor.CacheResolver接口\n2.1.4 自定义缓存解析 默认的缓存解析适用于应用只有单个CacheManager并且没有复杂的缓存解析需求\n如果应用有多个缓存manager，你可以在每个操作上设置cacheManager：\n@Cacheable(cacheNames=\u0026quot;books\u0026quot;, cacheManager=\u0026quot;anotherCacheManager\u0026quot;) public Book findBook(ISBN isbn) {...}\r 你也可以类似的替换CacheResolver：\n@Cacheable(cacheResolver=\u0026quot;runtimeCacheResolver\u0026quot;) public Book findBook(ISBN isbn) {...}\r  从Spring 4.1开始，不再维护value属性，因为这个信息可以由CacheResolver来提供，注释的内容如何不再生效\n跟key和keyGenerator类似，cacheManager和cacheResolver也是相互排斥的。\n原因是自定义的CacheManager是被CacheResolver的实现所忽略的\n 2.1.5 同步的缓存 在多线程的环境，某一个操作可能被同样的参数并发调用。默认情况，缓存抽象类没有任何锁，可能造成同样的值被计算很多次，这违背了缓存的初衷\n在这种场景下，你可以使用sync属性去命令缓存提供者在值计算完毕后对缓存键值上锁。目的是只有一个线程在计算结果，其他的需要阻塞直到键值已经更新完毕\n@Cacheable(cacheNames=\u0026quot;foos\u0026quot;, sync=true) public Foo executeExpensiveOperation(String id) {...}\r  这是一个可选的特性，有可能你使用的缓存提供方不支持它。目前核心框架实现的所有CacheManager都支持他。更多信息需要参考提供方的文档。\n 2.1.6 有条件的缓存 有时候，方法并不是任何时候都需要缓存(比如在某个特定的参数值才缓存)。condition参数可以解决这个问题，他需要一个SpEL表达式，这个表达式的结果是true或者false，代表开启缓存\n下面这个例子代表只有方法参数name长度小于32时才启用缓存\n@Cacheable(cacheNames=\u0026quot;book\u0026quot;, condition=\u0026quot;#name.length() \u0026lt; 32\u0026quot;) public Book findBook(String name)\r 除了condition，你还可以指定unless参数去阻止缓存。不像condition，unless表达式是在方法被调用后才计算。\n现在扩展之前的例子，也许我们想缓存简装版的书籍，而不是精装版：\n@Cacheable(cacheNames=\u0026quot;book\u0026quot;, condition=\u0026quot;#name.length() \u0026lt; 32\u0026quot;, unless=\u0026quot;#result.hardback\u0026quot;)\rpublic Book findBook(String name)\r 缓存抽象类是支持java.util.Optional的，仅当其值存在时才将他的内容作为缓存。#result始终是指业务实体，不会是他的封装。所以之前的例子还可以进一步重写：\n@Cacheable(cacheNames=\u0026quot;book\u0026quot;, condition=\u0026quot;#name.length() \u0026lt; 32\u0026quot;, unless=\u0026quot;#result?.hardback\u0026quot;)\rpublic Optional\u0026lt;Book\u0026gt; findBook(String name)\r 注意result仍然指Book而不是Optional。因为他可能为null，应该使用safe navigation操作符\n2.1.7 缓存SpEL中可用的上下文参数 每个SpEL表达式都根据一个专门的context对象来计算。这个context包含一些默认的参数，可以用来计算主键或者运行条件，参照下表：\n   名称 位置 描述 例子     methodName Root object 被调用的方法名称 #root.methodName   method Root object 被调用的方法 #root.method.name   target Root obejct 被调用的目标对象 #root.target   targetClass Root object 被调用的目标类 #root.targetClass   args Root object 被调用方法的参数（数组） #root.args[0]   caches Root object 当前运行方法的缓存集合 #root.cache[0].name   参数名 Evaluation context 任何方法的参数名称。如果名称不可用(也许是因为没有debug信息)，可以使用#a\u0026lt;#arg\u0026gt;，其中#arg代表参数的下标(从0开始) #iban或者#a0（你也可以用#p0或者#p\u0026lt;#arg\u0026gt;作为别名）   result Evaluation context 方法调用的结果（拿来缓存的值）。只在unless表达式，cache put表达式（用于计算主键的），或者cache evict表达式（beforeInvacation的值是false）时可用。为了支持包装类（比如Optional)，#result指代的实体对象，不是包装对象 #result    2.2 CachePut注解 当缓存需要更新并且不希望干扰方法的执行时，你可以使用CachePut注解。也就是该方法任何时候都会被调用，并且它的结果将会放到缓存中（具体参照注解参数配置）。它也支持@Cacheable注解支持的参数，它应该应用于缓存填充而不是方法流优化。下面是一个使用例子：\n@CachePut(cacheNames=\u0026quot;book\u0026quot;, key=\u0026quot;#isbn\u0026quot;)\rpublic Book updateBook(ISBN isbn, BookDescriptor descriptor)\r  强烈不推荐在同一个方法上使用CachePut和Cacheable。Cacheable会在检查到方法有缓存的时候跳过执行，CachePut为了更新缓存强制执行调用。同时声明会导致意想不到的操作（除非极端情况，比如两个注解的参数互相排除了对方），所以尽量避免这么声明\n 2.3 CacheEvict注解 除了缓存填充，Spring也提供了缓存释放注解@CacheEvict。跟@Cacheable注解类似，@CacheEvict也需要指定影响的缓存（一个或者多个），允许自定义缓存和主键的解决方案，同样也可以指定生效条件。除了这些跟Cacheable一样的特性，CacheEvict还有一个额外的参数allEntries，它代表是否执行整个缓存范围的释放，而不是仅仅一个键值对（基于主键）\n@CacheEvict(cacheNames=\u0026quot;books\u0026quot;, allEntries=true) public void loadBooks(InputStream batch)\r 这个选项在需要清空整个缓存区域时非常有用，如果单独的清除每个键值对，那将耗费大量时间。在上面的例子中，一个操作就可以清空所有的键值对。注意在这个场景你指定的主键没有任何作用。\n你也可以指定释放操作在方法调用后（默认）或者调用前执行。默认情况下都是调用后执行，可以通过属性beforeInvcation来指定调用前执行，这样方法是否运行完都不会影响到释放操作\n注意@CacheEvict可以在void方法上使用，方法相当于一个触发器，返回结果将会被忽略。\n2.4 @Caching注解 有些时候，相同类型的多个注解（比如@CacheEvict或者@CachePut）需要指定在一个方法上——例如，因为条件不同或者主键表达式不同的两个不同的缓存。@Caching注解可以让多个@Cacheable,@CachePut,和@CacheEvict注解集成用在同一个方法上。下面这个例子用了两个@CacheEvict注解：\n@Caching(evict = {@CacheEvict(\u0026quot;primary\u0026quot;),@CacheEvict(cacheNames=\u0026quot;secondary\u0026quot;,key=\u0026quot;#p0\u0026quot;)})\rpublic Book importBooks(String deposit, Date date)\r 2.5 @CacheConfig注解 当目前为止，我们讨论的缓存操作提供了很多的自定义选项。但是有些选项是通用的，如果方法里的所有操作都需要配置这个选项，并且还是相同的值，那么就太麻烦了。所以Spring提供了@CacheConfig注解，这是一个类级别的注解，可以用它来指定一些共用的选项信息。 下面的例子用@CacheConfig指定了该类所有缓存操作的缓存名称\n@CacheConfig(\u0026quot;books\u0026quot;) public class BookRepositoryImpl implements BookRepository {\r@Cacheable\rpublic Book findBook(ISBN isbn) {...}\r}\r @CacheConfig是一个类级别的注解可以分享的选项有：缓存名称、自定义KeyGenerator、自定义CacheManager、以及自定义CacheResolver。把这个注解放在类上只是共享配置，并不会打开任何缓存操作。\n一个操作级别的自定义参数始终可以覆盖在@CacheConfig上的配置。缓存自定义选项有三个级别：\n 全局配置，对CacheManager,KeyGenerator生效。 类级别，用CacheConfig。 操作级别配置  2.6 让缓存注解生效 想许多Spring特性一样，缓存注解不是自动触发的，他们需要一个有效声明（当你发觉问题有可能是缓存带来的，你可以只移除一行配置行，而不是你代码里面的所有注解）\n让缓存注解生效很简单，只需要在任意一个@Configuration类上加注解@EnableCaching\n@Configuration\r@EnableCaching\rpublic class AppConfig {\r}\r 或者，通过xml配置，你可以使用cache:annotation-driven\n\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxmlns:cache=\u0026quot;http://www.springframework.org/schema/cache\u0026quot;\rxsi:schemaLocation=\u0026quot;\rhttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\rhttp://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd\u0026quot;\u0026gt;\r\u0026lt;cache:annotation-driven/\u0026gt;\r\u0026lt;/beans\u0026gt;\r 上面两种方式都有大量配置项可以调整，他们通过aop实际的影响缓存行为。这些配置项跟@Transactional 相似\n 默认处理缓存注解的方式是通过代理实现的，他只会拦截通过代理的调用。因此在同一个类的本地调用，是无法被拦截到的（具体参照Spring AOP).如果需要其他的拦截模式，考虑切换到aspectj模式结合编译时或者加载时的weaving。\n  更多自定义配置可以实现CachingConfigurer，参考javadoc\n 自定义缓存配置项：\n   xml属性 注解属性 默认值 描述     cache-manager 参照CachingConfigurer 文档 cacheManager 指代缓存管理器使用的名称。默认的缓存管理器或者没有设置cahcheMnager，在他的后台会初始化一个默认的CacheResolver。如果你需要对缓存解析更细粒度的管理，考虑设置cache-resolver属性   cache-resolver 参照CachingConfigurer 文档 SimpleCacheResolver，缓存管理使用的默认cacheManger 缓存解析器的bean name，缓存解析器是缓存的底层实现。这个属性不是必须的，仅当需要替代cache-manager属性时才指定   key-generator 参照CachingConfigurer 文档 SimpleKeyGenerator 自定义主键生成器的名称   error-handler 参照CachingConfigurer 文档 SimpleCacheErrorHandler 自定义缓存错误处理器的名称。默认情况下，缓存相关操作抛出的异常会直接抛给调用方   mode mode proxy 默认proxy模式代表注解会通过Spring AOP框架处理，生成原类的代理类。可选择的替代参数是aspectj   proxy-target-class proxyTargetClass false 只在mode值是proxy时生效。控制为缓存类生成什么类型的缓存代理。如果属性是true，以类为基础的代理将会被创建。如果属性是false或者属性没有手动配置，标准的JDK接口代理会被创建（两者的具体差距可以参考代理机制 )   order order Ordered.LOWEST_PRECEDENCE 当前类里的缓存切面逻辑的执行优先权，具体参考AOP执行顺序     缓存注解的方法可见性 当你使用proxy mode，你应该将你的缓存注解放到public方法上。如果放到诸如protected,private,或者 package可见的方法上，虽然没有异常提示，但是你的注解将不会有任何效果。如果有这样的需求，可以考虑使用AspectJ\n  Spring推荐将缓存注解放到实现类上，而不是接口上。你当然可以吧缓存注解放到接口上或者接口的方法上，但是前提是proxy-target-class的值必须是false。如果proxy-target-class值是true或者mode=\u0026quot;aspectj，缓存配置将没有任何效果\n  在proxy mode(默认情况)，只有外部的方法调用会被拦截并处理。内部的调用，指类内部的方法掉了同类下的另一个方法，这样的调用就算方法有缓存注解也不会有任何效果。这样的情况请考虑使用aspectjmode。另外，必须完全初始化代理才能提供预期的支持，所以不应该在初始化代码中（@PostConstruct）使用缓存注解\n 2.7 使用自定义注解  自定义注解和AspectJ\n这个特性只能在基于代理的方法上使用，非代理方法需要使用AspectJ\nspring-aspects项目模块只定义了标准注解的切面。如果你定义了你自己的注解，你需要为它定义对应的切面类。AnnotationCacheAspect类就是一个例子\n Spring可以让你用自定义注解去申明什么方法触发缓存填充和释放。这是一个简单的模板机制，因为他可以避免缓存注解的重复声明，特别是指定了主键和条件，或者代码库不允许外部导入(org.springframework)时特别有用。跟其余的模板注解相同，你可以使用@Cacheable，@CachePut，@CacheEvict，和@CacheConfig作为元注解（意思就是，能够在其他注解上声明注解）\n下面的例子，我们替换一个公用得问@Cacheable注解为我们的自定义注解:\n@Retention(RetentionPolicy.RUNTIME)\r@Target(ElementType.METHOD)\r@Cacheable(cacheNames=\u0026quot;books\u0026quot;,key=\u0026quot;#isbn\u0026quot;)\rpublic @interface SlowService{\r}\r 上面的例子我们定义了自己的SlowService注解，他被@Cacheable注解修饰，现在我们可以替换掉下面的代码\n@Cacheable(cacheNames=\u0026quot;books\u0026quot;, key=\u0026quot;#isbn\u0026quot;)\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r 那如果用我们申明的自定义注解，可以很方便的写为：\n@SlowService\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r 即使@SlowService不是Spring注解，在运行时容器也能自动获取他的声明。注意，如前所述，需要启用注解驱动。\n3.JCache(JSR-107)注解 从4.1版本开始，Spring缓存全面支持JCache标准注解：@CacheResult,@CachePut,@CacheRemove,和@CacheRemoveAll以及@CacheDefaults,@CacheKey,和@CacheValue配合。你可以使用这些注解即使没有把缓存存储到JSR-107上。内部实现使用了Spring的缓存抽象类，并提供了默认的符合规范的CacheResolver和KeyGenerator实现。换句话说，如果你已经使用了Spring的缓存抽象，你可以切换到这些标准注解并且不需要改变你的缓存存储（或者配置）。\n3.1 特征总结 下面是Spring缓存注解和对应的JSR-107注解的区别：\n   Spring JSR-107 备注     @Cacheable @CacheResult 基本相同，@CacheResult可以缓存指定的异常还能强制执行方法不管缓存的内容   @CachePut @CachePut 当Spring用方法调用的结果更新缓存时，JCache需要将它当做一个参数(@CacheValue注解修饰)传递。因为这个不同，JCache是允许在实际方法执行前或者执行后更新缓存的   @CacheEvict @CacheRemove 基本相同。@CacheRemove支持方法调用异常时条件释放   @CacheEvict(allEntries=true) @CacheRemoveAll 参照@CacheRemove   @CacheConfig @CacheDefaults 提取相同的配置，相似的风格    JCache也有CacheResolver概念：javax.cache.annotation.CacheResolver，跟Spring的CacheResolver接口是完全一样的，除了JCache只支持一种缓存外。默认情况下，一个简单的实现根据注解中声明的名称去检索要使用的缓存。需要注意的是，如果没有缓存名称指定，会自动生成一个默认的。@CacheResult#cacheName()api文档有更详细的信息。\nCacheResolver实例是通过CacheResolverFactory来检索的。可以为每个缓存操作自定义factory：\n@CacheResult(cacheNames=\u0026quot;books\u0026quot;, cacheResolverFactory=MyCacheResolverFactory.class) public Book findBook(ISBN isbn)\r  对于所有引用的类，Spring会根据指定类型尝试去定位一个bean。如果多个匹配项存在，一个新的实例会被创建，并且使用常规bean生命周期回调，就像依赖注入一样。\n 跟Spring的KeyGenerator目的一样，javax.cache.annotation.CacheKeyGenerator被用来生成主键。默认情况，方法的所有参数都被考虑在内，除非至少一个参数被@CacheKey注解修饰。这个Spring的自定义主键生成非常相似。下面的例子就是跟Spring的一个对比：\n@Cacheable(cacheNames=\u0026quot;books\u0026quot;, key=\u0026quot;#isbn\u0026quot;)\rpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r@CacheResult(cacheName=\u0026quot;books\u0026quot;)\rpublic Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)\r 你也可以在这个操作上指定CacheKeyResolver，方法跟指定CacheResolverFactory相同。\nJCache可以管理被注解方法抛出的异常。他可以阻止缓存的更新，也可以缓存异常而不是再去调用一次方法。假定ISBN无效时会抛出InvalidIsbnNotFoundException。下面的例子，每次调用都用一个无效的，并且相同的ISBN，多次调用的情况下会直接抛出异常，而不是再次执行方法：\n@CacheResult(cacheName=\u0026quot;books\u0026quot;, exceptionCacheName=\u0026quot;failures\u0026quot;\rcachedExceptions = InvalidIsbnNotFoundException.class)\rpublic Book findBook(ISBN isbn)\r 3.2 开启JSR-107支持 除了Spring的申明注解支持外，不需要其他的操作来启用JSR-107。如果classpath内部有JSR-107API和spring-context-support模块，那么@EnableCaching和cache:annotation-driven元素会自动启用JCache支持\n 两种注解形式可以随意使用，唯一需要注意的是，如果Spring和JSR-107都影响了相同的缓存，你应该保证主键生成器一致\n ","id":64,"section":"posts","summary":"1.了解缓存概念 缓存和缓冲(Cache vs Buffer) 缓存和缓冲一般来说都是交替使用的，需要知道的是他们是两个完全不同的东西。 buffer(缓冲)是用在","tags":["spring"],"title":"Spring缓存集成","uri":"https://www.mingaccount.com/2018/09/spring-cache/","year":"2018"},{"content":"1.大型网站的特点： 　相比传统企业应用系统，大型互联网应用系统有以下特点：\n 高并发、大流量：需要面对高并发用户，大流量访问。 高可用：系统需要7*24小时不间断服务。 海量数据：需要储存、管理海量数据，需要使用大量服务器。 用户分布广泛，网络情况复杂。 安全环境恶劣：黑客攻击。 需求快速变更，发布频繁。 渐进式发展：大型互联网几乎都是从小网站发展起来的，不像传统行业一开始需求就相对固定。 那么大型网站是如何做到高可用、高性能、易扩展、可伸缩且安全的网站，又是怎样演变的了？  2.大型网站架构的演化发展历程 2.1 初始化阶段的网站架构 应用程序、数据库、和用户上传的文件等所有的资源都是在一台服务器上。\n2.2 应用服务和数据服务分离 随着网站用户的增加，不断增加的访问数量，和大量的文件储存，一台服务器已经不能满足需求，这时就需要分离应用和数据。\n分离后整个网站使用三台服务器：应用服务器、文件服务器、数据库服务器。\n三台服务器对硬件的要求不同：\n 应用服务器需要处理大量业务逻辑，需要更好的cpu； 数据库服务器需要快速检索磁盘和数据缓存，因此需要更快的硬盘和更大的内存； 文件服务器需要储存大量用户上传的文件，因此需要更大的硬盘。  2.3 使用缓存改善网站性能 随着用户进一步增加，数据库压力太大导致访问延迟。而大部分数据的访问，总是集中在某些热点数据上，例如淘宝商品访问，总是集中在评价最高的商品上。\n那么我们可以将这一部分热点数据，缓存到内存中，以减少数据库的访问压力。\n网站可使用的缓存分为两种：\n 本地缓存：缓存在应用服务器上，访问速度快，但受应用服务器的内存限制。 远程缓存：缓存在专门的分布式缓存服务器上，理论上不受内存容量限制。  2.4 使用应用服务器集群改善网站的并发处理能力 使用缓存后，数据库的压力得到有效缓解，但单个应用服务器能处理的请求连接有限，在访问高峰期，应用服务器成为整个网站的瓶颈。\n单一应用服务器性能是有上限的，这种情况下，更好的方式是多个服务器的集群来分担原有服务器的访问及储存压力，从而实现系统的可伸缩性。\n应用服务器集群搭建后，通过负载均衡调度服务器，将请求分发到集中中任何一台机器上。\n2.5 数据库读写分离 网站使用缓存后，绝大部分数据都可以从缓存中获取，但在部分情况下任然需要访问数据库：\n 缓存未命中（请求未能从缓存系统中找到匹配的缓存） 缓存过期 全部写操作 虽然只有部分情况才会访问数据库，但当用户基数不断增大，数据库也会不堪重负。  这种情况下，可以通过读写分离，来减轻数据库的压力。\n目前大部分主流数据库都支持主从热备（双机热备），通过设定两台数据库的主从关系，可以将一台数据库服务器的数据同步更新到另一台服务器上，网站利用数据库的这个功能来实现读写分离。\n在写数据时访问主数据库，同时主数据库同步数据到从数据库，在读取数据时，就可以访问从数据库，同时还需要一个数据访问模块，让读写分离对应用程序透明，减少代码依赖。\n2.6 使用反向代理和CDN加速网站响应 随着网站规模的扩大，用户可能分布在全国各地，不同地方的网络环境不同，要保证响应速度，就需要加速网站的访问速度。\n主要的加速手段：\n CDN 反向代理  这两种方式都基于缓存，不同点在于：\n CDN部署在网络提供商的机房，用户在请求数据时，可以从离自己最近的网络提供商出获取数据。 反向代理部署在网站中心机房，用户在请求数据时，首先访问的时反响代理服务器，如果缓存着用户请求的资源，就直接将缓存返回给用户。  2.7 使用分布式文件系统和分布式数据库系统 数据库经过读写分离，拆分为两台服务器，但是随着网站发展任然不能满足需求，文件服务器也是一样。\n这时就需要分布式的数据库系统和文件系统。\n分布式数据库是网站数据库拆分的最后手段，只有在单表数据非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同的业务的数据库部署在不同的服务器上。\n2.8 使用NoSQL和搜索引擎 随着网站业务越来越复杂，对数据库储存和检索的需求也越来越复杂，网站需要采取一些非关系型数据库技术如NoSQL和非数据库查询技术如搜索引擎。\nNoSQL和搜索引擎，对可伸缩的分布式系统有很好的支持。面对如此多的数据源，应用服务器通过统一的数据访问模块来访问不同的数据源。\n2.9 业务拆分 大型网站面对日益复杂的业务场景，根据产品线划分，可以将一个网站拆成多个应用，每个应用都独立部署维护。\n每个应用之间的数据关联有如下几种方式：\n 通过访问同一个数据储存系统(最常用)。 通过超链接建立关系。 通过消息队列进行数据分发。  2.10 分布式服务 随着业务拆分越来越细，应用系统越来越复杂，并且由于所有应用要和所有数据库连接，在数万台服务器规模的网站中，会导致数据库连接资源不足，拒绝服务。\n应用系统中有许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些相同的业务提取出来独立部署，由这些可复用的业务连接数据库，通过分布式服务调用共用业务服务完成具体操作。\n*本文是《大型网站技术架构 核心原理与案例分析》的章节总结\n","id":65,"section":"posts","summary":"1.大型网站的特点： 相比传统企业应用系统，大型互联网应用系统有以下特点： 高并发、大流量：需要面对高并发用户，大流量访问。 高可用：系统需要7*","tags":["website build"],"title":"大型网站架构演化概论","uri":"https://www.mingaccount.com/2018/09/big-web-bala-bala/","year":"2018"},{"content":"Java8函数式编程的加入彻底改变了游戏规则。对Java开发者来说这是一个全新的世界，我们也需要做出相应的改变。\n在这篇文章中我们将找寻传统循环代码的可替代方案。Java8的函数式编程特性改变了编程思路，从 “我们怎样去做” 变成了 “我们想做什么” 。\n这也是传统循环的缺点。当然传统循环更加的灵活，但其灵活性并不能掩盖他的问题。\nreturn、break、continue能直接改变循环的执行流程，强迫我们不仅要理解业务逻辑，同时也要了解循环是怎样工作的。\nJava8通过引入stream指令，我们可以在集合上使用强大的函数式操作。现在我们来看看怎样将传统循环转变为更简洁，更具有可读性的代码。\n这里将会创建一个Article类，他有三个成员变量：title、author、tags：\nprivate class Article {\rprivate final String title;\rprivate final String author;\rprivate final List\u0026lt;String\u0026gt; tags;\rprivate Article(String title, String author, List\u0026lt;String\u0026gt; tags) {\rthis.title = title;\rthis.author = author;\rthis.tags = tags;\r}\rpublic String getTitle() {\rreturn title;\r}\rpublic String getAuthor() {\rreturn author;\r}\rpublic List\u0026lt;String\u0026gt; getTags() {\rreturn tags;\r}\r}\r 每个例子都会包括一个传统循环的解决方案，和Java8函数式编程的解决方案。\n在第一个例子里面，将会在Article集合中寻找tag包含\u0026quot;Java\u0026quot;的第一个对象：\n传统循环的解决方案：\npublic Article getFirstJavaArticle(){\rfor(Article article : articles){\rif(article.getTags().contains(\u0026quot;Java\u0026quot;)){\rreturn article;\r}\r}\rreturn null;\r}\r Java8的解决方案：\npublic Optional\u0026lt;String\u0026gt; getFirstJavaArticle(){\rreturn articles.stream().filter(article -\u0026gt; article.getTags.contains(\u0026quot;Java\u0026quot;)).findFirst(); }\r 首先我们使用filter操作找到所有符合条件的Article，然后调用findFirst()方法得到第一个。\n因为stream是惰性的而且filter返回了一个stream，因此方法只有在找到第一个匹配时才会去处理这个元素。\n现在让我们尝试获取所有匹配的元素。\n传统循环解决方案：\npublic List\u0026lt;Article\u0026gt; getAllJavaArticles() {\rList\u0026lt;Article\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\rfor (Article article : articles) {\rif (article.getTags().contains(\u0026quot;Java\u0026quot;)) {\rresult.add(article);\r}\r}\rreturn result;\r}\r Java8解决方案：\npublic List\u0026lt;Article\u0026gt; getAllJavaArticles() {\rreturn articles.stream().filter(article -\u0026gt; article.getTags.contains(\u0026quot;Java\u0026quot;)).collect(Collectors.toList());\r}\r 在这个例子中我们使用了 collect 方法去筛选stream，而不是自己声明一个集合，并将匹配的参数追加到集合中。\n到目前为止都不错，现在是时候来展现 stream api真正的魅力了！\n让我们基于author将articles进行分组。\n传统循环解决方案：\npublic Map\u0026lt;String,List\u0026lt;Article\u0026gt;\u0026gt; groupByAuthor(){\rMap\u0026lt;String,List\u0026lt;Article\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;();\rfor(Article article : articles){\rif(result.containsKey(article.getAuthor)){\rresult.get(article.getAuthor).add(article);\r}else{\rArrayList\u0026lt;Article\u0026gt; articles = new ArrayList\u0026lt;\u0026gt;();\rarticles.add(article);\rresult.put(article.getAuthor(), articles);\r}\r} }\r Java8解决方案：\npublic Map\u0026lt;String, List\u0026lt;Article\u0026gt;\u0026gt; groupByAuthor() {\rreturn articles.stream().collect(Collectors.groupingBy(Article::getAuthor));\r}\r 通过使用groupingBy操作和getAuthor的方法引用，我们得到了整洁并且可读性高的代码。\n现在，让我们在集合中找到Article所有的不重复的tags。\n首先时传统循环方案：\npublic Set\u0026lt;String\u0026gt; getDistinctTags(){\rSet\u0026lt;String\u0026gt; result = new HashSet\u0026lt;\u0026gt;();\rfor(Article article : articles){\rresult.addAll(article.getTags());\r}\rreturn result; }\r Java8解决方案：\npublic Set\u0026lt;String\u0026gt; getDistinctTags(){\rreturn articles.stream().flatMap(article -\u0026gt; article.getTags().stream()).collect(Collectors.toSet());\r}\r flatMap帮助我们获取结果流中的tag集合，然后用collect方法创建一个Set并返回结果。\n函数式编程拥有无限的可能，这四个例子的目的是怎样将循环替换成更可读的代码。你应该仔细查看stream API，因为相比api这文章仅仅只是皮毛而已。\n*英文链接：deadCodeRising\n*原创译文\n","id":66,"section":"posts","summary":"Java8函数式编程的加入彻底改变了游戏规则。对Java开发者来说这是一个全新的世界，我们也需要做出相应的改变。 在这篇文章中我们将找寻传统循","tags":["java"],"title":"[译]Java8：循环与函数式编程","uri":"https://www.mingaccount.com/2018/08/java8-for-functional/","year":"2018"},{"content":"Java8引入了 java.util.function 包，他包含了函数式接口，具体的描述在以下api说明文档中：\n函数式接口为lambda表达式和方法引用提供目标类型。每个函数式接口有一个单独的抽象方法，被称为函数式接口的函数方法，lambda表达式的参数和返回类型与之匹配或适应。\r 在这篇文章中，将着重介绍function包40个接口中的4个：\nPredicate 代表有一个参数的断言(boolean值的函数)\r Predicate 接口允许我们创建一个基于给定参数并返回一个boolean值的lambda表达式。让我们创建一个Predicate来测试一个Person是否为成年人。\nPredicate\u0026lt;Integer\u0026gt; isAnAdult = age -\u0026gt; age \u0026gt;= 18;\r 这里对于stream的filter方法的使用，让Predicate接口作为一个参数。所以我们实际上能够在stream中使用我们的Predicate接口。\nPredicate\u0026lt;Person\u0026gt; isAnAdult = person -\u0026gt; person.getAge() \u0026gt;= 18;\rList\u0026lt;Person\u0026gt; people = getAllPeople();\rInteger numOfAdult = people.stream().filter(isAnAdult).count();\r Consumer 代表一个接受单个参数输入而不返回任何结果的操作。不像大多数其他的函数式接口，Customer预期是通过副作用进行操作。\r Consumer\u0026lt;Ticket\u0026gt; ticketPrinter = ticket -\u0026gt; ticket.print();\r Iterable接口带来的全新forEach方法可以将Consumer作为一个参数，让我们用forEach方法将上面创建的ticketPrinter操作组合在一个Collection上：\nConsumer\u0026lt;Ticket\u0026gt; ticketPrinter = ticket -\u0026gt; ticket.print();\rCollection\u0026lt;Ticket\u0026gt; tickets = getTicketsToPrint();\rtickets.forEach(ticketPrinter);\r 现在，让我们简化一下代码，通过把Consumer直接放进forEach方法中：\nCollection\u0026lt;Ticket\u0026gt; tickets = getTicketsToPrint();\rtickets.forEach(ticket -\u0026gt; ticket.print());\r Supplier 表示结果供应\r 这是工厂的一种，他没有参数，只是返回给你一个结果。非常适合返回一个实例。\nSupplier\u0026lt;TicketHandler\u0026gt; ticketHandlerCreator = () -\u0026gt; new TicketHandler();\r 另一种方案是使用构造方法引用。\nSupplier\u0026lt;TicketHandler\u0026gt; ticketCreator = TicketHandler::new;\r Function\u0026lt;T,R\u0026gt; 表示一个方法接收一个参数然后产出一个结果\r 让我们直接看一个例子：\nFunction\u0026lt;String,Predicate\u0026lt;Ticket\u0026gt;\u0026gt; ticketFor = event -\u0026gt; ticket -\u0026gt; event.equals(ticket.getName());\rList\u0026lt;Ticket\u0026gt; tickets = getAllTickets();\rInteger soldTicketsForCoolEvent = tickets.stream().filter(ticketFor.apply(\u0026quot;CoolEvent\u0026quot;)).count();\r 我们创建了一个以event字符串作为参数的Function，他会返回一个Predicate。参数会被传给Predicate，并与event字符串作比较。然后我们在stream中使用function去计算ticket name为\u0026quot;CoolEvent\u0026quot;的数量\n*英文链接：deadCodeRising\n*原创译文\n","id":67,"section":"posts","summary":"Java8引入了 java.util.function 包，他包含了函数式接口，具体的描述在以下api说明文档中： 函数式接口为lambda表达式和方法引用提供目标类型。每个函数式","tags":["java"],"title":"[译]Java8的函数式接口","uri":"https://www.mingaccount.com/2018/08/java8-lamda-interface/","year":"2018"},{"content":"在开发代码中，有一段需要获取resources目录下的一个配置文件（这里写作test.xml）。\n这段代码在ide中没有任何问题，但是一打成jar包发布到线上，这段代码就会报找不到对应文件的错误。\n按照一般的思路，因为resources目录下的文件经过编译后都会放在classpath根目录下，所以获取到根目录然后追加test.xml即可得到该文件路径。这是尝试获取路径失败的代码：\n//直接获取目标文件路径\rString filePath = this.getClass.getClassLoader().getResource(\u0026quot;text.xml\u0026quot;).getPath;\r//获取根目录路径1\rString rootPath = this.getClass.getClassLoader().getResource(\u0026quot;\u0026quot;).getPath;\r//获取根目录路径2\rString rootPath2 = ResourceUtils.getURL(\u0026quot;classpath:\u0026quot;).getPath();\r 通过以上代码获取到的路径在spring boot项目作为jar包运行时，得到的并不是真实的路径，而是如下的一个路径：\nworkspace/project/target/project.jar!/BOOT-INF/classes!/...\r spring提供了ClassPathResource类处理这种情况，通过ClassPathResource可以直接获取File对象，或者InputStream，这是获取成功的代码：\nResource resource = new ClassPathResource(\u0026quot;text.xml\u0026quot;);\rresource.getFile();\rresource.getInputStream();\r ","id":68,"section":"posts","summary":"在开发代码中，有一段需要获取resources目录下的一个配置文件（这里写作test.xml）。 这段代码在ide中没有任何问题，但是一打成j","tags":["spring"],"title":"Spring boot 文件路径读取异常","uri":"https://www.mingaccount.com/2018/08/spring-boot-get-file-path/","year":"2018"},{"content":"cd - #查看上一次所在的目录\rcat /etc/hosts #文档查看\rls #查看当前目录下所有文件\rpwd #查看当前目录的绝对路径\rll #查看目录下文件的详细信息，包括权限属组等信息\rfind / -name web.xml #查看名字为web.xml的文件，需要等待片刻\rfind .|xargs grep -rl \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名\rfind .|xargs grep -r \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名，并展示命中行\rfind .|xargs grep -rn \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名，并展示行号\rfind .|xargs grep -rn1 \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名，并展示上下文内容\rmkdir -p #创建文件夹\rcat [目录1] \u0026gt;\u0026gt; [目录2] #把目录1的文件内容输入到目录2中 chmod a+x filename #让执行文件能被./filename调用\rmv #文件移动或者重命名\rvi /etc/hosts #HOST修改需重启\rvi /etc/resolv.conf #DNS修改即时生效\rvi /etc/sysconfig/network-scripts/ifcfg-eth0 #IP修改需重启\rcat /etc/os-release #查看当前系统版本信息\runset #删除对应的环境变量\rnslookup [ip/域名] #通过域名查找ip和dns，或者通过ip查找域名\rwget 域名 #通过指定域名下载文件到当前目录\rscp -r ~/data root@127.0.0.1:~/data #指定服务上传 scp -r root@127.0.0.1:~/data ~/data #指定服务下载\rctrl+z #进程暂停\rctrl+c #进程终止\rfg [JobID] #将后台进程移到前台处理，不设置id，将显示最后一个暂停的进程\rbg [JobID] #将进程放到后台处理\rjobs [选项] [JobID] #该命令生效之前需执行find / -name password \u0026amp;\r#-l显示进程\r#-p仅显示任务对应的进程号\r#-r仅输出运行状态的任务 #-s仅输出停止状态的任务\rps -ef #查询所有正在运行的service\rps -ef | grep mysql #查询mysql相关的进程\rservice --status-all #查询所有已安装的service\rreboot\r#-d重新开机时不把数据写入记录文件/var/tmp/wtmp。具有-n效果\r#-f强制重新开机，不调用shutdow指令\r#-i重新开机之前，关闭所有网络界面\r#-n重新开机之前不检查是否有程序未结束\r#-w仅做测试，不真正重启，只会在/var/log/wtmp写入记录\rsu - [用户名] #完全切换到指定用户，需要指定用户的密码\rsudo -i #暂时切换到root账户，logout命令可退出root，需要sudoers权限\rsudo passwd root #设置root密码　sudo useradd -m hadoop -s /bin/bash #添加用户\rsudo adduser hadoop sudo #给用户追加管理员权限\rtop #表示1分钟，5分钟，15分钟的运行队列平均进程数\rwhile true;do ps -u your-user-name -L | wc -l;sleep 1;done #查看当前用户开启的线程数\rulimit -u #查看当前用户所能开启的线程数\recho $JAVA_HOME #查询环境变量\rwhich java #获取java执行路径\rls -lrt /usr/bin/java #查找安装路径\rsudo tar -zxf 压缩包目录 -C 目标解压目录 #文件解压\rsudo chown -R [userName] [filePath] #更改文件及其所有子文件的所有者权限\runzip #解压zip文件\rvi /etc/apt/sources.list #编辑环境变量\rdpkg -i *.deb #ubuntu体系安装软件包命令\rapt-get upgrade [软件名] #ubuntu更新软件\rjps #查看当前所有的java进程，并显示进程id\rssh-keygen #生成SSH key\r ","id":69,"section":"posts","summary":"cd - #查看上一次所在的目录 cat /etc/hosts #文档查看 ls #查看当前目录下所有文件 pwd #查看当前目录的绝对路径 ll #查看目录下文件的详细信息，包括权限属组等信息","tags":["linux"],"title":"Linux常用命令备忘","uri":"https://www.mingaccount.com/2018/08/linux-common-command/","year":"2018"},{"content":"vi /etc/hosts\ni 修改模式\resc　退出修改\r:q　正常退出(文件没有修改\r:q!　不保存退出\r:wq 保存退出\rG　跳到末尾行\rdd　删除当前行\rgg　跳到第一行第一个字符\r$　跳到当前行的最后一个字符\ro　在当前行之后插入一个新行\r/搜索内容　搜索指定内容\r:122　跳转到指定行\r:%d 删除所有内容\rdG 删除当前光标以下的所有内容\r:set ff 查看当前脚本格式 ","id":70,"section":"posts","summary":"vi /etc/hosts i 修改模式 esc 退出修改 :q 正常退出(文件没有修改 :q! 不保存退出 :wq 保存退出 G 跳到末尾行 dd 删除当前行 gg 跳到第一行第一个字符 $ 跳到当前行的最后一个字","tags":["linux"],"title":"vim命令备忘","uri":"https://www.mingaccount.com/2018/08/vim-common-command/","year":"2018"},{"content":"开启定时任务  @Configuration\r@EnableScheduling\r@ComponentScan(basePackages=\u0026quot;com.myco.tasks\u0026quot;)\rpublic class AppConfig {\r}\r 如果需要对定时任务的生命周期有其他的操作，可以实现接口SchedulingConfigurer\n@Configuration\r@EnableScheduling\rpublic class AppConfig implements SchedulingConfigurer {\r@Override\rpublic void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\rtaskRegistrar.setScheduler(taskScheduler());\rtaskRegistrar.addTriggerTask(\rnew Runnable() {\rpublic void run() {\rmyTask().work();\r}\r},\rnew CustomTrigger()\r);\r}\r@Bean(destroyMethod=\u0026quot;shutdown\u0026quot;)\rpublic Executor taskScheduler() {\rreturn Executors.newScheduledThreadPool(42);\r}\r@Bean\rpublic MyTask myTask() {\rreturn new MyTask();\r}\r}\r  详细信息参考 @EnableScheduling注解官方API\n 配置定时任务 package com.myco.tasks;\r@Component\rpublic class MyTask {\r@Scheduled(fixedRate=1000)\rpublic void work() {\r// task execution logic\r}\r}\r 注解@Scheduled有如下参数\n cron 输入cron表达式 fixedDelay 在最后一个任务执行完后，下个任务开始执行的间隔时间 fixedRate 最后一个任务开始执行后，下个任务开始执行的间隔时间 initialDelay 第一个任务执行前的延迟时间 zone 时区   详细信息参考 @Scheduled注解官方API\n ","id":71,"section":"posts","summary":"开启定时任务 @Configuration @EnableScheduling @ComponentScan(basePackages=\u0026quot;com.myco.tasks\u0026quot;) public class AppConfig { } 如果需要对定时任务的生命周期有其他的操作，可以实现接口SchedulingConfigurer @Configuration @EnableScheduling public class AppConfig implements SchedulingConfigurer { @Override","tags":["spring"],"title":"SpringBoot定时任务","uri":"https://www.mingaccount.com/2018/08/spring-boot-schedule/","year":"2018"},{"content":"本篇文章着重整理什么是静态化系统架构，以及静态化架构的几种方案。\n首先先贴一个淘宝系统升级的历程(09~13)：\n 09年，系统拆分，静态文件合并，前端页面异步化和json化。 10年，去DB依赖、引入缓存、提升单机QPS、关注用户体验。 11年，优化进入深水区Velocity、BigPipe。 12年，静态化改造。 13年统一Cache、CDN化、网络协议。  一、什么是静态化架构，为什么需要它 静态化架构系统通常有几个特征：\n 一个URL标识一个唯一的页面。 页面不包含cookie等私有数据，即用户信息，时间，地点等。  当出现高并发问题，一般情况下首先想到的是优化java程序，但java程序本身是有瓶颈的，并且他也存在不擅长处理大量连接请求，每个连接消耗内存较多，Servlet容器解析HTTP较慢等问题，那要怎样跳出Java来进行优化了？\n以下是静态话化架构的处理方式：\n 首先分离页面静态内容，页面内容并不是所有都需要从后台获取，将必须后台处理的分离出去，留下不受用户信息影响的静态的页面内容。 改变静态内容缓存的位置，不再缓存到java层面，直接在Web服务器上做缓存（Nginx,Apache,Varnish）； 分离出的动态内容Json化，以便复用。获取动态内容有两种方式ESI、CSI  ESI：在Web服务器上做动态内容请求，并将动态内容插入到静态页面，用户拿到的是一个完整的页面，用户体验好，服务器压力较大。 CSI：通过JS直接发送动态内容请求，用户体验差，服务器压力小。    二、静态化架构的几种方案 首先是静态化方案需要考虑的几个问题：\n 是否一致性Hash分组？做缓存一定是和命中率紧密相关的，命中率和数据的集中度相关，而要让数据集中一致性Hash就是一个必然选择。但是一致性Hash有一个天然的缺陷就是会导致热点问题，当热点特别集中时可能会导致网络瓶颈。 是否使用ESI?ESI对性能有影响，但是他对客户端友好，前端编程也方便。 是否使用物理机？物理机可以提供更大的内存、更好的CPU资源，但是使用物理机也有一些缺点，例如会导致应用集群的相对集中，进而导致网络风险增加。另外对Java系统而言内存增加并不能带来那么大的好处。 谁来压缩、在哪里压缩也是让人比较纠结的问题，增加一层Cache，必然增加了数据的传输，那么谁来压缩就会影响到Cache的容量和网络数据的传输量就。 网卡选择？网卡选择其实是个成本问题，避免网络瓶颈可以选择万兆网卡和交换机，但是必然成本增加。  方案1.采用Nginx+Cache+Java结构的虚拟机单机部署 这种方案是最简单的静态化方案，只需要在静态化改造的基础上，在前面的架构上加一层Cach就行，他的优缺点如下：\n优点：\n 没有网络瓶颈，不需要改造网络； 机器增加，也没有网卡瓶颈； 机器数增多，故障风险减少。  缺点:\n 机器增加，缓存命中率下降； 缓存分散，失效功能难度增加； Cache和JBoss都会争抢内存；  该方案虽然比较简单，但也能够解决热点商品的访问问题，例如做大促时，商品数比较少，在有限内存中任然能够命中这些商品；另外针对一些恶意攻击也十分有效，这是的命中率能达到90%以上，但是对系统的整体性能没有很多提升。\n方案2.采用Nginx+Cache+Java结构实体机单机部署 这种方案在前面的基础上将虚拟机改成实体机，增大Cache的内存，并且采用了一致性Hash分组的方式来提升命中率，这里将Cache分成若干组，这样就可以达到命中率和访问热点的平衡。\n优点：\n 既没有网络瓶颈，也能使用大内存； 减少Varnish机器，提升命中率； 提升命中率，能减少Gzip压缩； 减少Cache失效的压力。  这是一个比较理想的方案，在正常请求下也能达到50%左右的命中率，对一些基数数据比较小的系统如天猫Detail，命中率能达到80%左右，这样的命中率比较理想。\n方案3.统一Cache层 统一Cache层是个更理想的推广方案。\n将Cache层单独拿出来统一管理可以减少运维成本，同事也方便其他静态化系统接入。\n优点：\n 可以减少多个应用接入Cache的成本，接入的应用只维护自己的Java系统就好，不用单独维护Cache，只需关心如何使用，更好地让更多流量型系统接入使用。 统一Cache易于维护，例如后面加强监控、配置的自动化，统一维护、升级比较方便。 *可以共享内存，最大化利用内存，不同系统之间的内存可以动态切换，有效应对攻击情况。 更有助于安全防护。  三、如何解决失效问题 缓存的失效同样时静态化架构需要考虑的问题，这里采用主动失效和被动失效相结合的方式。\n被动失效\n　被动失效主要处理如模板变更和一些对时效性不是太敏感的数据的失效，采用设置Cache时间长度这种自动失效的方式，同时也要开发一个后台管理界面来用于手工失效某些Cache。\n主动失效\n　主动有如下几种：\n Cache失效中心监控数据库表变化，发送Purge失效请求； 装修时间戳比较失效装修内容； Java系统发布，清空Cache; Vm模板发布，清空Cache;\n其中主要使用第一个失效中心，这个失效中心通过监控数据库关键数据对应表的变更以发送Purge失效请求给Cache层来清除缓存数据。  四、服务端静态化方案的演进：CDN化 在静态化系统过后，还可以进一步优化，将Cache层前移到CDN（Content Delivery Network 内容分布网络，它会将用户的请求自动分配到最近的服务器进行处理，并且他会缓存网站的静态内容，加速网站的响应速度），因为CDN离用户最近，效果会更好。\n但是想要CDN化，存在几个问题需要解决：\n 失效问题。由于CDN分布在全国，要在秒级时间内失效这么广泛的Cache，对CDN的失效系统要求很高。 命中率问题。Cache最重要的一个指标就是要保证高命中率，不然Cache就失去了意义。同样，如果将数据全部放到全国的CDN上，Cache分散是必然的，Cache分散导致访问的请求命中到同一个请求的Cache降低，那么命中率就成为一个问题。 发布更新问题。作为一个业务系统，每周都有日常业务需要发布，所以发布系统是否简单、快速也是一个不可回避的问题，有问题快速回滚和问题排查的简便性也是要考虑的方面。  解决失效问题\n采用级联的失效结构，主动发Purge请求给Cache软件失效的方式，这种失效由失效中心将失效请求发送给每个CDN节点上的Console机，然后Concole机发送Purge请求给每台Cache机器。\n解决命中率问题\n现阶段把Cache放到全国所有的CDN节点上，现阶段是不太可能实现的，那么是否可以选择若干个节点来实施、尝试了？\n这样的节点需要满足以下几个条件：\n 靠近访问量比较集中的地区； 离主站相对较远； 节点到主站的网络比较好且稳定； 节点容量比较大，不会占用其他CDN太多的资源； 节点不要太多；  基于上面几个因素，选择CDN的二级Cache比较合适。\n使用CDN的二级Cache作为缓存，可以达到和前面服务端静态化Cache类似的命中率，因为节点数不多，Cache不是很分散，访问量也比较集中，这样也解决了命中率的问题，同时也提供给用户最好的访问体验，是在当前环境下比较理想的CDN化方案。\n*本文是《深入分析JAVA WEB技术内幕》一书的总结和节选\n","id":72,"section":"posts","summary":"本篇文章着重整理什么是静态化系统架构，以及静态化架构的几种方案。 首先先贴一个淘宝系统升级的历程(09~13)： 09年，系统拆分，静态文件合并","tags":["website build"],"title":"大浏览量系统的静态化架构设计","uri":"https://www.mingaccount.com/2018/08/static-sturcture-design/","year":"2018"},{"content":"最近在开发中碰见一个问题，后端代码调用接口，在请求端参数没有任何问题，但是当接口接收到参数时，其中的加号全部变为了空格。\n在查阅资料后发现是URLDecoder方法的问题，以下是URLDecoder的文档说明：\nThe following rules are applied in the conversion:\n The alphanumeric characters \u0026ldquo;a\u0026rdquo; through \u0026ldquo;z\u0026rdquo;, \u0026ldquo;A\u0026rdquo; through \u0026ldquo;Z\u0026rdquo; and \u0026ldquo;0\u0026rdquo; through \u0026ldquo;9\u0026rdquo; remain the same. The special characters \u0026ldquo;.\u0026rdquo;, \u0026ldquo;-\u0026rdquo;, \u0026ldquo;*\u0026rdquo;, and \u0026ldquo;_\u0026rdquo; remain the same. The plus sign \u0026ldquo;+\u0026rdquo; is converted into a space character \u0026quot; \u0026quot; . A sequence of the form \u0026ldquo;%xy\u0026rdquo; will be treated as representing a byte where xy is the two-digit hexadecimal representation of the 8 bits. Then, all substrings that contain one or more of these byte sequences consecutively will be replaced by the character(s) whose encoding would result in those consecutive bytes. The encoding scheme used to decode these characters may be specified, or if unspecified, the default encoding of the platform will be used  文档中很明显，URLDecoder会将加号转变为空格，其他的符号\u0026quot;.\u0026quot;, \u0026ldquo;-\u0026rdquo;, \u0026ldquo;*\u0026rdquo;, \u0026ldquo;_\u0026ldquo;将保持不变。\nSpring mvc框架在给参数赋值的时候调用了URLDecoder，那要解决这个问题，需要在请求的时候对\u0026rdquo;+\u0026ldquo;做处理：\nString plusEncode = URLEncoder.encode(\u0026quot;+\u0026quot;, \u0026quot;UTF-8\u0026quot;); param = param.replaceAll(\u0026quot;\\\\+\u0026quot;, plusEncode);  这里在请求发送前，将加号用URLEcoder进行编码，并将参数json中的所有加号替换成编码后的字符。\n","id":73,"section":"posts","summary":"最近在开发中碰见一个问题，后端代码调用接口，在请求端参数没有任何问题，但是当接口接收到参数时，其中的加号全部变为了空格。 在查阅资料后发现是U","tags":["java"],"title":"请求参数中的+号为什么会丢失,如何保证参数完整","uri":"https://www.mingaccount.com/2018/08/request-param-lost-add-symbol/","year":"2018"},{"content":"maven package生成的jar包默认是没有项目依赖的 需要导出的jar包包含项目所有的依赖，需要配置pom：\n\u0026lt;build\u0026gt;\r\u0026lt;finalName\u0026gt;yourApp\u0026lt;/finalName\u0026gt;\r\u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;shadedArtifactAttached\u0026gt;true\u0026lt;/shadedArtifactAttached\u0026gt;\r\u0026lt;shadedClassifierName\u0026gt;jar-with-dependencies\u0026lt;/shadedClassifierName\u0026gt; \u0026lt;!-- Any name that makes sense --\u0026gt;\r\u0026lt;outputDirectory\u0026gt;../output/jar-with-dependencies\u0026lt;/outputDirectory\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r\u0026lt;/build\u0026gt;\r 注意以上配置之后，maven还是会生成一个无依赖的jar包，但是在你设置的\u0026lt;outputDirectory\u0026gt;路径下会有一个全依赖的jar包\n","id":74,"section":"posts","summary":"maven package生成的jar包默认是没有项目依赖的 需要导出的jar包包含项目所有的依赖，需要配置pom： \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;yourApp\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;shadedArtifactAttached\u0026gt;true\u0026lt;/shadedArtifactAttached\u0026gt; \u0026lt;shadedClassifierName\u0026gt;jar-with-dependencies\u0026lt;/shadedClassifierName\u0026gt; \u0026lt;!-- Any name that makes sense --\u0026gt; \u0026lt;outputDirectory\u0026gt;../output/jar-with-dependencies\u0026lt;/outputDirectory\u0026gt; \u0026lt;/configuration\u0026gt;","tags":["maven"],"title":"Maven package完整依赖jar包","uri":"https://www.mingaccount.com/2018/07/maven-package-complete-dependency/","year":"2018"},{"content":"背景 默认情况下@Value注解如果没有在properties文件中存在对应值，那么启动项目的时候会直接报错。\n解决方案 可以给@Value注解设定默认值，这样就算配置文件中没有对应值，也不会报错。\n@Component\rpublic class ConfigurationProperties{\r@Value(\u0026quot;${custom.values.val1:#{null}\u0026quot;)\rprivate String val1;\r@Value(\u0026quot;${custom.values.val2:hello}\u0026quot;)\rprivate String val2;\r}\r 可以通过#{null}的方式将默认值设为null\n","id":75,"section":"posts","summary":"背景 默认情况下@Value注解如果没有在properties文件中存在对应值，那么启动项目的时候会直接报错。 解决方案 可以给@Value注解设","tags":["spring"],"title":"Spring boot @Value设定默认值 配置文件中没有也不会报错","uri":"https://www.mingaccount.com/2018/07/spring-boot-properties-default-value/","year":"2018"},{"content":"win10右键徽标-\u0026gt;Windows Powershell(管理员)\n dispark list disk 展示所有磁盘 select disk # 确认好所选目标磁盘，#号为id clean 删除选中磁盘的所有内容 exit  ","id":76,"section":"posts","summary":"win10右键徽标-\u0026gt;Windows Powershell(管理员) dispark list disk 展示所有磁盘 select disk # 确认好所选目标磁盘，#号为id clean 删除选中磁盘","tags":["windows"],"title":"Windows删除启动盘的所有分区","uri":"https://www.mingaccount.com/2018/07/windows-delete-disk-partition/","year":"2018"},{"content":"在阅读Venkat Subramaniam的著作《Functional Programming in Java》 之后，方法模式和lambda完美结合让我印象深刻。\n这种模式经常用作数据源处理，但也适用于类似的情况。这种模式可以让你集中注意力在核心功能点上，而不用担心类里面有过多重复的代码。\n这里创建了一个事务处理作为事例。\n接口 Transaction，他有一个执行方法。\nimport java.sql.Connection;\rimport java.sql.SQLException;\rpublic interface Transaction{\rpublic void execute(Connection connection) throws SQLException;\r}\r 这个接口代表我们想在事务中执行什么操作。这是一个 SAM(Single Abstract Method) 类型，意味着我们能够使用lambda表达式去实现他。\n然后我们轮到我们的主角登场，TransactionHandler。\nimport java.sql.Connection; import java.sql.DriverManager;\rpublic class TransactionHandler {\rpublic static void runInTransaction(Transaction transaction) throws Exception {\rConnection dbConnection = createDatabaseConnection();\rdbConnection.setAutoCommit(false);\rtry {\rSystem.out.println(\u0026quot;Starting transaction\u0026quot;);\rtransaction.execute(dbConnection);\rSystem.out.println(\u0026quot;Committing transaction\u0026quot;);\rdbConnection.commit();\r} catch (Exception e) {\rSystem.out.println(e.getMessage());\rSystem.out.println(\u0026quot;Rolling back...\u0026quot;);\rdbConnection.rollback();\r} finally {\rdbConnection.close();\r}\r}\rprivate static Connection createDatabaseConnection() throws Exception {\rClass.forName(\u0026quot;com.mysql.jdbc.Driver\u0026quot;);\rreturn DriverManager.getConnection(\u0026quot;jdbc:mysql://localhost:3306/ticket_system\u0026quot;, \u0026quot;user\u0026quot;, \u0026quot;password\u0026quot;);\r}\r}\r 他包含了一个静态方法,他的职责是运行我们的事务和在异常情况下回滚.\n我创建了一个简单的票务系统去展示TransactionHandler是怎么样和lambda一起工作的.\n首先是一个成功的事务:\n@Test\rpublic void testSuccessfulPurchase() throws Exception {\rTransactionHandler.runInTransaction(connection -\u0026gt; {\rint ticketId = findAvailableTicket(connection);\rreserveTicket(ticketId, connection);\rmarkAsBought(ticketId, connection);\r});\rassertEquals(getNrOfTicketsIn(TicketState.AVAILABLE), 9);\rassertEquals(getNrOfTicketsIn(TicketState.RESERVED), 0);\rassertEquals(getNrOfTicketsIn(TicketState.BOUGHT), 1);\r}\r 控制台输出:\nStarting transaction Reserving ticket with id 1 Marking ticket with id 1 as bought Committing transaction  然后是失败的事务:\n@Test\rpublic void testFailedPurchase() throws Exception {\rTransactionHandler.runInTransaction(connection -\u0026gt; {\rint ticketId = findAvailableTicket(connection);\rreserveTicket(ticketId, connection);\rthrow new IllegalStateException(\u0026quot;Not approved credit card\u0026quot;);\r});\rassertEquals(getNrOfTicketsIn(TicketState.AVAILABLE), 10);\rassertEquals(getNrOfTicketsIn(TicketState.RESERVED), 0);\rassertEquals(getNrOfTicketsIn(TicketState.BOUGHT), 0);\r}\r 这个测试预定了一张票,然后抛出异常,触发回滚取消预约;\n控制台输出:\nStarting transaction Reserving ticket with id 1 Not approved credit card Rolling back...  lambda表达式的处理方式是简洁优雅的，而匿名内部类需要创建类并实例化他，你不觉得他有些太罗嗦了吗?\n留意我们是如何使用lambda表达式作为一个工具去测试TransactionHandler的每个方面\n你能在这里找到完整的例子 GitHub\n*英文链接：deadCodeRising\n*原创译文\n","id":77,"section":"posts","summary":"在阅读Venkat Subramaniam的著作《Functional Programming in Java》 之后，方法模式和lambda完美结合让我印象深刻。 这种模式","tags":["java"],"title":"[译]lambda表达式对 SAM （单个抽象方法类）type的处理方式","uri":"https://www.mingaccount.com/2018/06/lambda-sam/","year":"2018"},{"content":"npm config set registry https://registry.npm.taobao.org\r ","id":78,"section":"posts","summary":"npm config set registry https://registry.npm.taobao.org","tags":["npm"],"title":"Npm淘宝镜像","uri":"https://www.mingaccount.com/2018/06/npm-taobao-mirror/","year":"2018"},{"content":"“JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性”\n一、类对象的获取 1.通过对象获取 Object obj = new Object();\robj.getClass();\r 2.通过类名获取 Object.class;\r 3.通过类的路径名获取 Class.forName(\u0026quot;com.metadata.Student\u0026quot;);\r 二、类的实例化和构造函数 获取到的class对象可以直接通过clazz.newInstance()方法实例化，但是需要目标类有默认无参构造函数，不然会抛出异常。\n在类没有默认无参构造函数，或者需要某个具体的构造函数来实例化的情况，需要通过Constructor类的newInstance()来完成。\n1.获取公有构造函数，不包括父类 //Class\rpublic Constructor\u0026lt;?\u0026gt;[] getConstructors() public Constructor\u0026lt;T\u0026gt; getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)\r 2.获取当前类构造函数，忽略修饰符 //Class\rpublic Constructor\u0026lt;?\u0026gt;[] getDeclaredConstructors()\rpublic Constructor\u0026lt;T\u0026gt; getDeclaredConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)\r 构造函数调用\n//Constructor\rpublic T newInstance(Object... initargs)\r//忽略修饰符，强制调用\rpublic void setAccessible(boolean flag)\r 三、类成员变量的获取 1.获取公有变量，包括父类 //Class\rpublic Field[] getFields()\rpublic Field getField(String name)\r 2.获取当前类成员变量，忽略修饰符 //Class\rpublic Field[] getDeclaredFields()\rpublic Field getDeclaredField(String name)\r 成员变量赋值\n//Field\r//obj为实例对象\rpublic void set(Object obj,Object value)\r//忽略修饰符，强制调用\rpublic void setAccessible(boolean flag)\r 四、类方法的获取 1.获取公有方法，包括父类 //Class\rpublic Method[] getMethods()\rpublic Method getMethod(String name,\rClass\u0026lt;?\u0026gt;... parameterTypes)\r 2.获取当前类方法，忽略修饰符 //Class\rpublic Method[] getDeclaredMethods()\rpublic Method getDeclaredMethod(String name,\rClass\u0026lt;?\u0026gt;... parameterTypes)\r 方法调用\n//Method\r//obj为类实例化对象，如果为静态方法obj为Null\rinvoke(Object obj, Object... args)\r//忽略修饰符，强制调用\rpublic void setAccessible(boolean flag)\r ","id":79,"section":"posts","summary":"“JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性” 一、类对","tags":["java"],"title":"Java反射常用API汇总","uri":"https://www.mingaccount.com/2018/06/java-reflection-common-api/","year":"2018"},{"content":"复杂密码才能通过\nsudo mysql -u root -p\rmysql\u0026gt; select user, plugin from mysql.user;\rmysql\u0026gt; update mysql.user set authentication_string=PASSWORD('xcvds_32GDS'), plugin='mysql_native_password' where user='root';\r mysql8.0不能用上边的语句：\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY \u0026quot;svewe_123\u0026quot;;\r ","id":80,"section":"posts","summary":"复杂密码才能通过 sudo mysql -u root -p mysql\u0026gt; select user, plugin from mysql.user; mysql\u0026gt; update mysql.user set authentication_string=PASSWORD('xcvds_32GDS'), plugin='mysql_native_password' where user='root'; mysql8.0不能用上边的语句： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY \u0026quot;svewe_123\u0026quot;;","tags":["mysql"],"title":"Mysql安装后root无法登陆(Access denied for user 'root'@'localhost')","uri":"https://www.mingaccount.com/2018/06/mysql-cant-login-with-root/","year":"2018"},{"content":"distributionManagement 需要在pom.xml文件中新增标签\u0026lt;distributionManagement\u0026gt;\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;\r\u0026lt;name\u0026gt;Maven Quick Start Archetype\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;http://maven.apache.org\u0026lt;/url\u0026gt;\r\u0026lt;!--\r|\r|\r|\r--\u0026gt;\r\u0026lt;distributionManagement\u0026gt;\r\u0026lt;repository\u0026gt;\r\u0026lt;id\u0026gt;mycompany-repository\u0026lt;/id\u0026gt;\r\u0026lt;name\u0026gt;MyCompany Repository\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;scp://repository.mycompany.com/repository/maven2\u0026lt;/url\u0026gt;\r\u0026lt;/repository\u0026gt;\r\u0026lt;/distributionManagement\u0026gt;\r\u0026lt;/project\u0026gt;\r settings.xml 然后在settings.xml文件中配置访问远程仓库的认证信息\n\u0026lt;settings xmlns=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026quot;\u0026gt;\r...\r\u0026lt;servers\u0026gt;\r\u0026lt;server\u0026gt;\r\u0026lt;id\u0026gt;mycompany-repository\u0026lt;/id\u0026gt;\r\u0026lt;username\u0026gt;jvanzyl\u0026lt;/username\u0026gt;\r\u0026lt;!-- Default value is ~/.ssh/id_dsa --\u0026gt;\r\u0026lt;privateKey\u0026gt;/path/to/identity\u0026lt;/privateKey\u0026gt; (default is ~/.ssh/id_dsa)\r\u0026lt;passphrase\u0026gt;my_key_passphrase\u0026lt;/passphrase\u0026gt;\r\u0026lt;/server\u0026gt;\r\u0026lt;/servers\u0026gt;\r...\r\u0026lt;/settings\u0026gt;\r ","id":81,"section":"posts","summary":"distributionManagement 需要在pom.xml文件中新增标签\u0026lt;distributionManagement\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;Maven Quick Start Archetype\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.apache.org\u0026lt;/url\u0026gt; \u0026lt;!-- | | | --\u0026gt; \u0026lt;distributionManagement\u0026gt; \u0026lt;repository\u0026gt;","tags":["maven"],"title":"Maven怎样把jar部署到远程仓库","uri":"https://www.mingaccount.com/2018/06/maven-deploy-jar-to-remote-repository/","year":"2018"},{"content":"avg函数对值为null的行，会忽略不计 解决方案\navg((coalesce(column,0))\r ","id":82,"section":"posts","summary":"avg函数对值为null的行，会忽略不计 解决方案 avg((coalesce(column,0))","tags":["mysql"],"title":"avg函数忽略null值","uri":"https://www.mingaccount.com/2018/06/avg-ignore-null/","year":"2018"},{"content":"参考官方文档Spring Boot Test\n","id":83,"section":"posts","summary":"参考官方文档Spring Boot Test","tags":["spring"],"title":"Srping Boot测试","uri":"https://www.mingaccount.com/2018/05/spring-boot-test/","year":"2018"},{"content":"   目录 描述     src/main/java Application/Library sources   src/main/resources Application/Library resources   src/main/filters Resource filter files   src/main/webapp Web application sources   src/test/java Test sources   src/test/resources Test resources   src/test/filters Test resource filter files   src/it Integration Tests (primarily for plugins)   src/assembly Assembly descriptors   src/site Site   LICENSE.txt Project\u0026rsquo;s license   NOTICE.txt Notices and attributions required by libraries that the project depends on   README.txt Project\u0026rsquo;s readme    ","id":84,"section":"posts","summary":"目录 描述 src/main/java Application/Library sources src/main/resources Application/Library resources src/main/filters Resource filter files src/main/webapp Web application sources src/test/java Test sources src/test/resources Test resources src/test/filters Test resource filter files src/it Integration Tests (primarily for plugins) src/assembly Assembly descriptors src/site Site LICENSE.txt Project\u0026rsquo;s license NOTICE.txt Notices and attributions required by libraries that the project depends on README.txt Project\u0026rsquo;s readme","tags":["maven"],"title":"Maven标准文件夹结构","uri":"https://www.mingaccount.com/2018/05/maven-stadard-dir-layout/","year":"2018"},{"content":"Java8 带来了许多改变，其中之一就是default修饰的接口方法。\n这些方法改变了我们已知的接口，现在我们能够在接口中定义默认实现方法。默认实现方法的不同之处在于，在接口中用default修饰抽象方法后，该方法可以拥有方法体，实现他的方法可以不重写default修饰的方法而且可以直接调用。\n如果你大量使用default方法在你的应用接口中，你将很快意识到他没有真正精简代码。\n因为你不能在接口中提炼default里重复的代码到一个新的普通方法，这与以精简代码为目的的default关键字相冲突。\n但在java9中这个问题被引入的 private interface methods 解决了。这些新定义的规则可以让你在接口中创建private修饰的方法，这样我们就可以在接口中构造更加简练的代码。\n利用Java9的 private interface methods 重构 default 方法\n代码实例：\n接口\u0026ndash;Archive\npublic interface Archive {\rList\u0026lt;Article\u0026gt; getArticles();\rdefault List\u0026lt;Article\u0026gt; filterByTitle(String title) {\rreturn getArticles().stream()\r.filter(article -\u0026gt; article.getTitle().equals(title))\r.collect(Collectors.toList());\r}\rdefault List\u0026lt;Article\u0026gt; filterByTag(String tag) {\rreturn getArticles().stream()\r.filter(article -\u0026gt; article.getTags().contains(tag))\r.collect(Collectors.toList());\r}\r}\r 正如你所看到的，Archive包含一个抽象方法- getArticles ，和两个default方法- filterByTitle 和 filterByTag 。\n现在，如果你仔细观察两个default方法，你会发现它们几乎相同。唯一的区别就是在filter方法中使用了不同的谓语而已。\n这种重复的代码又土又没有必要。理应让default代码更加简练，幸运的是Java9的 private interface method 可以帮上忙。\n下面是用 private interface methods 重写的Archive：\npublic interface NewArchive {\rList\u0026lt;Article\u0026gt; getArticles();\rdefault List\u0026lt;Article\u0026gt; filterByTitle(String title) {\rreturn filterBy(article -\u0026gt; article.getTitle().equals(title));\r}\rdefault List\u0026lt;Article\u0026gt; filterByTag(String tag) {\rreturn filterBy(article -\u0026gt; article.getTags().contains(tag));\r}\rprivate List\u0026lt;Article\u0026gt; filterBy(Predicate\u0026lt;Article\u0026gt; toFilterBy) {\rreturn getArticles().stream()\r.filter(toFilterBy)\r.collect(Collectors.toList());\r}\r}\r 这就是想要的结果，通过提取除了谓语以外的代码，我们移除了重复的内容，也让代码更具有可读性。\n*英文链接：deadCodeRising\n*原创译文\n","id":85,"section":"posts","summary":"Java8 带来了许多改变，其中之一就是default修饰的接口方法。 这些方法改变了我们已知的接口，现在我们能够在接口中定义默认实现方法。默认实现方法","tags":["java"],"title":"[译]java9新特性：在接口中用pirvate方法让default(java8接口特性)更简练","uri":"https://www.mingaccount.com/2018/05/java9-new-feature/","year":"2018"},{"content":"异常信息\nNo anonymous write access. Authentication failed for\r 解决方案\n提交的时候设置UserName和email\r 或者重新设置全局git用户名和邮箱\ngit config --global user.name \u0026quot;username\u0026quot;\rgit config --global user.email \u0026quot;email\u0026quot;\r ","id":86,"section":"posts","summary":"异常信息 No anonymous write access. Authentication failed for 解决方案 提交的时候设置UserName和email 或者重新设置全局git用户名和邮箱 git config --global user.name \u0026quot;username\u0026quot; git config --global user.email \u0026quot;email\u0026quot;","tags":["git"],"title":"Git push 异常：remote: No anonymous write access","uri":"https://www.mingaccount.com/2018/05/git-push-exception-no-anonymous/","year":"2018"},{"content":"1.在git上创建仓库，记下clone地址 2.把线上仓库拉到本地 git clone https://github.com/*/*.git\r 3.把要上传的本地项目文件全部放入本地仓库中 4.把所有文件提交到线上 git add .\rgit commit -m \u0026quot;first commit\u0026quot;\rgit push -u origin master\r ","id":87,"section":"posts","summary":"1.在git上创建仓库，记下clone地址 2.把线上仓库拉到本地 git clone https://github.com/*/*.git 3.把要上传的本地项目文件全部放入本地仓库中 4.把所有文件提交到线上 git","tags":["git"],"title":"Git上传本地项目","uri":"https://www.mingaccount.com/2018/05/git-upload-local-project/","year":"2018"},{"content":"# git更新当前分支\rgit pull\r#拉线上代码\rgit clone https://***.git.com\r#查看工作区状态\rgit status -s\r#撤回上一次的commit内容\rgit reset --hard HEAD~\r#查看当前分支\rgit branch\r#切换到对应分支\rgit checkout dev\r#删除所有本地未提交内容\rgit checkout .\r#下次push时保存输入密码\rgit config credential.helper store\r#更改当前项目的用户名和邮箱\rgit config user.name \u0026quot;\u0026quot;\rgit config user.email \u0026quot;\u0026quot;\r#更改全局的用户名和邮箱\rgit config --global user.name \u0026quot;\u0026quot;\rgit config --global user.email \u0026quot;\u0026quot;\r#git日志\rgit log\r#取消cherry pick\rgit cherry-pick --abort\r#在指定路径添加子模块\rgit submodule add \u0026lt;url\u0026gt; [path] # 撤回git add操作\rgit reset \u0026lt;file\u0026gt;\r ","id":88,"section":"posts","summary":"# git更新当前分支 git pull #拉线上代码 git clone https://***.git.com #查看工作区状态 git status -s #撤回上一次的commit内容 git reset --hard HEAD~ #查看当前分支 git branch #切换到对应分支 git checkout","tags":["git"],"title":"Git常用命令备忘","uri":"https://www.mingaccount.com/2018/05/git-common-command/","year":"2018"},{"content":"Hutool封装大量java工具类\nmaven配置：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;5.4.4\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  API文档\n官方首页\n ","id":89,"section":"posts","summary":"Hutool封装大量java工具类 maven配置： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; API文档 官方首页","tags":["java"],"title":"Hutool工具包","uri":"https://www.mingaccount.com/2018/05/hutool/","year":"2018"},{"content":"问题代码 service方法抛出了异常，但是没有rollback\n@Transactional\rpublic void batchInsert() throws CommonException{}\r 抛出的自定义异常继承于Exception\npublic class CommonException extends Exception{}\r 问题原因 @Transactional注解默认不能捕获checked异常\nchecked异常就是继承于Exception的异常，编辑器强制捕获或者抛出\runchecked异常就是继承于RuntimeException的异常，编译器不强制处理\r 解决方案  把CommonException改为继承RuntimeException 设置@Transactional(rollbackFor=CommonException.class)  发散 除了因为Exception类型原因导致的事务失败，还有可能因为以下原因：\n @Transactional修饰的方法不是public 本类中没有注解的方法调用有注解的方法 设置的引擎不支持事务  ","id":90,"section":"posts","summary":"问题代码 service方法抛出了异常，但是没有rollback @Transactional public void batchInsert() throws CommonException{} 抛出的自定义异常继承于Exception public class CommonException extends Exception{} 问题原因 @Tra","tags":["spring"],"title":"Spring @Transactional事务失效","uri":"https://www.mingaccount.com/2018/05/spring-transaction-invalid/","year":"2018"},{"content":"Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：\n　（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year\n　（2）Seconds Minutes Hours DayofMonth Month DayofWeek\n　一、结构 　corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份\n二、各字段的含义    字段 允许值 允许的特殊字符     秒（Seconds） 0~59的整数 , - * / 四个字符   分（Minutes） 0~59的整数 , - * / 四个字符   小时（Hours） 0~23的整数 , - * / 四个字符   日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符   月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符   星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符   年(可选，留空)（Year） 1970~2099 , - * / 四个字符    　注意事项：\n　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：\n　（1）*：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。\n　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。\n　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次\n　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.\n　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。\n　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。\n　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。\n　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。\n　（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n三、常用表达式例子 　（1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务\n　（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业\n　（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n　（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点\n　（5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时\n　（6）0 0 12 ? * WED 表示每个星期三中午12点\n　（7）0 0 12 * * ? 每天中午12点触发\n　（8）0 15 10 ? * * 每天上午10:15触发\n　（9）0 15 10 * * ? 每天上午10:15触发\n　（10）0 15 10 * * ? * 每天上午10:15触发\n　（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发\n　（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发\n　（13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发\n　（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发\n　（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发\n　（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发\n　（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发\n　（18）0 15 10 15 * ? 每月15日上午10:15触发\n　（19）0 15 10 L * ? 每月最后一日的上午10:15触发\n　（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发\n　（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发\n　（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发\n　注：\n　（1）有些子表达式能包含一些范围或列表\n　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”\n“*”字符代表所有可能的值\n　因此，“*”在子表达式（月）里表示每个月的含义，“*”在子表达式（天（星期））表示星期的每一天\n　“/”字符用来指定数值的增量\n例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟\n在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样\n　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值\n当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”\n　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写\n但是它在两个子表达式里的含义是不同的。\n在天（月）子表达式中，“L”表示一个月的最后一天\n在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT\n　如果在“L”前有具体的内容，它就具有其他的含义了\n　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五\n注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n转自：https://www.cnblogs.com/javahr/p/8318728.html\n","id":91,"section":"posts","summary":"Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： （1） Seconds Minutes Hours DayofMonth Month DayofWeek Year","tags":["spring"],"title":"quartz cron表达式详解","uri":"https://www.mingaccount.com/2018/05/quartz-cron/","year":"2018"},{"content":"指定ip信息，只需要修改set参数\nname是控制面板\\网络和 Internet\\网络连接中对应的连接名称\n@echo off\rset name=\u0026quot;Wi-Fi\u0026quot;\rset ipaddress=172.16.61.216\rset mask=255.255.255.0\rset gateway=172.16.61.254\rset dns1=172.16.3.38\rset dns2=172.16.3.41\rnetsh interface ip set address name=%name% source=static addr=%ipaddress% mask=%mask% gateway=%gateway% 1\rnetsh interface ip set dns name=%name% source=static addr=%dns1% register=PRIMARY\rnetsh interface ip add dns name=%name% addr=%dns2% index=2\r 恢复默认ip配置\n@echo off\rset name=\u0026quot;Wi-Fi\u0026quot;\rnetsh interface ip set address name=%name% source=dhcp\rnetsh interface ip set dns name=%name% source=dhcp\r ","id":92,"section":"posts","summary":"指定ip信息，只需要修改set参数 name是控制面板\\网络和 Internet\\网络连接中对应的连接名称 @echo off set name=\u0026quot;Wi-Fi\u0026quot; set ipaddress=172.16.61.216 set mask=255.255.255.0 set gateway=172.16.61.254 set dns1=172.16.3.38 set dns2=172.16.3.41 netsh interface ip set address","tags":["windows"],"title":"Windows IP DNS批处理","uri":"https://www.mingaccount.com/2018/03/windows-dns/","year":"2018"},{"content":"需要注意在判断int和Integer是否相等时，会先将Integer拆箱，如果Integer为null，会报空指针异常。\n因此需要提前处理好Integer对象为null的情况。\n","id":93,"section":"posts","summary":"需要注意在判断int和Integer是否相等时，会先将Integer拆箱，如果Integer为null，会报空指针异常。 因此需要提前处理好I","tags":["java"],"title":"判断int和Integer类型是否相等时，空指针异常","uri":"https://www.mingaccount.com/2018/03/int-equals-integer/","year":"2018"},{"content":"1. ASCII码 我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态（-128~127），这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。\n上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。\nASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。\nASCII码用了1个字节，1个字节可以表示256种状态，但ASCII码只用了128种，也就是一个字节的后七位，最前面的1位都是0\n2、非ASCII编码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。\n中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。\n3.Unicode编码 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。\nUnicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。\n4. Unicode的问题 需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n它们造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。\n5.UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。\nUTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则很简单，只有二条：\n 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 对于n字节的符号（n\u0026gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。  下表总结了编码规则，字母x表示可用编码的位。\n   Unicode符号范围 UTF-8编码方式     (十六进制) （二进制）   0000 0000-0000 007F 0xxxxxxx   0000 0080-0000 07FF 110xxxxx 10xxxxxx   0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx   0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    下面，还是以汉字“严”为例，演示如何实现UTF-8编码。\n已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。\n6. Unicode与UTF-8之间的转换 通过上一节的例子，可以看到“严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。\n在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击“文件”菜单中的“另存为”命令，会跳出一个对话框，在最底部有一个“编码”的下拉条。\n里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。\n 1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。 2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。（这种情况下如果一个字符的unicode超过2个字节就存不下了，utf-8就没事） 3）Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。 4）UTF-8编码，也就是上一节谈到的编码方法。  选择完”编码方式“后，点击”保存“按钮，文件的编码方式就立刻转换好了。\n7. Little endian和Big endian （其实这就是bom） 上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字”严“为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。\n这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。\n因此，第一个字节在前，就是”大头方式“（Big endian），第二个字节在前就是”小头方式“（Little endian）。\n那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？\nUnicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格“（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。\n如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。\n8. 实例 下面，举一个实例：\n打开”记事本“程序Notepad.exe，新建一个文本文件，内容就是一个”严“字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。\n然后，用文本编辑软件UltraEdit中的”十六进制功能“，观察该文件的内部编码方式。\n 1）ANSI：文件的编码就是两个字节“D1 CF”，这正是“严”的GB2312编码，这也暗示GB2312是采用大头方式存储的。 2）Unicode：编码是四个字节“FF FE 25 4E”，其中“FF FE”表明是小头方式存储，真正的编码是4E25。 3）Unicode big endian：编码是四个字节“FE FF 4E 25”，其中“FE FF”表明是大头方式存储。 4）UTF-8：编码是六个字节“EF BB BF E4 B8 A5”，前三个字节“EF BB BF”表示这是UTF-8编码，后三个“E4B8A5”就是“严”的具体编码，它的存储顺序与编码顺序是一致的。  9、unicode编码表 Unicode目前普遍采用的是UCS-2,它用两个字节来编码一个字符,比如汉字\u0026quot;经\u0026quot;的编码是0x7ECF,注意字符编码一般用十六进制来表示,为了与十进制区分,就是32463,UCS-2用两个字节来编码字符,两个字节就是16\n位二进制,2的16次方等于65536,所以UCS-2最多能编码65536个字符。编码从0到127的字符与ASCII编码的字符一样,比如字母\u0026quot;a\u0026quot;的Unicode 编码是0x0061,十进制是97,而\u0026quot;a\u0026quot;的ASCII编码是0x61,十进制也是97,\n对于汉字的编码,事实上Unicode对汉字支持不怎么好,这也是没办法的,简体和繁体总共有六七万个汉字,而UCS-2最多能表示65536个,才六万多个,所以Unicode只能排除一些几乎不用的汉字,好在常用的简体汉字\n也不过七千多个,为了能表示所有汉字,Unicode也有UCS-4规范,就是用4个字节来编码字符,不过现在普遍采用的还是UCS-2，只用两个字节来编码\n曾经使用这种方法处理汉字传输乱码问题。传输过程中将汉字转换成UCS-2的unicode 4位16进制编码，接收后再转回来。\n10、BCD码 在一次面试中被问到BCD码上面讲的是字符编码，是指一个字符对应的一个二进制数，而BCD码是计算机在对十进制数做运算或存储时采用的二进制格式。\n即BCD代码。Binary-Coded Decimal‎，简称BCD，称BCD码或二-十进制代码，亦称二进码十进数。是一种二进制的数字编码形式，用二进制编码的十进制代码。这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。\nBCD码 - 常用BCD码\n   十进制数 8421码 5421码 2421码 余3码 余3循环码     0 0000 0000 0000 0011 0010   1 0001 0001 0001 0100 0110   2 0010 0010 0010 0101 0111   3 0011 0011 0011 0110 0101   4 0100 0100 0100 0111 0100   5 0101 1000 1011 1000 1100   6 0110 1001 1100 1001 1101   7 0111 1010 1101 1010 1111   8 1000 1011 1110 1011 1110   9 1001 1100 1111 1100 1010    bcd码效率高：\n比如十进制要以二进制的形式在计算机中存储，十进制直接转换成与之对应的BCD码比十进制通过除法取余再转换的效率来的高\n11、Base64编码（怎么使用？） （把一串二进制转换成另一种二进制串，以至于可以打印成英文、数字字符还有+、/）\n1、Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3*8 = 4*6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。\n2、在email传输中，加密是肯定的，但是base64加密的目的不是让用户发送非常安全的Email。这种加密方式主要就是“防君子不防小人”，达到一种一眼看上去看不出内容的效果。\n3、base64编码是用来解决把不可打印的内容塞进可打印内容的需求的。比如把图片存到数据库，图片数据归根到底还是一堆二进制串（总不能把这些二进制串直接存到数据库吧），用base64编码后的显示成的字符串就大大缩小的长度，可以存到数据库。\n4、满足电子邮件中不能直接使用非ASCII码字符传输数据的规定，所以使用base64进行编码后传输，因为base64的64个字符肯定有对应的ascii编码。\n5、请不要再叫base64加密，请叫base64编码\n让我们再来看一个实际的例子，加深印象！\n转换前 10101101 10111010 01110110\n转换中 101011 011011 101001 110110\n转换后 00101011 00011011 00101001 00110110\n对应码表中的值 r b p 2\n转自http://blog.csdn.net/junhuahouse/article/details/23032827\n很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。\n开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10, 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉 很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。\n后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！\n等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。\n但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣 们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……”\n因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！\n正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。\nunicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。\n这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。\nunicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。\nunicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。\nUTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。\n   Unicode符号范围 UTF-8编码方式     (十六进制) （二进制）   0000 0000-0000 007F 0xxxxxxx   0000 0080-0000 07FF 110xxxxx 10xxxxxx   0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx   0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    作者：于洋\n链接：https://www.zhihu.com/question/23374078/answer/69732605\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","id":94,"section":"posts","summary":"1. ASCII码 我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就","tags":["java"],"title":"[转]字符编码笔记：ASCII、Unicode、UTF-8 和 Base64","uri":"https://www.mingaccount.com/2018/03/char-encode/","year":"2018"},{"content":"关于如何有效避免空指针，并减少空指针的重复申明。\n参考stackoverflow的讨论\n","id":95,"section":"posts","summary":"关于如何有效避免空指针，并减少空指针的重复申明。 参考stackoverflow的讨论","tags":["java"],"title":"Java合理避免空指针","uri":"https://www.mingaccount.com/2018/03/java-avoid-null-pointer/","year":"2018"},{"content":"一、需要一个类继承HttpServletRequestWrapper，该类继承了ServletRequestWrapper并实现了HttpServletRequest， 因此它可作为request在FilterChain中传递。\n该类需要重写getReader和getInputStream两个方法，并在返回时将读出的body数据重新写入。\n二、需要一个Filter筛选目标urlPattern，调用第一个类的同时，将第一个类写入FilterChain中代替原本的Request package com.bonc.util;\rimport javax.servlet.ReadListener;\rimport javax.servlet.ServletInputStream;\rimport javax.servlet.http.HttpServletRequest;\rimport javax.servlet.http.HttpServletRequestWrapper;\rimport java.io.*;\rpublic class BodyReaderRequestWrapper extends HttpServletRequestWrapper {\rprivate final String body;\r/**\r*\r* @param request\r*/\rpublic BodyReaderRequestWrapper(HttpServletRequest request) throws IOException{\rsuper(request);\rStringBuilder sb = new StringBuilder();\rInputStream ins = request.getInputStream();\rBufferedReader isr = null;\rtry{\rif(ins != null){\risr = new BufferedReader(new InputStreamReader(ins));\rchar[] charBuffer = new char[128];\rint readCount = 0;\rwhile((readCount = isr.read(charBuffer)) != -1){\rsb.append(charBuffer,0,readCount);\r}\r}else{\rsb.append(\u0026quot;\u0026quot;);\r}\r}catch (IOException e){\rthrow e;\r}finally {\rif(isr != null) {\risr.close();\r}\r}\rsb.toString();\rbody = sb.toString();\r}\r@Override\rpublic BufferedReader getReader() throws IOException {\rreturn new BufferedReader(new InputStreamReader(this.getInputStream()));\r}\r@Override\rpublic ServletInputStream getInputStream() throws IOException {\rfinal ByteArrayInputStream byteArrayIns = new ByteArrayInputStream(body.getBytes());\rServletInputStream servletIns = new ServletInputStream() {\r@Override\rpublic boolean isFinished() {\rreturn false;\r}\r@Override\rpublic boolean isReady() {\rreturn false;\r}\r@Override\rpublic void setReadListener(ReadListener readListener) {\r}\r@Override\rpublic int read() throws IOException {\rreturn byteArrayIns.read();\r}\r};\rreturn servletIns;\r}\r}\r package com.bonc.bitwd.filter;\rimport com.bonc.util.BodyReaderRequestWrapper;\rimport javax.servlet.*;\rimport javax.servlet.http.HttpServletRequest;\rimport javax.servlet.http.HttpServletResponse;\rimport java.io.IOException;\rpublic class BodyReaderRequestFilter implements Filter{\r@Override\rpublic void init(FilterConfig filterConfig) throws ServletException {\r}\r@Override\rpublic void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain) throws IOException, ServletException {\rHttpServletRequest request = (HttpServletRequest)req;\rHttpServletResponse response = (HttpServletResponse)res;\rBodyReaderRequestWrapper requestWrapper = new BodyReaderRequestWrapper(request);\rif(requestWrapper == null){\rfilterChain.doFilter(request,response);\r}else {\rfilterChain.doFilter(requestWrapper,response);\r}\r}\r@Override\rpublic void destroy() {\r}\r}\r ","id":96,"section":"posts","summary":"一、需要一个类继承HttpServletRequestWrapper，该类继承了ServletRequestWrapper并实现了HttpS","tags":["java"],"title":"Request的Body只能读取一次解决方法","uri":"https://www.mingaccount.com/2018/03/request-body-read-twice/","year":"2018"},{"content":"# 一般声明\rdef printUser(id,name,sex,age,email,phone,group):\rprintUser(1,'ming','male',18,'',110,'default')\r # 默认值\rdef printUser(id,name,sex,age,email='',phone=110,group='default'):\rprintUser(1,'ming','male',18)\r # 位置参数和关键字参数\rdef printUser(id,name,sex,/,age,email,*,phone,group):\r# 位置参数就是调用的时候直接赋值\r# 关键字参数就是调用的时候通过 key=value 的形式赋值\r# 斜杠之前的只能有位置参数，斜杆之后和*号之前的，可以有关键字参数或者位置参数，*号之后的只能关键字参数\rprintUser(1,'ming','male',18, email='@mail', phone=110, group='default')\r# 关键字参数必须在位置参数之后，并且位置参数必须遵循方法声明的顺序，但是关键字参数可以任意变换顺序\rprintUser(1,'ming','male',18, group='default', email='@mail', phone=110)\r # 元组\rdef printUser(id, name, sex, *args):\rprintUser(1,'ming','male', 18, '@mail', 110, 'default')\r # 多个关键字参数\rdef printUser(id, name, sex, **kwargs):\rprintUser(1,'ming','male', age=18, email='@mail', phone=110, group='defalut')\r 注意*args和**kwargs可以在一起使用，但是*args必须在**kwargs前面。\n# 注解\r# 表示参数类型和方法返回类型\rdef printUser(id,name,sex, age, email:str='@email', group:str='default') -\u0026gt; str:\r ","id":97,"section":"posts","summary":"# 一般声明 def printUser(id,name,sex,age,email,phone,group): printUser(1,'ming','male',18,'',110,'default') # 默认值 def printUser(id,name,sex,age,email='',phone=110,group='default'): printUser(1,'ming','male',18) # 位置参数和关键字参数 def printUser(id,name,sex,/,age,email,*,phone,group): # 位置参数就是调用的时候直接赋值 # 关键字参数就是调用的时候通过 key=value 的形式赋值 # 斜杠之前","tags":["python"],"title":"Python方法定义","uri":"https://www.mingaccount.com/2018/01/python-method-define/","year":"2018"},{"content":"全局filter @Component\r@Order(1)\rpublic class FirstFilter extends Filter {\r@Override\rpublic void doFilter(\rServletRequest request,\rServletResponse response,\rFilterChain chain) throws IOException, ServletException {\r...\rchain.doFilter(request, response);\r}\r}\r 全局过滤直接实现Filter即可，如需设定顺序，使用@Order注解\nURL Pattern Filter 过滤指定的URL，需要通过注册Bean的形式：\n@Configuration\rpublic class FilterBeanConfiguration{\r@Bean\rpublic FilterRegistrationBean\u0026lt;SecondFilter\u0026gt; secondFilter(){\rFilterRegistrationBean\u0026lt;SecondFilter\u0026gt; registrationBean\r= new FilterRegistrationBean\u0026lt;\u0026gt;();\rregistrationBean.setFilter(new SecondFilter());\rregistrationBean.addUrlPatterns(\u0026quot;/users/*\u0026quot;);\rreturn registrationBean;\r}\r}\r @Order(2)\rpublic class SecondFilter extends Filter {\r@Override\rpublic void doFilter(\rServletRequest request,\rServletResponse response,\rFilterChain chain) throws IOException, ServletException {\r...\rchain.doFilter(request, response);\r}\r}\r 注意通过FilterRegistrationBean注册的filter，不能被@Component修饰\n","id":98,"section":"posts","summary":"全局filter @Component @Order(1) public class FirstFilter extends Filter { @Override public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { ... chain.doFilter(request, response); } } 全局过滤直接实现Filter即可，如需设定顺序，使用@Order注解 URL","tags":["spring"],"title":"Spring boot filter","uri":"https://www.mingaccount.com/2018/01/spring-boot-filter/","year":"2018"},{"content":" 交于Spring管理的类，通过注解调用  @Component\rpublic class Test{\r@Autowired\rprivate HttpServletRequest httpServletRequest;\r}\r 通过静态方法调用  HttpServletRequest httpServletRequest = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();\r ","id":99,"section":"posts","summary":"交于Spring管理的类，通过注解调用 @Component public class Test{ @Autowired private HttpServletRequest httpServletRequest; } 通过静态方法调用 HttpServletRequest httpServletRequest = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();","tags":["java"],"title":"全局获取request","uri":"https://www.mingaccount.com/2018/01/get-request-global/","year":"2018"},{"content":"Description Below I present you two different ways to get the current Class:\n Using Thread Using getClass()  The simplest way to get the name of the class where your code is being executed in is using the getClass() method present in every java object. Like here:\nString clazz = this.getClass().getName();\r This works only if executed in an Object, namely an instanciated class. If you try to execute the code above in a static method. It won\u0026rsquo;t work. Even the keyword this is meaningless in a static method.\nAlso, the class returned by the above method may actually be a subclass of the class in which the method is defined. This is because subclasses inherit the methods of their parents; and getClass() returns the actual runtime type of the object. To get the actual class in which a method is defined, use the method below also.\nIn a static method you can instead use the following:\nString clazz = Thread.currentThread().getStackTrace()[1].getClassName();\r Which uses the static methodgetStackTrace() to get the whole stacktrace. This method returns an array, where the first element (index 0) is the getStackTrace() you called and the second element (index 1) is the method your code is in.\nA similar trick can be used to find out the name of the method currently executed:\nString method = Thread.currentThread().getStackTrace()[1].getMethodName();\r It\u0026rsquo;s exactly the same principle, just you dig out the name of the method instead of the class.\nThe code package org.wikijava.reflection; public class MethodName { public static void main(String[] args) { MethodName methodName = new MethodName(); String clazz = Thread.currentThread() .getStackTrace() [1].getClassName();\rString method = Thread.currentThread() .getStackTrace()[1].getMethodName();\rSystem.out.println(\u0026quot;class name: \u0026quot; + clazz + \u0026quot; Method Name \u0026quot; + method); methodName.anotherMethod(); } private void anotherMethod() { String clazz = this.getClass().getName(); String method = Thread.currentThread() .getStackTrace()[1].getMethodName(); System.out.println(\u0026quot;class name: \u0026quot; + clazz + \u0026quot; Method Name \u0026quot; + method); } }  ","id":100,"section":"posts","summary":"Description Below I present you two different ways to get the current Class: Using Thread Using getClass() The simplest way to get the name of the class where your code is being executed in is using the getClass() method present in every java object. Like here: String clazz = this.getClass().getName(); This works only if executed in an Object, namely an instanciated class. If you try to execute the code above","tags":["java"],"title":"Java获取当前类名和方法名","uri":"https://www.mingaccount.com/2018/01/java-fetch-current-classname-methodname/","year":"2018"},{"content":" 所谓观察者模式，指的某个状态信息的改变，会影响其他一系列的操作，这时就可以将这些操作抽象化，同时创建一个类统一的管理和执行这些操作。把这些抽象出来的操作称为观察者类，而管理这些操作的类称为通知者类，通知者类维护着一个观察者类的集合，可以追加和删除观察者，同时可遍历通知所有观察者类执行操作。    观察者模式的不足：虽然观察者模式提取出了抽象类，让类与类之间不互相依赖，共同依赖于抽象接口，这符合依赖倒转原则，但他们仍然依赖着抽象接口，而且有些时候不能提取出抽象的观察者（比如引用jar包）。 java委托机制与观察者模式：委托机制的实现不再需要提取观察者抽象类，观察者和通知者互不依赖。java利用反射即可实现，代码实例如下:  事件类\npackage com.suski.delegate;\rimport java.lang.reflect.Method;\rpublic class Event {\rprivate Object object;\rprivate String methodName;\rprivate Object[] params;\rprivate Class[] paramTypes;\rpublic Event(Object object,String method,Object...args)\r{\rthis.object = object;\rthis.methodName = method;\rthis.params = args;\rcontractParamTypes(this.params);\r}\rprivate void contractParamTypes(Object[] params)\r{\rthis.paramTypes = new Class[params.length];\rfor (int i=0;i\u0026lt;params.length;i++)\r{\rthis.paramTypes[i] = params[i].getClass();\r}\r}\rpublic void invoke() throws Exception\r{\rMethod method = object.getClass().getMethod(this.methodName, this.paramTypes);//判断是否存在这个函数\rif (null == method)\r{\rreturn;\r}\rmethod.invoke(this.object, this.params);//利用反射机制调用函数\r}\r}\r 事件管理类\npackage com.suski.delegate;\rimport java.util.ArrayList;\rimport java.util.List;\rpublic class EventHandler {\rprivate List\u0026lt;Event\u0026gt; objects;\rpublic EventHandler()\r{\robjects = new ArrayList\u0026lt;Event\u0026gt;();\r}\rpublic void addEvent(Object object, String methodName, Object...args)\r{\robjects.add(new Event(object, methodName, args));\r}\rpublic void notifyX() throws Exception\r{\rfor (Event event : objects)\r{\revent.invoke();\r}\r}\r}\r 通知者抽象类\npackage com.suski.delegate;\rpublic abstract class Notifier {\rprivate EventHandler eventHandler = new EventHandler();\rpublic EventHandler getEventHandler()\r{\rreturn eventHandler;\r}\rpublic void setEventHandler(EventHandler eventHandler)\r{\rthis.eventHandler = eventHandler;\r}\rpublic abstract void addListener(Object object,String methodName, Object...args);\rpublic abstract void notifyX();\r}\r 通知者具体实现类\npackage com.suski.delegate;\rpublic class ConcreteNotifier extends Notifier{\r@Override\rpublic void addListener(Object object, String methodName, Object... args) {\rthis.getEventHandler().addEvent(object, methodName, args);\r}\r@Override\rpublic void notifyX() {\rtry {\rthis.getEventHandler().notifyX();\r} catch (Exception e) {\r// TODO: handle exception\re.printStackTrace();\r}\r}\r}\r 具体的观察者类，不再需要抽象观察者\npackage com.suski.delegate;\rimport java.util.Date;\rpublic class WatchingTVListener {\rpublic WatchingTVListener()\r{\rSystem.out.println(\u0026quot;watching TV\u0026quot;);\r}\rpublic void stopWatchingTV(Date date) {\rSystem.out.println(\u0026quot;stop watching\u0026quot; + date);\r}\r}\r package com.suski.delegate;\rimport java.util.Date;\rpublic class PlayingGameListener {\rpublic PlayingGameListener()\r{\rSystem.out.println(\u0026quot;playing\u0026quot;);\r}\rpublic void stopPlayingGame(Date date)\r{\rSystem.out.println(\u0026quot;stop playing\u0026quot; + date);\r}\r}\r 测试方法\npackage com.suski.delegate;\rimport java.util.Date;\rpublic class Test {\rpublic static void main (String[] args)\r{\rNotifier goodNotifier = new ConcreteNotifier();\rPlayingGameListener playingGameListener = new PlayingGameListener();\rWatchingTVListener watchingTVListener = new WatchingTVListener();\rgoodNotifier.addListener(playingGameListener, \u0026quot;stopPlayingGame\u0026quot;, new Date());\rgoodNotifier.addListener(watchingTVListener, \u0026quot;stopWatchingTV\u0026quot;, new Date());\rgoodNotifier.notifyX();\r}\r}\r ","id":101,"section":"posts","summary":"所谓观察者模式，指的某个状态信息的改变，会影响其他一系列的操作，这时就可以将这些操作抽象化，同时创建一个类统一的管理和执行这些操作。把这些抽","tags":["design pattern"],"title":"观察者模式和java委托","uri":"https://www.mingaccount.com/2018/01/observe-patter-and-java-agent/","year":"2018"},{"content":"转自:http://blog.csdn.net/kaiwii/article/details/7405761\n主要功能\nClass.forName(xxx.xx.xx)返回的是一个类\nClass.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，\n也就是说JVM会执行该类的静态代码段\n下面，通过解答以下三个问题的来详细讲解下Class.forName()的用法。\n一.什么时候用Class.forName()？ 先来个热身，给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？你第一想到的肯定是new,但是注意一点：\nA a = (A)Class.forName(“pacage.A”).newInstance();\r 这和你 A a = new A()； 是一样的效果。\n现在言归正传。\n动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象时需要用到：\nString str = “用户输入的字符串” ;\rClass t = Class.forName(str);\rt.newInstance();\r 在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。那么为什么会有两种创建对象方式？这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。\nJava中工厂模式经常使用newInstance()方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。 例如：\nclass c = Class.forName(“Example”);\rfactory = (ExampleInterface)c.newInstance();\r 其中ExampleInterface是Example的接口，可以写成如下形式：\nString className = “Example”;\rclass c = Class.forName(className);\rfactory = (ExampleInterface)c.newInstance();\r 进一步可以写成如下形式：\nString className = readfromXMlConfig;//从xml 配置文件中获得字符串\rclass c = Class.forName(className);\rfactory = (ExampleInterface)c.newInstance();\r 上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。\n从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。但是使用newInstance()方法的时候，就必须保证：\n1、这个类已经加载；\n2、这个类已经连接了。\n而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。\n现在可以看出，newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。 这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。\n二.new 和Class.forName（）有什么区别？ 其实上面已经说到一些了，这里来做个总结：\n首先，newInstance( )是一个方法，而new是一个关键字；\n其次，Class下的newInstance()的使用有局限，因为它生成对象只能调用无参的构造函数，而使用 new关键字生成对象没有这个限制。 简言之：\n newInstance(): 弱类型,低效率,只能调用无参构造。 new: 强类型,相对高效,能调用任何public构造。 Class.forName(“”)返回的是类。 Class.forName(“”).newInstance()返回的是object 。  三.为什么在加载数据库驱动包的时候有用的是Class.forName( )，却没有调用newInstance( )？ 在Java开发特别是数据库开发中，经常会用到Class.forName( )这个方法。\n通过查询Java Documentation我们会发现使用Class.forName( )静态方法的目的是为了动态加载类。\n通常编码过程中，在加载完成后，一般还要调用Class下的newInstance( )静态方法来实例化对象以便操作。因此，单单使用Class.forName( )是动态加载类是没有用的，其最终目的是为了实例化对象。\n有数据库开发经验朋友会发现，为什么在我们加载数据库驱动包的时候有的却没有调用newInstance( )方法呢？\n即有的jdbc连接数据库的写法里是Class.forName(xxx.xx.xx);而有一 些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？\n刚才提到，Class.forName(“”);的作用是要求JVM查找并加载指定的类，首先要明白，java里面任何class都要装载在虚拟机上才能运行，而静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了，而且以后不会再走这段静态代码了。\n而我们前面也说了，Class.forName(xxx.xx.xx)的作用就是要求JVM查找并加载指定的类，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。\n而在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己，即任何一个JDBC Driver的 Driver类的代码都必须类似如下：\npublic class MyJDBCDriver implements Driver {\rstatic {\rDriverManager.registerDriver(new MyJDBCDriver());\r}\r}  既然在静态初始化器的中已经进行了注册，所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了。\n相关英文参考文献如下：\nwe just want to load the driver to jvm only, but not need to user the instance of driver,\nso call Class.forName(xxx.xx.xx) is enough, if you call Class.forName(xxx.xx.xx).newInstance(),\nthe result will same as calling Class.forName(xxx.xx.xx),\nbecause Class.forName(xxx.xx.xx).newInstance() will load driver first,\nand then create instance, but the instacne you will never use in usual,\nso you need not to create it.\n","id":102,"section":"posts","summary":"转自:http://blog.csdn.net/kaiwii/article/details/7405761 主要功能 Class.forNam","tags":["java"],"title":"[转]Class.forName()用法详解","uri":"https://www.mingaccount.com/2017/11/class-forname/","year":"2017"},{"content":"原因是因为list是由Arrays.asList生成的 根据Arrays源码，asList方法生成的ArrayList，并不是java.util.ArrayList，而是Arrays的一个内部类\npublic static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) {\rreturn new ArrayList\u0026lt;\u0026gt;(a);\r}\r 该内部类直接继承了AbstractList，并且并未实现addAll方法\nprivate static class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt;\rimplements RandomAccess, java.io.Serializable\r 然而默认的AbstractList的addAll方法直接抛出了异常，并未有任何实现\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) {\rboolean modified = false;\rfor (E e : c)\rif (add(e))\rmodified = true;\rreturn modified;\r}\rpublic boolean add(E e) {\rthrow new UnsupportedOperationException();\r}\r ","id":103,"section":"posts","summary":"原因是因为list是由Arrays.asList生成的 根据Arrays源码，asList方法生成的ArrayList，并不是java.uti","tags":["java"],"title":"List addAll产生异常java.lang.UnsupportedOperationException","uri":"https://www.mingaccount.com/2017/11/list-addall-exception/","year":"2017"},{"content":"通过以下命令，即可创建项目描述网页\nmvn site\r 跟网页展示资源相关的目录\n+- src/\r+- site/\r+- apt/\r| +- index.apt\r!\r+- markdown/\r| +- content.md\r|\r+- fml/\r| +- general.fml\r| +- faq.fml\r|\r+- xdoc/\r| +- other.xml\r|\r+- site.xml\r site.xml是描述文件，可以指定网页的菜单，链接，和图片等。\nsrc/site下面的每个目录对应一个标记语言，可以选择熟悉的标记语言目录来生成描述信息，但是index文件在所有目录下只能有一个。\n 详情参考mvn site\n ","id":104,"section":"posts","summary":"通过以下命令，即可创建项目描述网页 mvn site 跟网页展示资源相关的目录 +- src/ +- site/ +- apt/ | +- index.apt ! +- markdown/ | +- content.md | +- fml/ | +- general.fml | +- faq.fml | +- xdoc/ | +- other.xml | +- site.xml site.x","tags":["maven"],"title":"Maven构建项目描述网页","uri":"https://www.mingaccount.com/2017/11/maven-site/","year":"2017"},{"content":"背景 如果配置bean的时候出现null值，并且被其他bean所引用。那么启动的时候就有可能出现失败的情况。\n@Configuration\rpublic class BeanConfiguration{\r@Bean\rpublic Other getOther() {\rreturn null\r}\r}\r 因为配置的bean为null，Spring会直接忽略这个bean：\nUser-defined bean method '***' in '***' ignored as the bean value is null\r 解决方案 如果一个bean是可能为null的，那么在引用他的时候，需要将@Autowire注解的required属性设置为false。\npublic class Test{\r@Autowire(required=false)\rprivate Other other;\r}\r 这样就算bean为null，程序也能正常启动，但是需要注意空指针。\npublic class Test{\rprivate Other other;\r/**\r* can't work\r* @param other\r*/\r@Autowire(required=false)\rpublic Test(Other other) {\rthis.other = other\r}\r}\r 注意如果是通过构造器进行的bean引用，那么就算在构造器上申明了@Autowire(required=false)也没用。\n","id":105,"section":"posts","summary":"背景 如果配置bean的时候出现null值，并且被其他bean所引用。那么启动的时候就有可能出现失败的情况。 @Configuration public class BeanConfiguration{ @Bean public Other getOther() { return null } } 因为配置","tags":["spring"],"title":"Spring bean为null启动报错","uri":"https://www.mingaccount.com/2017/11/spring-bean-null/","year":"2017"},{"content":"项目结构 +- pom.xml\r+- my-app\r| +- pom.xml\r| +- src\r| +- main\r| +- java\r+- my-webapp\r| +- pom.xml\r| +- src\r| +- main\r| +- webapp\r 可以看到该项目下包含两个module:my-app、my-webapp。两个子module都有对应的pom.xml文件。\npom 最外层的项目pom.xml\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;app\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\r\u0026lt;modules\u0026gt;\r\u0026lt;module\u0026gt;my-app\u0026lt;/module\u0026gt;\r\u0026lt;module\u0026gt;my-webapp\u0026lt;/module\u0026gt;\r\u0026lt;/modules\u0026gt;\r\u0026lt;/project\u0026gt;\r 上面的\u0026lt;packaging\u0026gt;和\u0026lt;modules\u0026gt;标签是用来保证每个子模块的pom相关命令都能被执行到\n注意\u0026lt;module\u0026gt;标签中的值是子模块的相对路径，如果子模块不是父项目的子文件夹，而是同级的文件夹，那么\u0026lt;module\u0026gt;的值就应该是../my-app\n如果子模块中有依赖，比如my-webapp依赖my-app，那么需要在my-webapp模块中的pom.xml文件中添加依赖：\n\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r...\r\u0026lt;/dependencies\u0026gt;\r 上面的子模块依赖，保证my-webapp生成的包中包含了my-app的包，并且my-app的包构建永远在my-webapp之前\n然后两个子模块的pom.xml中分别需要追加一个\u0026lt;parent\u0026gt;标签，以防子模块单独构建找不到父模块的依赖：\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;parent\u0026gt;\r\u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;app\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;/parent\u0026gt;\r...\r 如果需要继承父项目的版本号和groupId，在子模块中不申明和即可\n另外，如果子模块要继承的父项目不像上面的结构一样，并且父项目也不在本地仓库中，比如像这样的结构：\n.\r|-- my-module\r| `-- pom.xml\r`-- parent\r`-- pom.xml\r 那么就需要手动指向父模块的pom.xml文件：\n\u0026lt;project\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;parent\u0026gt;\r\u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1\u0026lt;/version\u0026gt;\r\u0026lt;relativePath\u0026gt;../parent/pom.xml\u0026lt;/relativePath\u0026gt;\r\u0026lt;/parent\u0026gt;\r\u0026lt;artifactId\u0026gt;my-module\u0026lt;/artifactId\u0026gt;\r\u0026lt;/project\u0026gt;\r \u0026lt;relativePath\u0026gt;标签就是指相对于当前模块，父模块pom.xml文件所在的相对位置\n","id":106,"section":"posts","summary":"项目结构 +- pom.xml +- my-app | +- pom.xml | +- src | +- main | +- java +- my-webapp | +- pom.xml | +- src | +- main | +- webapp 可以看到该项目下包含两个module:my-app、my-webapp。","tags":["maven"],"title":"包含多个模块的项目如何配置maven","uri":"https://www.mingaccount.com/2017/11/maven-multiple-module/","year":"2017"},{"content":"*该博客转自 http://blog.csdn.net/danchu/article/details/54986442\n语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。\nJava作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。一般来说Java中的语法糖主要有以下几种：\n 泛型与类型擦除 自动装箱与拆箱，变长参数、 增强for循环 内部类与枚举类  泛型与类型擦除 Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。\n在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。\n/**\r* 在源代码中存在泛型\r*/\rpublic static void main(String[] args) {\rMap\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;String,String\u0026gt;();\rmap.put(\u0026quot;hello\u0026quot;,\u0026quot;你好\u0026quot;);\rString hello = map.get(\u0026quot;hello\u0026quot;);\rSystem.out.println(hello);\r}\r 当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换\npublic static void main(String[] args) {\rHashMap map = new HashMap(); //类型擦除\rmap.put(\u0026quot;hello\u0026quot;, \u0026quot;你好\u0026quot;);\rString hello = (String)map.get(\u0026quot;hello\u0026quot;);//强制转换\rSystem.out.println(hello);\r}\r 自动装箱与拆箱 Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。\r 我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。\n下面代码演示了自动装箱和拆箱功能\npublic static void main(String[] args) {\rInteger a = 1;\rint b = 2;\rint c = a + b;\rSystem.out.println(c);\r}\r 经过编译后，代码如下\npublic static void main(String[] args) {\rInteger a = Integer.valueOf(1); // 自动装箱\rbyte b = 2;\rint c = a.intValue() + b;//自动拆箱\rSystem.out.println(c);\r}\r 变长参数 所谓变长参数，就是方法可以接受长度不定确定的参数\n变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。\npublic class Varargs {\rpublic static void print(String... args) {\rfor(String str : args){\rSystem.out.println(str);\r}\r}\rpublic static void main(String[] args) {\rprint(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;);\r}\r}\r 编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的\npublic class Varargs {\rpublic Varargs() {\r}\rpublic static void print(String... args) {\rString[] var1 = args;\rint var2 = args.length;\r//增强for循环的数组实现方式\rfor(int var3 = 0; var3 \u0026lt; var2; ++var3) {\rString str = var1[var3];\rSystem.out.println(str);\r}\r}\rpublic static void main(String[] args) {\r//变长参数转换为数组\rprint(new String[]{\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;});\r}\r}\r 增强for循环 增强for循环与普通for循环相比，功能更强并且代码更简洁\r 增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。\npublic static void main(String[] args) {\rString[] params = new String[]{\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;};\r//增强for循环对象为数组\rfor(String str : params){\rSystem.out.println(str);\r}\rList\u0026lt;String\u0026gt; lists = Arrays.asList(\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;);\r//增强for循环对象实现Iterable接口\rfor(String str : lists){\rSystem.out.println(str);\r}\r}\r 编译后的class文件为\npublic static void main(String[] args) {\rString[] params = new String[]{\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;};\rString[] lists = params;\rint var3 = params.length;\r//数组形式的增强for退化为普通for\rfor(int str = 0; str \u0026lt; var3; ++str) {\rString str1 = lists[str];\rSystem.out.println(str1);\r}\rList var6 = Arrays.asList(new String[]{\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;});\rIterator var7 = var6.iterator();\r//实现Iterable接口的增强for使用iterator接口进行遍历\rwhile(var7.hasNext()) {\rString var8 = (String)var7.next();\rSystem.out.println(var8);\r}\r}\r 内部类 内部类就是定义在一个类内部的类\r Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。\npublic class Outer {\rclass Inner{\r}\r}\r 使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：\nclass Outer$Inner {\rOuter$Inner(Outer var1) {\rthis.this$0 = var1;\r}\r}\r 内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了\n枚举类型 枚举类型就是一些具有相同特性的类常量\r java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。\npublic enum Fruit {\rAPPLE,ORINGE\r}\r 使用jad对编译后的class文件进行反编译后得到：\n//继承java.lang.Enum并声明为final\rpublic final class Fruit extends Enum\r{\rpublic static Fruit[] values()\r{\rreturn (Fruit[])$VALUES.clone();\r}\rpublic static Fruit valueOf(String s)\r{\rreturn (Fruit)Enum.valueOf(Fruit, s);\r}\rprivate Fruit(String s, int i)\r{\rsuper(s, i);\r}\r//枚举类型常量\rpublic static final Fruit APPLE;\rpublic static final Fruit ORANGE;\rprivate static final Fruit $VALUES[];//使用数组进行维护\rstatic\r{\rAPPLE = new Fruit(\u0026quot;APPLE\u0026quot;, 0);\rORANGE = new Fruit(\u0026quot;ORANGE\u0026quot;, 1);\r$VALUES = (new Fruit[] {\rAPPLE, ORANGE\r});\r}\r}\r ","id":107,"section":"posts","summary":"*该博客转自 http://blog.csdn.net/danchu/article/details/54986442 语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，","tags":["java"],"title":"[转]谈谈Java中的语法糖","uri":"https://www.mingaccount.com/2017/10/java-syntatic-sugar/","year":"2017"},{"content":"一、常见的编码格式 1.ASCII 　基础编码，英文和西欧字符。\n　用一个字节的低7位表示，一共128个。\n　0~13是控制字符如换行、回车、删除等，32~126是打印字符，键盘输入。\n2.IOS-8859-1 　ASCII的扩展。\n　用一个字节表示，一共256个。\n3.GB2312 　中文编码字符集。\n　用两个字节表示，A1~A9是符号区，一共682个；B0~F7是汉字区，一共6763个。\n　编码需要查询对应码表，效率略低。\n4.GBK 　GB2312的扩展，能够兼容GB2312。\n　用两个字节表示，一共23940个码位，表示21003个汉字。\n　编码需要查询对应码表，效率略低。\n5.UTF-16 　UTF-16具体定义了Unicode字符在计算机的存取方法。\n　用两个字节表示Unicode的转化格式。\n　定长的展示方法，每两个字节表示一个字符，转化效率高，内存和硬盘多用此编码(JAVA内存存储格式UTF-16)。\n　采用顺序编码，不能对单个字符的编码进行校验，如果损坏，后面的码值都会受影响。\n6.UTF-8 　UTF-8具体定义了Unicode字符在计算机的存取方法。\n　用1-6个字节组成一个字符，汉字采用三个字节表示。\n　变长的展示方法，每个编码区域有不同的字码长度。\n　网络传输中很大一部分字符用一个字节就可以展示，UTF-16规范化的全部转为了两个字节，对于这些字符UTF-8只需要一个字节。\n　UTF-8如果中间一个码值损坏，后面的码值并不受影响。\n　相对于UTF-16，UTF-8有传输中资源占用小，数据更安全的优势，更适合网络传输，但UTF-16的编码规则相对简单，编码效率更高，适合本地内存和磁盘。\n二、常见JAVA编码API 1.I/O　 InputStreamReader isr = new InputStreamReader(inputStream,\u0026quot;utf-8\u0026quot;);\rCharset StreamDecoder\rOutputStreamWriter osw = new OutputStreamWriter(outputStream,\u0026quot;utf-8\u0026quot;);\rCharset StreamEncoder\r 2.内存操作 字符与字节的转换：　//String\rString s = \u0026quot;中文字符\u0026quot;;\rbyte[] b = s.getBytes(\u0026quot;UTF-8\u0026quot;);\rString s1 = new String(b,\u0026quot;UTF-8\u0026quot;);\r//Charset\rCharset charset = Charset.forName(\u0026quot;UTF-8\u0026quot;);\rByteBuffer byteBuffer = charset.encode(string);\rCharBuffer charBuffer = charset.decode(byteBuffer);\r//char和byte的软转换，将一个16bit的char拆分成两个8bit的byte来显示，实际值并没有被转换。\rByteBuffer heapByteBuffer = ByteBuffer.allocate(1024);\rByteBuffer byteBuffer = heapByteBuffer.putChar(c);\r 三、Java Web中涉及的编解码 1.URL编解码 PathInfo中文问题：\n配置tomcat的server.xml：\nQueryString是通过HTTP中的Header传到后台的，他的解码字符集默认是ISO-8859-1，\n也可以通过Header的ContentType中的Charset来定义。\n如何确定后端调取了ContentType中的字符集，需要在server.xml中配置（这个配置只针对QueryString有效）：\n2.HTTP Header的编解码 针对Header中的其他参数，比如Cookie,redirectPath等。\n尽量不要传递非ASCII字符，如果必须，在传递之前用下面的API进行编码再传递：\norg.apache.catalina.util.URLEncoder\n3.POST表单的编解码 客户端获取参数为乱码后的解决思路：\n　1.将POST改为get，查看浏览器端是否有问题。\n　2.后端request.geCharacterEncdoing返回结果是否是预期编码。\n//在第一次使用request.getParameter之前使用\nrequest.setCharacterEncoding(charset);\n4.HTTP BODY的编解码 主要阐述从后台到前台的编解码：\n//对返回前台的数据进行编码，前台会首先根据这个值进行解码 response.setCharacterEncoding(charset)  \u0026lt;!-- 如果后台没有设置，会根据页面中的charset来解码，如果页面也有设置则用默认编码来解码 --\u0026gt;\r\u0026lt;meta HTTP-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html;charset=UTF-8\u0026quot;/\u0026gt;\r\u0026lt;!-- JDBC读写数据时要和数据的内置编码保持一致 --\u0026gt;\rurl=\u0026quot;jdbc:mysql://localhost:3306/DB?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026quot;\r 四、JS的编码问题 1.外部引入js文件 \u0026lt;!-- 浏览器会按照charset的设置来解析这个js文件，如果没有设置则默认按照当前页面的的编码设置来解析js文件 --\u0026gt;\r\u0026lt;script src=\u0026quot;de/mo/demo.js\u0026quot; charset=\u0026quot;gbk\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r 2.js的URL编码 //对url根据UTF-8进行编码和解码，除了一些特殊字符\u0026quot;!\u0026quot;\u0026quot;#\u0026quot;\u0026quot;$\u0026quot;\u0026quot;\u0026amp;\u0026quot;\u0026quot;'\u0026quot;\u0026quot;(\u0026quot;\u0026quot;)\u0026quot;\u0026quot;*\u0026quot;\u0026quot;+\u0026quot;\u0026quot;,\u0026quot;\u0026quot;-\u0026quot;\u0026quot;.\u0026quot;\u0026quot;/\u0026quot;\u0026quot;:\u0026quot;\u0026quot;;\u0026quot;\u0026quot;=\u0026quot;\u0026quot;?\u0026quot;\u0026quot;@\u0026quot;\u0026quot;_\u0026quot;\u0026quot;~\u0026quot;\u0026quot;0-9\u0026quot;\u0026quot;a-z\u0026quot;\u0026quot;A-Z\u0026quot;\r//编码结果在每个码值前加一个\u0026quot;%\u0026quot;\rencodeURI(\u0026quot;http://localhost:8080/examples/servlets/servlet/来吧昆特牌吧孙子?inviter=杰洛特\u0026quot;);\rdecodeURI(\u0026quot;**编码内容**\u0026quot;);\r//对url根据UTF-8进行编码和解码，相对于encodeURI，它更加的彻底。排除的特殊字符为\u0026quot;!\u0026quot;\u0026quot;'\u0026quot;\u0026quot;(\u0026quot;\u0026quot;)\u0026quot;\u0026quot;*\u0026quot;\u0026quot;-\u0026quot;\u0026quot;.\u0026quot;\u0026quot;_\u0026quot;\u0026quot;~\u0026quot;\u0026quot;0-9\u0026quot;\u0026quot;a-z\u0026quot;\u0026quot;A-Z\u0026quot;\r//编码结果在每个码值前加一个\u0026quot;%\u0026quot;\r//它排除的字符比encodeURI更少，通常用于将URL作为参数的URL的编码，如示例如果不将参数URL中的\u0026amp;进行编码会影响到整个URL的完整性\r\u0026quot;http://localhost/servlet?ref=\u0026quot; + encodeURIComponent(\u0026quot;http://localhost:8080/examples/servlets/servlet/来吧昆特牌吧孙子?inviter=杰洛特\u0026amp;inviter=叶奈法\u0026quot;);\rdecodeURIComponent(\u0026quot;**编码内容**\u0026quot;);\r 3.后端接收时解码 后端处理URL编解码靠的是 java.net.URLEncoder和java.net.URLDecoder这两个类。\n后端对的对URL的编码同样也有排除的特殊字符，与前端的encodeURIComponent相对应。\n//后端直接获取传过来的URL参数会自动解码\r//如果没有提前设置request.setCharacterEncoding()很容易出现编码不同而导致的乱码\rrequest.getParameter();\r//另一种方式是通过前台js对URL进行两次编码，后台不管通过什么进行第一次解码，都能得到正确的UTF-8编码，前台代码如下\rencodeURIComponent(encodeURIComponent(url));\r//第一次编码的结果（例如：%E2%A7）的百分号，会在第二次编码后将%变成%25（例如：%25E2%25A7）\r//后台在执行request.getParameter()的时候会自动解码，不管当前容器的编码是什么得到的是正确的UTF-8编码（例如：%E2%A7）\r 五、其他需要编码的地方 1.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r 2.Velocity services.VelocityService.input.encoding=UTF-8\r 3.JSP \u0026lt;%@page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot;%\u0026gt;\r 注：本文是对“《深入分析Java Web技术内幕》许令波 著” 一书的相关内容的总结\n","id":108,"section":"posts","summary":"一、常见的编码格式 1.ASCII 基础编码，英文和西欧字符。 用一个字节的低7位表示，一共128个。 0~13是控制字符如换行、回车、删除等，32~126是打","tags":["java"],"title":"Java编码,乱码问题详解","uri":"https://www.mingaccount.com/2017/10/java-encode/","year":"2017"},{"content":"pom resources 首先要为pom文件新添一个resources标签\n\u0026lt;project\u0026gt;\r\u0026lt;name\u0026gt;...\u0026lt;/name\u0026gt;\r\u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt;\r\u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt;\r...\r\u0026lt;build\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;/build\u0026gt;\r\u0026lt;/project\u0026gt;\r 默认情况下\u0026lt;filtering\u0026gt;的属性为false，因此需要申明来覆盖它。resource的directory标签申明了资源的路径，代表该路径下的资源都可以通过@property@（注意是被@包裹）的方式来访问以下相关的属性：\n pom中的属性，例如：@project.name@ @project.version@ @project.build.finalName@ settings.xml中的属性，例如：@settings.localRepository@ 系统属性，例如： @java.version@ @user.home@  #application.properties\rapplication.name=@project.name@\rapplication.version=@project.version@\rjava.version=@java.version@\r 以上的属性引用，都会在mvn build阶段通过mvn process-resources语句处理为实际的值。手动执行完mvn process-resources命令，在target/classes下的资源就会变成这样：\n#application.properties\rapplication.name=test\rapplication.version=1.1\rjava.version=1.8\r 除了系统中已经定义好的属性，你还可以自定义属性\n外部文件属性 定义一个外部属性文件src/main/filters/filter.properties：\n# filter.properties\rmy.filter.value=hello!\r 要访问这个属性文件，需要更改pom文件build块的内容：\n\u0026lt;build\u0026gt;\r\u0026lt;filters\u0026gt;\r\u0026lt;filter\u0026gt;src/main/filters/filter.properties\u0026lt;/filter\u0026gt;\r\u0026lt;/filters\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt;\r\u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;/build\u0026gt;\r 相比之前的build，增加了一个filters标签，将自定义属性文件的路径作为子标签的属性。这样在src/main/resources路径下的资源文件中就可以直接访问了：\n#application.properties\rapplication.name=@project.name@\rapplication.version=@project.version@\rjava.version=@java.version@\rmy.filter.value=@my.filter.value@\r pom properties pom文件中的properties属性，不仅在pom文件中能调用，在外部资源文件中也能像前面那样调用。\n\u0026lt;project\u0026gt;\r\u0026lt;name\u0026gt;...\u0026lt;/name\u0026gt;\r\u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt;\r\u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt;\r...\r\u0026lt;properties\u0026gt;\r\u0026lt;my.property\u0026gt;myProperty\u0026lt;/my.property\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;build\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;/build\u0026gt;\r\u0026lt;/project\u0026gt;\r #application.properties\rapplication.name=@project.name@\rapplication.version=@project.version@\rjava.version=@java.version@\rmy.filter.value=@my.filter.value@\rmy.property=@my.property@\r 命令行属性 跟在mvn后面的属性参数，也能在src/main/resources目录中的资源文件中调用：\nmvn package \u0026quot;-Dmy.command.property=commandProperty\u0026quot;\r 规则就是在-D后边加上属性键值对(key=value)\n#application.properties\rapplication.name=@project.name@\rapplication.version=@project.version@\rjava.version=@java.version@\rmy.filter.value=@my.filter.value@\rmy.property=@my.property@\rmy.command.property=@my.command.property@\r 加载外部文件的属性 可以通过加载外部属性文件，扩展Maven可用的属性值。\n\u0026lt;project\u0026gt;\r...\r\u0026lt;name\u0026gt;My Resources Plugin Practice Project\u0026lt;/name\u0026gt;\r...\r\u0026lt;build\u0026gt;\r...\r\u0026lt;filters\u0026gt;\r\u0026lt;filter\u0026gt;[a filter property]\u0026lt;/filter\u0026gt;\r\u0026lt;/filters\u0026gt;\r...\r\u0026lt;/build\u0026gt;\r...\r\u0026lt;/project\u0026gt;\r my-filter-values.properties包含以下属性：\nyour.name = world\r 可以加载到pom.xml中：\n...\r\u0026lt;filters\u0026gt;\r\u0026lt;filter\u0026gt;my-filter-values.properties\u0026lt;/filter\u0026gt;\r\u0026lt;/filters\u0026gt;\r...\r 这样就可以通过${your.name}来访问该属性值\n","id":109,"section":"posts","summary":"pom resources 首先要为pom文件新添一个resources标签 \u0026lt;project\u0026gt; \u0026lt;name\u0026gt;...\u0026lt;/name\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; ... \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 默认情况下\u0026lt;filtering\u0026gt;的属性为fals","tags":["maven"],"title":"如何在资源文件中读取Maven相关的参数","uri":"https://www.mingaccount.com/2017/10/maven-filter-resources-file/","year":"2017"},{"content":"excel拆分规则  固定长度拆分 指定符号拆分 忽略重复拆分符号 带文本识别符号的拆分（比如\u0026quot;1,2,3,4,5\u0026quot;现在按照逗号分隔，但是又设置文本识别符号为\u0026quot;，那么\u0026quot;1,2,3,4,5\u0026quot;会被当做一个整体，不会进一步参与拆分）  正则表达式 固定长度直接substr即可，这里不讨论。下面的正则表达式中{split}代表拆分符号，{text}代表文本识别符号。\n指定符号拆分正则： [{split}]\r 忽略重复拆分符号 [{split}]+\r 带文本识别符号的拆分 (?![^{text}]+{text}{split}|[^{text}]+{text}$)\r ","id":110,"section":"posts","summary":"excel拆分规则 固定长度拆分 指定符号拆分 忽略重复拆分符号 带文本识别符号的拆分（比如\u0026quot;1,2,3,4,5\u0026quot;现在按照逗号分","tags":["regexp"],"title":"excel拆分(split)功能实现","uri":"https://www.mingaccount.com/2017/10/split-regexp/","year":"2017"},{"content":"概览 Java8为集合流处理提供了并发支持。并且就算集合不是线程安全的，你也可以在不修改集合的状态下，对集合进行并发汇总操作。但是这里面仍有一些限制和需要注意的情况，同时你也需要根据数据的实际情况来决定是否需要并发处理。\n并发申明 你可以通过并行或者串行的方式执行流。默认情况下所有的流都是串行的，如果需要并行，可以通过Collection.parallelStream或者调用某个operation的BaseStream.parallel。\ndouble average = roster\r.parallelStream()\r.filter(p -\u0026gt; p.getGender() == Person.Sex.MALE)\r.mapToInt(Person::getAge)\r.average()\r.getAsDouble()\r 上面的例子是并发求取所有男性成员的平均年龄。\n并发Reduction 默认串行reduction操作：\nMap\u0026lt;Person.Sex, List\u0026lt;Person\u0026gt;\u0026gt; byGender =\rroster\r.stream()\r.collect(\rCollectors.groupingBy(Person::getGender));\r 上面的例子将所有成员按性别分组\n下面是并行reduction：\nConcurrentMap\u0026lt;Person.Sex, List\u0026lt;Person\u0026gt;\u0026gt; byGender =\rroster\r.parallelStream()\r.collect(\rCollectors.groupingByConcurrent(Person::getGender));\r 可以看到不光是parallelStream的区别，还有groupingByConcurrent。要确定collect操作是否是并发，要满足以下三个条件：\n parallelStream。 collect操作的参数，必须包含特征：Collector.Characteristics.CONCURRENT 。通过调用Collector.characteristics 来决定一个collector的特征属性。 要么stream是无序的，要么collector有Collector.Characteristics.UNORDERED 特性。通过调用BaseStream.unordered 来确保Stream是无序的。  注意：上面用了ConcurrentMap和groupingByConcurrent，都是因为性能的原因。因为他们能更好的适配parallelStream带来更高的性能。\n排序 流处理元素的顺序取决于它是并行还是串行的，并且还有中间操作的影响。默认情况下串行的流是按照集合顺序执行的，并行的情况顺序无法保证，但是在迭代时你可以使用forEachOrdered来代替forEach强制并行流按照顺序遍历，但是这会损耗性能，跟并行的初衷相违。\nInteger[] intArray = {1, 2, 3, 4, 5, 6, 7, 8 };\rList\u0026lt;Integer\u0026gt; listOfIntegers =\rnew ArrayList\u0026lt;\u0026gt;(Arrays.asList(intArray));\rSystem.out.println(\u0026quot;listOfIntegers:\u0026quot;);\rlistOfIntegers\r.stream()\r.forEach(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\rSystem.out.println(\u0026quot;listOfIntegers sorted in reverse order:\u0026quot;);\rComparator\u0026lt;Integer\u0026gt; normal = Integer::compare;\rComparator\u0026lt;Integer\u0026gt; reversed = normal.reversed(); Collections.sort(listOfIntegers, reversed); listOfIntegers\r.stream()\r.forEach(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\rSystem.out.println(\u0026quot;Parallel stream\u0026quot;);\rlistOfIntegers\r.parallelStream()\r.forEach(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\rSystem.out.println(\u0026quot;Another parallel stream:\u0026quot;);\rlistOfIntegers\r.parallelStream()\r.forEach(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\rSystem.out.println(\u0026quot;With forEachOrdered:\u0026quot;);\rlistOfIntegers\r.parallelStream()\r.forEachOrdered(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\r print:\nlistOfIntegers:\r1 2 3 4 5 6 7 8\rlistOfIntegers sorted in reverse order:\r8 7 6 5 4 3 2 1\rParallel stream:\r3 4 1 6 2 5 7 8\rAnother parallel stream:\r6 3 1 5 7 8 4 2\rWith forEachOrdered:\r8 7 6 5 4 3 2 1\r 副作用 流的collect操作对并发情况有良好的的支持，但是像forEach和peek这种操作，不适用于并发流，他们可能被并发的在多个线程处理多次，并且他们的结果无法估计，还会产生副作用。除了两个遍历操作，像System.out这种返回void的调用，在lambda表达式中除了带来副作用没有任何意义。还要注意像filter和map操作的lambda表达式参数，需要确保他们不会产生任何副作用。\n惰性 流的中间操作都不是立即执行的，他们再被申明过后，都会等待最后一个终端操作（比如之前的forEach和collect）的出现，才开始被调用。因为这个特性，在申明流的中间操作时，需要特别注意不要有干扰和状态化的lambda表达式出现。\n错误的干扰 下面的例子是一个错误的干扰性的中间操作申明：\ntry {\rList\u0026lt;String\u0026gt; listOfStrings =\rnew ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026quot;one\u0026quot;, \u0026quot;two\u0026quot;));\r// This will fail as the peek operation will attempt to add the\r// string \u0026quot;three\u0026quot; to the source after the terminal operation has\r// commenced. String concatenatedString = listOfStrings\r.stream()\r// Don't do this! Interference occurs here.\r.peek(s -\u0026gt; listOfStrings.add(\u0026quot;three\u0026quot;))\r.reduce((a, b) -\u0026gt; a + \u0026quot; \u0026quot; + b)\r.get();\rSystem.out.println(\u0026quot;Concatenated string: \u0026quot; + concatenatedString);\r} catch (Exception e) {\rSystem.out.println(\u0026quot;Exception caught: \u0026quot; + e.toString());\r}\r 上面的例子在peek操作中给集合源添加了一个元素。按照之前的惰性说明，流操作的执行的开始是在终端操作出现之后。当流开始处理，这时候peek操作修改源数据，就会抛出ConcurrentModificationException。\n不该出现的状态化lambda表达式 List\u0026lt;Integer\u0026gt; serialStorage = new ArrayList\u0026lt;\u0026gt;();\rSystem.out.println(\u0026quot;Serial stream:\u0026quot;);\rlistOfIntegers\r.stream()\r// Don't do this! It uses a stateful lambda expression.\r.map(e -\u0026gt; { serialStorage.add(e); return e; })\r.forEachOrdered(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\rserialStorage\r.stream()\r.forEachOrdered(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\rSystem.out.println(\u0026quot;Parallel stream:\u0026quot;);\rList\u0026lt;Integer\u0026gt; parallelStorage = Collections.synchronizedList(\rnew ArrayList\u0026lt;\u0026gt;());\rlistOfIntegers\r.parallelStream()\r// Don't do this! It uses a stateful lambda expression.\r.map(e -\u0026gt; { parallelStorage.add(e); return e; })\r.forEachOrdered(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\rparallelStorage\r.stream()\r.forEachOrdered(e -\u0026gt; System.out.print(e + \u0026quot; \u0026quot;));\rSystem.out.println(\u0026quot;\u0026quot;);\r  e -\u0026gt; { parallelStorage.add(e); return e; }在这里是一个状态化的lambda表达式，在parallel的情况下他的执行结果可能是难以预料的：\nSerial stream:\r8 7 6 5 4 3 2 1\r8 7 6 5 4 3 2 1\rParallel stream:\r8 7 6 5 4 3 2 1\r1 3 6 2 4 5 8 7\r 注意，这里使用了Collections.synchronizedList来包装并发的List，如果没有这个逻辑，直接申明一个ArrayList来接收并发流生成的list，那么可能会产生多个线程同时修改一个对象的情况，结果可能像这样：\nParallel stream:\r8 7 6 5 4 3 2 1\rnull 3 5 4 7 8 1 2\r ","id":111,"section":"posts","summary":"概览 Java8为集合流处理提供了并发支持。并且就算集合不是线程安全的，你也可以在不修改集合的状态下，对集合进行并发汇总操作。但是这里面仍有一","tags":["java"],"title":"Java8 lamda表达式中的parallel","uri":"https://www.mingaccount.com/2017/09/java8-parallel/","year":"2017"},{"content":"Reduction 首先看一个例子：\ndouble average = roster\r.stream()\r.filter(p -\u0026gt; p.getGender() == Person.Sex.MALE)\r.mapToInt(Person::getAge)\r.average()\r.getAsDouble();\r 像上面的例子一样，JDK还包含很多其他的终端操作（比如说average,sum,min,max,和count），他们合并了stream中的内容并返回单一的结果。这些操作被统一称为Reduction operations。JDK同样包含可以返回集合而不是一个值的reduction操作.大多数reduction操作针对的都是特定情况，比如找平均值或者按照目录分组等。但是，JDK同样也提供了通用的reduction操作，他们是reduce和collect。\nStream.reduce 下面的例子目的是求名册中男性成员的年龄总和\n首先使用Stream.sum的方式\nInteger totalAge = roster\r.stream()\r.mapToInt(Person::getAge)\r.sum();\r 下面用Stream.reduce计算同样的结果\nInteger totalAgeReduce = roster\r.stream()\r.map(Person::getAge)\r.reduce(\r0,\r(a,b) -\u0026gt; a + b);\r)\r 这个reduce操作有两个参数：\n identity：它既是reduction计算的初始值也是在流没有任何元素的时候的默认值。这个例子中identity的值是0，也就是求和的初始化值是0，并且如果roster流中没有任何元素，最后返回的结果也是0。 accumulator：这个accumulator方法有两个参数：一个是reduction的部分结果（在这个例子里面，就是到目前为止所有年龄的和），另外一个是流的下一个元素（在这个例子中就是下一个年龄数）。它返回了一个新的部分结果。在这个例子中，accumulator方法是一个将两个Integer相加并返回Integer相加结果的lambda表达式：\n(a,b) -\u0026gt; a + b  这个reduce操作始终返回一个新的值。但是，这个accumulator方法在每次处理流中的一个元素后，也返回一个新的值。假定你想处理的stream更复杂，比如内部都是集合。这样可能对性能造成影响。比如你的reduce操作是合并集合，那么每次你的accumulator方法在处理一个元素时，都会创建一个新的集合去执行合并操作，这样毫无效率可言。在这种情况下，更适合使用Stream.collect方法。\nStream.collect 不像reduce方法每次处理元素都会创建一个新的值，collect方法是修改或者改变一个已经存在的值。\n思考一下你要怎样求出stream中元素的平均值。你需要的是元素总数和元素的总和。但是，像reduce方法和所有其他的reduction方法一样，collect方法也只能返回一个值。你可以创建一个新的数据类型包含追踪总数和总和的成员变量，就像下面的类Averager：\nimport java.util.function.IntConsumer;\rclass Averager implements IntConsumer {\rprivate int total = 0;\rprivate int count = 0;\rpublic double average() {\rreturn count \u0026gt; 0 ? (double) total / count : 0;\r}\r@Override\rpublic void accept(int value) {\rtotal += value;\rcount++;\r}\rpublic void combine(Averager that) {\rtotal += that.total;\rcount += that.count;\r}\r}\r 下面的例子使用Averager类和collect方法去获取所有男性的平均年龄：\nAverager averager = roster.stream()\r.filter(p -\u0026gt; p.getGender() == Person.Sex.MALE)\r.map(Person::getAge)\r.collect(Averager::new, Averager::accept, Averager::combine);\rdouble averageNum = averager.average();\r 这个例子中的collect有三个参数：\n supplier：它是一个工厂方法，构建一个新的实例。supplier为collect操作提供一个实例作为结果容器。在这个例子中，就是Averager类的实例。 accumulator：它将一个stream的成员合并到结果容器中。在这个例子中，它通过每次给count+1和给total加上当前流中的年龄数值来修改Averager`结果容器。 combiner：它代表了你要如何合并两个结果容器。在这个例子中，就是合并两个结果容器中的count和total。  注意事项：\n supplier是一个lambda表达式（或者一个方法引用），而不是像reduce操作中的identity元素。 accumulator和combiner方法都不返回值。 可以在并发流上使用collect操作，详情参考Parallelism 。如果你在并发流上运行collect方法，那么每当combiner方法创建一个新的对象，就像上面例子的Averager对象，JDK就会创建一个新的线程。因此，你不需要担心同步的问题。  虽然JDK已经提供了average操作计算流元素的平均值，但是如果你需要计算多个结果值的时候，可以通过collect和一个自定义类来获得。\ncollect操作完美适配集合。下面的例子展示了如何通过collect获取男性成员的所有名称集合：\nList\u0026lt;String\u0026gt; names = roster.stream()\r.filter(p -\u0026gt; p.getGender() == Person.Sex.MALE)\r.map(p -\u0026gt; p.getName())\r.collect(Collectors.toList());\r 上面的collect方法只有一个Collector参数。这个Collector方法内部其实就是封装了之前三个参数的collect方法。\nCollectors除了toList还封装了很多常用的reduction操作，比如累加元素到集合中和根据各种条件汇总元素。这些reduction操作返回Collector类的实例，所以你可以将他们作为collect操作的参数。\n上面例子中的Collectors.toList操作是将流中所有的元素添加到一个新的List中。像大多数Collectors中的操作一样，toList返回的是一个Collector的实例，而不是一个集合。\n下面的例子是根据roster的性别分组：\nMap\u0026lt;Person.Sex, List\u0026lt;Person\u0026gt;\u0026gt; byGender =\rroster\r.stream()\r.collect(\rCollectors.groupingBy(Person::getGender));\r groupingBy操作，根据参数中的lambda表达式分类，并将它作为结果Map的Key值。像这个例子中，Key值就是Person.Sex.Male和Person.Sex.Female。\n下面的例子检索流元素的所有名称，并根据性别分类：\nMap\u0026lt;Person.Sex, List\u0026lt;String\u0026gt;\u0026gt; namesByGender =\rroster\r.stream()\r.collect(\rCollectors.groupingBy(\rPerson::getGender, Collectors.mapping(\rPerson::getName,\rCollectors.toList())));\r 这个groupingBy操作有两个参数，一个分类方法和一个Collector实例。这个Collector参数叫做downstream collector。这个collector会在Java运行时应用到另外一个collector的结果上。因此这个groupingBy操作让你可以应用一个collect方法到由groupingBy操作创建的List值上。在这个例子中，应用了mapping collector，它将Person::getName方法应用到stream的每个元素上。隐私，结果会得到一个由成员名称组成的流。一个管道流包含一个或者多个downstream collectors，向上面例子这样，被叫做multilevel reduction。\n下面的例子检索每个性别的年龄总和：\nMap\u0026lt;Person.Sex, Integer\u0026gt; totalAgeByGender =\rroster\r.stream()\r.collect(\rCollectors.groupingBy(\rPerson::getGender,\rCollectors.reducing(\r0,\rPerson::getAge,\rInteger::sum)));\r 这个reducing操作有三个参数：\n identity：就像Stream.reduce操作中声明的一样，可以作为初始化值，或者流为空时的默认值。 mapper：reducing操作会将这个mapper应用到每个stream元素。在这个例子中，mapper就是为了检索所有的成员的年龄。 operation：这个操作方法是用来reduce由mapper处理的值的。在这个例子中，就是Integer的加法操作。  下面的例子检索每个性别的平均年龄：\nMap\u0026lt;Person.Sex, Double\u0026gt; averageAgeByGender = roster\r.stream()\r.collect(\rCollectors.groupingBy(\rPerson::getGender, Collectors.averagingInt(Person::getAge)));\r ","id":112,"section":"posts","summary":"Reduction 首先看一个例子： double average = roster .stream() .filter(p -\u0026gt; p.getGender() == Person.Sex.MALE) .mapToInt(Person::getAge) .average() .getAsDouble(); 像上面的例子一样，JDK还包含很多其他的终端操作（比如说average,sum,min,max,","tags":["java"],"title":"java8 lambda reduce\u0026collect","uri":"https://www.mingaccount.com/2017/09/lambda-reduce/","year":"2017"},{"content":"资源类 User\n@Data\rpublic User{\rprivate String name;\rprivate List\u0026lt;String\u0026gt; tags;\r}\r map\u0026amp;flatmap map将每个参数对象映射为返回类型，一个参数对应一个返回值\nList\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;();\r//...省略赋值\rList\u0026lt;String\u0026gt; userNames = userList.stream().map(user -\u0026gt; user.getName()).collect(Collectors.toList());\r flatMap将每个参数对象映射为返回类型，一个参数对应多个返回值\nList\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;();\r//...省略赋值\rSet\u0026lt;String\u0026gt; allUserTags = userList.stream().flatMap(user -\u0026gt; user.getTags().stream()).collect(Collectors.toSet());\r map和flatMap返回的都是一个Stream，不过一个Stream里面只有一个值，另一个Stream可能包含多个\n","id":113,"section":"posts","summary":"资源类 User @Data public User{ private String name; private List\u0026lt;String\u0026gt; tags; } map\u0026amp;flatmap map将每个参数对象映射为返回类型，一个参数对应一个返回值 List\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;(); //...省略赋值 List\u0026lt;String\u0026gt; userNames = userList.stream().map(user -\u0026gt; user.getName()).collect(Collectors.toList()); flatMa","tags":["java"],"title":"java lambda表达式map和flatMap","uri":"https://www.mingaccount.com/2017/09/map-and-flatmap/","year":"2017"},{"content":"纯数字 /^\\d+$/\r 小数 /^\\d*\\.\\d+$/\r 整数或者小数 /^\\d*(\\.\\d+)?$/\r 正负整数或者小数 /^-?\\d*(\\.\\d+)?$/\r 整数小数或者分数 /[-]?[0-9]+[,.]?[0-9]*([\\/][0-9]+[,.]?[0-9]*)*/\r 数字字母 /^[a-zA-Z0-9]*$/\r 单词 /^[a-zA-Z \\-]{1,50}$/\r MM/DD/YYYY 1900-2099\n兼容的分隔符：空格 - / .\n/^((0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2})*$/\r YYYY/MM/DD 1900-2099\n兼容的分隔符：空格 - / .\n#^((19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01]))*$#\r HH:mm:ss 24小时制\n/(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)/\r 手机号 /^1[3-9]\\d{9}$/\r 身份证 /(^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$)|(^[1-9]\\d{5}\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}$)/\r email /^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6})*$/\r masterCard /^(5[1-5][0-9]{14})*$/'\r visa /^(4[0-9]{12}(?:[0-9]{3})?)*$/\r 复杂八位密码 必须包含大写，小写，数字和特殊符号\n/(?=(.*[0-9]))(?=.*[\\!@#$%^\u0026amp;*()\\\\[\\]{}\\-_+=~`|:;\u0026quot;'\u0026lt;\u0026gt;,./?])(?=.*[a-z])(?=(.*[A-Z]))(?=(.*)).{8,}/  一般八位密码 必须包含大写，小写，数字\n/(?=(.*[0-9]))((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.{8,}$/\r 用户名 数字字母字符串，可能包含_和-，长度在3到16之间\n/^[a-z0-9_-]{3,16}$/\r IPv4 /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/  IPv6 /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/\r IPv4和IPv6 /((^\\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\\s*$)|(^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$))/\r URL /^(((http|https|ftp):\\/\\/)?([[a-zA-Z0-9]\\-\\.])+(\\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\\/+=%\u0026amp;_\\.~?\\-]*))*$/\r HTML标签 /\u0026lt;\\/?[\\w\\s]*\u0026gt;|\u0026lt;.+[\\W]\u0026gt;/\r 匹配字符串中的重复内容 /\u0026lt;\\/?[\\w\\s]*\u0026gt;|\u0026lt;.+[\\W]\u0026gt;/\r 匹配线上文件资源路径 /((\\/|\\\\|\\/\\/|https?:\\\\\\\\|https?:\\/\\/)[a-z0-9 _@\\-^!#$%\u0026amp;+={}.\\/\\\\\\[\\]]+)+\\.[a-z]+$/\r ","id":114,"section":"posts","summary":"纯数字 /^\\d+$/ 小数 /^\\d*\\.\\d+$/ 整数或者小数 /^\\d*(\\.\\d+)?$/ 正负整数或者小数 /^-?\\d*(\\.\\d+)?$/ 整数小数或者分数 /[-]?[0-9]+[,.]?[0-9]*([\\/][0-9]+[,.]?[0-9]*)*/ 数字字母 /^[a-zA-Z0-9]*$/ 单词 /^[a-zA-Z \\-]{1,50}$/ MM/DD/YYYY 1900-2099 兼容的分隔符：空格 - / . /^((0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2})*$/ YYYY/MM/DD 1900-2099 兼容的分隔符：空格 -","tags":["regexp"],"title":"常用正则表达式","uri":"https://www.mingaccount.com/2017/09/common-regexp/","year":"2017"},{"content":"问题背景 使用sql:\ncreate view test_view as\rselect a.column_1, b.column_2\rfrom (select column_1 from table_1) a\rleft join (select column_2 from table_2) b on a.column_1 = b.column_2\r 报错信息：\nView's SELECT contains a subquery in the FROM clause\r 问题原因 根据mysql官方文档，版本5.7之前都是不支持创建视图的from语句中有子查询的：\n The SELECT statement cannot contain a subquery in the FROM clause.\n 参考mysql 5.6 create view\n  从版本5.7开始不再有该限制。\n 参考mysql 5.7 create view\n ","id":115,"section":"posts","summary":"问题背景 使用sql: create view test_view as select a.column_1, b.column_2 from (select column_1 from table_1) a left join (select column_2 from table_2) b on a.column_1 = b.column_2 报错信息： View's SELECT contains a subquery in the FROM clause 问题原因 根据mysql官方文档，版本5.7之","tags":["mysql"],"title":"Mysql 创建视图报错：View's SELECT contains a subquery in the FROM clause","uri":"https://www.mingaccount.com/2017/09/mysql-create-view-exception/","year":"2017"},{"content":"1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成测试，那么将会极大的缩短测试时间。比如通过ORM框架访问数据库的时候，想确定sql的正确性，或者对象实例映射的正确性\n介绍Spring的测试框架，第一个就离不开org.springframework.test包，他对Spring容器集成测试有很大的价值，并且它不依赖于任何其他的部署环境或者应用服务。虽然他比纯粹的单元测试慢，但是比任何等同于Selenium的测试，或者需要依赖于部署应用服务的测试都快\nSpring TestContext框架是以注解为驱动支持单元和集成测试的。这个TestContext不管实际使用的是什么测试框架，在Junit，TestNG，以及其他测试框架环境中都能进行测试\n2. 集成测试的目标 Spring集成测试主要有下面几个主要目标：\n 在测试之间管理Spring IoC容器的缓存 为测试的资源实例提供依赖注入 提供适合集成测试的事务管理 提供Spring指定的基础类以帮助开发者写集成测试  接下来的子章节是对上面几个目标的详细描述\n2.1. 上下文管理和缓存 Spring TestContext框架提供了ApplicationContext实例和WebApplicationContext实例的一致性加载，以及这些上下文对象的缓存。支持缓存和加载这些上下文对象是非常重要的，因为启动时间是个很严重的问题，这个时间的消费并不是Spring容器自身消耗的，而是对象实例化需要时间。举个例子，一个项目有50到100个Hibernate的映射文件，那么将要花费10到20秒的时间去加载这些映射文件,如果每次测试都有这个花费，那么会拖慢整个测试进度，减少开发者的产出。\n典型的测试类申明要么是xml的资源位置数组或者Groovy的配置源数据（一般在classpath目录下），又或者是配置应用的成员类数组。这些位置或者类跟web.xml中的申明基本类似\n默认情况下，一旦加载，每次测试都复用的一个ApplicationContext。 因此，一个测试套件（test suite)只会有一次初始化应用的过程，每次子测试可以节省大量时间。这里说的测试套件(test suite)术语代表在一个JVM里面运行的所有测试-比如说，一个由Ant，Maven，或者Gradle构建的项目中运行的所有测试。在极少情况下，ApplicationContext会被污染需要重新加载（举个例子，通过修改bean的定义或者应用对象的状态）TestContext框架可以通过配置重载配置信息，并在执行下次测试之前重新构建ApplicationContext。下文中有详细操作。\n2.2. 测试资源的依赖注入 当TestContext框架加载你的ApplicationContext时，他可以通过依赖注入添加任意的配置到你的测试实例。他提供了一个简明的机制，通过ApplicationContext中的预配置bean来构建你测试所需要的资源环境。他的最大好处是每个测试场景都可以共用一个ApplicationContext，避免一次测试起一次环境\n现在假如我们有一个类HibernateTitleRepository，他实现了Title领域实体（domain entity)的数据访问逻辑。我们想写一个集成测试以测试下面几个方面：\n Spring的配置：所有HibernateTitleRepository相关的配置是否正确关联和展示？ Hibernate的映射文件配置：映射是否正确并且延迟加载的配置是否到位？ HibernateTitleRepository的逻辑：该类配置实例的运行是否符合预期？  依赖注入的详细内容后面会讲到\n2.3. 事务管理 在测试中访问真实数据库的一个常见问题是测试对持久性存储状态的影响。即使你使用的是开发数据库，更改状态也可能会影响到进一步的测试。还有许多操作例如插入或者修改持久数据，没有事务都是不能运行的\nTestContext框架解决了这个问题。默认情况下，框架会为每次测试创建和回滚事务。你可以在假定有事务的前提下写测试代码。如果你在测试中调用事务的代理对象，根据他们配置的事务语句，决定他们是否能正常运转。另外，如果一个测试方法在事务管理的范围内删除了选中表的内容，默认情况下事务会回滚，数据库会返回到执行测试之前的状态。为测试提供的事务支持是由PlatformTransactionManagerbean来提供的\n如果你想提交一个事务（一般来说不会，在你想填充或者修改数据库的时候有用），你可以通过TestContext框架来提交事务以代替使用@Commit注解的回滚\n详细内容后面会讲到\n2.4. 集成测试的支持类 TestContext框架提供了多个抽象支持类，他们简化了集成测试的编写。这些基础测试类为测试框架提供了定义明确的钩子和方便的实例参数和方法，他们能让你访问：\n ApplicationContext，用于执行显式的bean查找或者测试整个上下文的状态。 JdbcTemplate，用于执行sql表达式。你可以查询数据库相关应用代码执行前后的数据库状态，并且Spring确保这些查询都在同一个事务中。党和ORM框架配合使用时，需要确保避免false positives  另外你可能想创建你自定义的支持类，更多信息可以参考TestContext framework\n3. JDBC测试的支持 JDBC相关的工具方法在类JdbcTestUtils类中，他在org.springframework.test.jdbc包下。它简化了标准的数据库测试场景。JdbcTestUtils提供了以下静态的工具方法：\n countRowsInTable(..):计算指定表有多少行数据 countRowsInTableWhere(..):计算指定表有多少行数据通过提供的where条件进行限制 deleteFromTables(..):删除指定表的所有行 deleteFromTableWhere(..):删除指定表的数据行通过提供的where条件进行限制 dropTables(..):Drop指定表   AbstractTransactionalJUnit4SpringContextTests和AbstractTransactionalTestNGSpringContextTests代理了前面提及的JdbcTestUtils类的方法。\nspring-jdbc模块支持配置和启动一个集成的数据库，你可以用它进行集成测试。更多细节，参考Embedded Database Support 和 Testing Data Access Logic with an Embedded Database\n 4. 注解 这个章节介绍你在测试Spring应用时可以用的注解。它包含如下几个主题：\n Spring 测试注解 标准注解支持 Spring JUnit 4 测试注解 Spring JUnit Jupiter 测试注解 测试元注解  4.1. Spring 测试注解 Spring框架提供了如下Spring特有的注解，你可以使用他们在你的单元和集成测试中。查看他们对应的javadoc以查找更多信息，包括默认的属性值，属性别名，和其他细节。\nSpring测试注解包括：\n @BootstrapWith @ContextConfiguration @WebAppConfiguration @ContextHierarchy @ActiveProfiles @TestPropertySource @DynamicPropertySource @DirtiesContext @TestExecutionListeners @Commit @Rollback @BeforeTransaction @AfterTransaction @Sql @SqlConfig @SqlMergeMode @SqlGroup  @BoostrapWith @BootstrapWith是一个类级别的注解，你可以使用它配置Spring TestContext框架是怎样引导启动的。具体可以使用@BootstrapWith去指定一个自定的TestContextBootstrapper。查看bootstrapping the TestContext framework 以获取详细信息\n@ContextConfiguration @ContextConfiguration 定义类级别的源数据，常用来决定集成测试如何加载和配置一个ApplicationContext。具体的，可以使用@ContextConfiguration声明应用上下文的资源位置，或者用于加载上下文的组件类\n资源位置，一般来说就是在classpath路径下的XML的配置文件或者Groovy的脚本，而组件类一般来说是@Configuration注解的类。但是，资源位置可以引用文件系统中的文件和脚本，并且组件类可以是@Component类，@Service类，其他等等。更多参照Component Classes\n下面的例子@ContextConfiguration注解指向了一个XML文件：\n@ContextConfiguration(\u0026quot;/test-config.xml\u0026quot;)\rclass XmlApplicationContextTests{}\r 下面的例子@ContextConfiguration指向一个类：\n@ContextConfiguration(classes = TestConfig.class)\rclass ConfigClassApplicationContextTests{}\r 另外还可以使用@ContextConfiguration声明ApplicationContextInitializer类，这种方法也可以声明资源位置和组件类：\n@ContextConfiguration(initializers = CustomContextIntializer.class)\rclass ContextInitializerTests{}\r 你也可以选择ContextConfiguration申明ContextLoader的方式也行。注意，你通常不需要显式的配置loader，因为默认的loader支持initializers和资源位置或组件类。\n下面的例子同时声明了一个资源位置和一个loader:\n@ContextConfiguration(locations=\u0026quot;/test-context.xml\u0026quot;,loader=CustomContextLoader.class)\rclass CustomLoaderXmlApplicationContextTests{}\r  @ContextConfigurtion对继承资源位置或者配置类提供了支持，还有由父类或者封闭类声明的context initializers\n 详情参考 Context Management ,@Nested test class configuration 以及@ContextConfiguration的API文档\n@WebAppConfiguration @WebAppConfiguration是一个类级别的注解，它能将为集成测试声明的ApplicationContext指定为WebApplicationContext。WebAppConfiguration注解仅仅在测试类上存在，为确保WebApplicationContext是为测试加载，使用默认值file:src/main/webapp作为web应用的根路径（资源仓库路径）。资源仓库路径用于在后台创建MockServletContext，它被用作WebApplicationContext的ServletContext\n下面是如何使用@WebAppConfiguration注解：\n@ContextConfiguration\r@WebAppConfiguration\rclass WebAppTests{}\r 如果你的资源仓库路径不是默认的file:src/main/webapp，你可以指定你自己的资源仓库路径，使用默认的value属性。可以支持classpath:和file:资源前缀。如果没有提供资源前缀，这个路径会被假定位文件系统资源。下面的例子展示了怎样指定一个classpath资源：\n@ContextConfiguration\r@WebAppConfiguration(\u0026quot;classpath:test-web-resources\u0026quot;)\rclass WebAppTests{}\r 注意WebAppConfiguration必须与ContextConfiguration配合使用，不管在单个测试类还是一个测试类的层次结构中。详情参考@WebAppConfiguration API文档\n@ContextHierarchy 它是一个类级别的注解，为集成测试定义ApplicationContext实例的层次结构。@ContextHierarchy应该由一个@ContextConfiguration的实例集合来申明，其中每一个都定义context层级关系中的一级。下面的例子展示了@ContextHierarchy在单个测试类中的的使用（它也可以用在一个测试类的层次结构中）\n@ContextHierarchy({\r@ContextConfiguration(\u0026quot;/parent-config.xml\u0026quot;),\r@ContextConfiguration(\u0026quot;/child-config.xml\u0026quot;)\r})\rclass ContextHierarchyTests{}\r @WebAppConfiguration\r@ContextHierarchy({\r@ContextConfiguration(classes = AppConfig.class),\r@ContextConfiguration(classes = WebConfig.class)\r})\rclass WebIntegrationTests{}\r 如果你需要在测试类的层次结构中对指定层级的配置进行合并或者重写，那么需要一个别名值来对应层级，在设置@ContextHierarchy的每个@ContextConfiguration层级时，需要给他们指明参数name的值。详情参考Context Hierarchies 和@ContextHierarchy api文档\n@ActiveProfiles 它是类级别的注解，当为继承测试加载ApplicationContext时用来声明启用哪些bean定义配置文件\n下面的例子表示启用了dev配置文件：\n@ContextConfiguration\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\rclass DeveloperTests{}\r 下面的例子表示dev和integration配置文件都应该启用：\n@ContextConfiguration\r@ActiveProfiles({\u0026quot;dev\u0026quot;,\u0026quot;integration\u0026quot;})\rclass DeveloperIntegrationTests{}\r  默认情况下@ActiveProfiles是支持继承父类或者封闭类的配置信息的。你可以完全自定义解析激活配置文件通过实现ActiveProfilesResolver，并使用@ActiveProfiles的属性resolver来注册。\n 详情参考Context Configuration with Environment Profiles ,@Nested test class configuration ,以及@ActiveProfiles\n@TestPropertySource 它是一个类级别的注解，你可以使用它来配置属性文件和内联属性的位置，最后添加到PropertySources集合中，这个集合在ApplicationContext的Environment中。\n下面的例子展示了怎样声明一个来自classpath的属性文件:\n@ContextConfiguration\r@TestPropertySource(\u0026quot;/test.properties\u0026quot;)\rclass MyIntegrationTests{}\r 下面的例子展示怎样声明内联属性：\n@ContextConfiguraiton\r@TestPropertySource(properties = {\u0026quot;timezone = GMT\u0026quot;, \u0026quot;port: 4242\u0026quot;})\rclass MyIntegrationTests{}\r 详情参考Context Configuration with Test Property Sources\n@DynamicPropertySource 它是一个方法级别的注解，他可以注册动态属性，跟@TestPropertySource一样，也是添加到PropertySources集合中。当你不能提前判断属性值时，可以通过动态属性来设置-举个例子，如果属性是交由外部资源管理的，比如通过TestContainers 来进行的容器管理。\n下面的例子展示了如何注册一个动态属性：\n@ContextConfiguration\rclass MyIntegrationTests{\rstatic MyExternalServer server = // ...\r@DynamicPropertySource\rstatic void dynamicProperties(DynamicPropertyRegistry registry){\rregistry.add(\u0026quot;server.port\u0026quot;,server::getPort);\r}\r}\r 详情参考Context Configuration with Dynamic Property Sources\n@DirtiesContext 这个注解表示底层的SpringApplicationContext在执行测试的时候被污染了（意思就是，测试的时候以某种方式修改或者污染了ApplicationContext-比如说，改变单例bean的状态），并且需要关闭这个context。当一个应用上下文被dirty标记，会被测试框架从缓存中移除并关闭。在最后，如果还有其他测试需要这个context，Spring容器会重新构建。\n你可以使用该注解在类级别或者方法级别，在同一个类中或者类的层次结构中。你可以标记ApplicationContext是在方法前后还是在类前后被污染的，通过methodMode和classMode来配置。\n下面的例子展示了几个不同场景的使用方案：\n 在当前的测试类之前，通过声明classMode为BEFORE_CLASS  @DirtiesContext(classMode = BEFORE_CLASS)\rclass FetchContextTests{}\r  在当前的测试类之后，通过声明classMode为AFTER_CLASS(默认的classMode)  @DirtiesContext\rclass FetchContextTests{}\r  在当前测试类的每个测试方法之前，通过声明classMode为BEFORE_EACH_TEST_METHOD  @DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD)\rclass FreshContextTests{\r}\r  在当前测试类的每个测试方法执行后，通过声明classMode为AFTER_EACH_TEST_METHOD  @DirtiesContext(classMode = AFTER_EACH_TEST_METHOD)\rclass ContextDirtyingTests{}\r  在当前测试之前，通过在方法上申明methodMode为BEFORE_METHOD  @Test\r@DirtiesContext(methodMode = BEFORE_METHOD)\rvoid testProcessWhichRequiresFreshAppCtx(){}\r  在当前测试之后，通过在方法上声明methodMode为AFTER_METHOD(默认的方法模式)  @DirtiesContext\r@Test\rvoid testProcessWhichDirtiesAppCtx(){}\r 如果@DirtiesContext注解修饰的测试context，是@ContextHierarchy注解层次结构中的一部分，你可以使用hierarchyMode属性去控制context缓存如何清除。默认情况下，一个详尽的算法会用来清除context缓存，包括的不仅是当前层级，还有所有其他共享了同一个父类context的子层级，子层级的所有ApplicationContext实例都会从缓存中移除并关闭。在某些情况下，如果你觉得默认的算法清楚的范围太广，你可以指定更简单的当前层级算法：\n@ContextHierarchy({\r@ContextConfiguration(\u0026quot;/parent-config.xml\u0026quot;),\r@ContextConfiguration(\u0026quot;/child-config.xml\u0026quot;)\r})\rclass BaseTest{}\rclass ExtendedTests extends BaseTest{\r@Test\r@DirtiesContext(hierarchyMode=CURRENT_LEVEL)\rvoid test(){}\r}\r 更多关于EXHAUSTIVE和CURRENT_LEVEL算法的问题，可以参考DirtiesContext.HierarchyMode\n@TestExecutionListeners 它定义了用来配置TestExecutionListener实现的类级别元数据(TestExecutionListener实现是由TestContextManager来注册的)。一般来说都是配合@ContextConfiguration来使用。\n下面的例子展示了如何注册两个TestExecutionListener实现\n@ContextConfiguration\r@TestExecutionListeners({CustonTestExecutionListener.class,AnotherTestExecutionListerner.class})\rclass CustomTestExecutionListenerTests {}\r 默认情况下，@TestExecutionListeners是支持从父类继承的，或者内部类从外部封闭类继承。详情参考@Nested test class configuration 和@TestExecutionListeners javadoc\n@Commit @Commit代表测试方法的事务会在测试方法完成后提交。你可以将@Commit替换为@Rollback(false)。@Commit和@Rollback相似，都可以声明在类或方法上。\n使用实例：\n@Commit\r@Test\rvoid testProcessWithoutRollback(){\r}\r @Rollback @Rollback代表测试方法执行完后，是否回滚事务。为true则回滚，否则事务会提交（跟@Commit一样）。该注解的默认值为true，就算没有声明该注解，事务默认也会回滚。\n当申明在类上时，@Rollback注解将会影响类的所有测试方法，当申明在方法时，只会影响指定方法，并会覆盖类上的全局@Rollback或@Commit配置\n使用实例：\n@Test\r@Rollback(false)\rvoid testProcessWithoutRollback(){\r}\r @BeforeTransaction 它代表注解的void方法应该在事务启动之前运行，对测试方法来说，它已经被配置好了在一个事务中运行，是通过使用Spring的@Transactional注解来实现的。@BeforeTransaction方法是不需要public修饰的，并且可以声明在java8的接口默认方法上。\n使用实例：\n@BeforeTransaction\rvoid beforeTransaction(){}\r @AfterTransaction 它代表注解的void方法应该在事务结束后运行，对测试方法来说，它已经被配置好了在一个事务中运行，是通过使用Spring的@Transactional注解来实现的。@AfterTransaction方法是不需要public修饰的，并且可以声明在java8的接口默认方法上。\n@AfterTransaction\rvoid afterTransaction(){}\r @Sql 它是用来配置测试类或者方法需要的sql脚本的。\n@Test\r@Sql({\u0026quot;/test-schema.sql\u0026quot;,\u0026quot;/test-user-data.sql\u0026quot;})\rvoid userTest(){}\r 详情参考Executing SQL scripts declaratively with @Sql\n@SqlConfig 它用来配置如何解析和执行@Sql注解配置的脚本。\n@Test\r@Sql(\rscripts = \u0026quot;/test-user-data.sql\u0026quot;,\rconfig = @SqlConfig(commentPrefix = \u0026quot;`\u0026quot;, separator = \u0026quot;@@\u0026quot;)\r)\rvoid userTest(){}\r @SqlMergeMode 它是用来设置@Sql注解的方法和类的sql脚本是否融合在一起。如果类和方法上都没有@SqlMergeMode注解，那么默认的OVERRIDE模式将会被使用。在OVERRIDE模式下，方法上声明的@Sql会覆盖掉类上的@Sql声明。\n注意方法上的@SqlMergeMode声明会覆盖类上的声明。\n作用在类上：\n@SpringJunitConfig(TestConfig.class)\r@Sql(\u0026quot;/test-schema.sql\u0026quot;)\r@SqlMergeMode\rclass UserTests{\r@Test\r@Sql(\u0026quot;/user-test-data-001.sql\u0026quot;)\rvoid standardUserProfile(){\r}\r}\r 作用在方法上：\n@SpringJUnitConfig(TestConfig.class)\r@Sql(\u0026quot;/test-schema.sql\u0026quot;)\rclass UserTests{\r@Test\r@Sql(\u0026quot;/user-test-data-001.sql\u0026quot;)\r@SqlMergeMode(MERGE)\rvoid standardUserProfile(){}\r}\r @SqlGroup 它是一个容器注解，内部集成了多个@Sql注解。你可以使用@SqlGroup直接声明多个集成的@Sql，或者你可以配合java8对重复注解的支持来使用，@Sql可以在同一个类和方法上声明多次，隐式的生成注解容器。\n@Test\r@SqlGroup({\r@Sql(scripts = \u0026quot;/test-schema.sql\u0026quot;,config = @SqlConfig(commentPrefix = \u0026quot;`\u0026quot;)),\r@Sql(\u0026quot;/test-user-data.sql\u0026quot;)\r})\rvoid userTest(){}\r 4.2. 标准注解支持 下面的注解在任何配置的Spring TestContext框架的标准语法中都支持。注意这些注解并不是专门用来测试的，在Spring框架的任何地方都可以使用。\n @Autowired @Qualifier @Value @Resource(javax.annotation)如果JSR-250存在 @ManagedBean(javax.annotation)如果JSR-250存在 @Inject(javax.inject)如果JSR-330存在 @Named(javax.inject)如果JSR-330存在 @PersistenceContext(javax.persistence)如果JPA存在 @PersistenceUnit(javax.persistence)如果JPA存在 @Required @Transactional(org.springframework.transaction.annotation)部分属性支持   JSR-250生命周期注解\n在Spring TestContext框架中，你可以在ApplicationContext内部配置的任何应用组件上以标准语法使用@PostConstruct和@PreDestroy。但是在实际测试类中，这些生命周期注解还是有使用限制的。\n如果一个方法在测试类中，并且被注解@PostConstruct修饰，那么这个方法会在底层测试框架的所有before方法之前执行（举个例子，任何被JUnit Jupiter的@BeforeEach注解修饰的方法），并且他会被应用在测试类中的每个测试方法上。另一方面，如果一个方法在测试类中被@PreDestroy注解修饰，那么这个方法永远不会运行。所以，在一个测试类中，我们推荐使用来自测试框架的生命周期的回调函数，而不是@PostConstruct和@PreDestroy。\n 4.3. Spring JUnit 4 测试注解 下面的注解仅在与 SpringRunner ，Spring\u0026rsquo;s JUnit 4 rules ,或者Spring’s JUnit 4 support classes 配合使用时才有效：\n @IfProfileValue @ProfileValueSourceConfiguration @Timed @Repeat  IfProfileValue 它代表注解修饰的测试只在指定测试环境生效。如果ProfileValueSource的属性value跟name的值匹配，这个测试才生效。否则，这个测试不会启用。\n你可以声明IfProfileValue在类或者方法上。类级别的使用优先于方法级别的使用，特别是针对类下的所有方法或者所有子类的时候。要启用一个测试，他的类和方法都要是启用状态，但是在默认没有声明IfProfileValue的情况下，就代表着启用状态。JUnit4的@Ignore注解跟它类似，除了@Ignore只能用来屏蔽测试。\n使用实例：\n@IfProfileValue(name = \u0026quot;java.vendor\u0026quot;, value=\u0026quot;Oracle Corporation\u0026quot;)\r@Test\rpublic void testProcessWithRunsOnlyOnOracleJvm(){}\r 另外，你可以为@IfProfileValue配置一个values集合，就像TestNG在JUnit4环境支持测试组一样：\n@Test\r@IfProfileValue(name = \u0026quot;test-groups\u0026quot;, values={\u0026quot;unit-tests\u0026quot;,\u0026quot;integration-tests\u0026quot;})\rpublic void testProcessWhichRunsForUnitOrIntegrationTestGroups(){}\r @ProfileValueSourceConfiguration 它是一个类级别的注解，它指定了当通过@IfProfileValue注解检索配置值的时候该使用什么类型的ProfileValueSource。如果该注解没有在测试上声明，SystemProfileValueSource会被作为默认值。\n使用实例：\n@Test\r@ProfileValueSourceConfiguration(CustomProfileValueSource.class)\rpublic class CustomProfileValueSourceTests(){}\r @Timed @Timed代表备注接的测试方法必须在指定的时间段内完成（微秒）。如果测试时间超过了指定的时间段，则测试失败。\n这个时间段包括运行测试方法自身的时间，以及重复测试的时间（@Repeat)，也包括其他测试资源的安装和卸载时间。\n@Timed(millis = 1000)\rpublic void testProcessWithOneSecondTimeout(){\r}\r Spring的@Timed语法跟JUnit4的语法@Test(timeout=...)不同，是因为JUnit4处理测试执行超时的处理方式（在单独的一个分支执行测试方法），如果测试超时@Test(timeout=...)会立即让测试失败。但Spring的@Timed不同，在标识失败之前，他会让测试方法先走完。\n@Repeat 它代表注解的测试方法必定会重复执行。重复执行的次数需要指定在注解参数中\n除了重复执行测试方法本身，测试资源的安装和卸载也会被重复执行。\n@Repeat(10)\r@Test\rpublic void testProcessRepeatedly(){}\r 4.4. Spring JUnit Jupiter 测试注解 下面的注解只在配合SpringExtension和JUnit Jupiter(也就是JUnit5的编程模型)使用时才可用\n @SpringJUnitConfig @SpringJUnitWebConfig @TestConstructor @NestedTestConfiguration @EnabledIf @DisabledIf  @SpringJUnitConfig 它是一个集成的注解，他是由来自JUnit Jupiter的@ExtendWith(SpringExtension.class)和来自Spring TestContext框架的@ContextConfiguration组成的。他可以作用在类上以替代@ContextConfiguration。关于配置选项，@ContextConfiguration和@SpringJUnitConfig唯一的区别是在@SpringJUnitConfig可以用value属性声明组件类。\n下面的例子展示了如何使用@SpringJUnitConfig注解指定一个配置类：\n@SpringJUnitConfig(TestConfig.class)\rclass ConfigurationClassJUnitJupiterSpringTests{\r}\r 下面的例子展示了如何使用@SpringJUnitConfig注解指定一个配置文件的位置：\n@SpringJUnitConfig(locations = \u0026quot;/test-config.xml\u0026quot;)\rclass XmlJUnitJupiterSpringTests{\r}\r 详情参考Context Management 和@SpringJUnitConfig ，@ContextConfiguration的API文档\n@SpringJUnitWebConfig 它是一个复合注解，是由来自JUnit Jupiter的@ExtendWith(SprintExtension.class)与来自Spring TestContext框架的ContextConfiguration、@WebAppConfiguration构成。你可以将他申明在类上，它可以用来代替@ContextConfiguration和@WebAppConfiguration。关于配置选项，@ContextConfiguration和@SpringJUnitWebConfig的唯一区别是@SpringJUnitWebConfig可以使用value属性来声明组件类。另外你可以覆盖@WebAppConfiguration的value属性，通过@SpringJUnitWebConfig的resourcePath属性。\n下面的例子展示了如何指定一个配置类：\n@SpringJUnitWebConfig(TestConfig.class)\rclass ConfigurationClassJUnitJupiterSpringWebTests{}\r 下面的例子展示了如何指定一个配置文件的路径：\n@SpringJUnitWebConfig(locations = \u0026quot;/test-config.xml\u0026quot;)\rclass XmlJUnitJupiterSpringWebTests{}\r 详情参考Context Management 和@SpringJUnitWebConfig ，@ContextConfiguration ，@WebAppConfiguration\nTestConstructor 它是一个类级别的注解，用来配置如何将测试的ApplicationContext组件参数装配到测试类构造方法的参数中。\n如果@TestConstructor不存在，那么会有一个默认的装配模式被使用。下面的提示展示了如何改变默认模式。注意，如果构造器上有一个@Autowired注解，那么@TestConstructor和默认模式都会被覆盖。\n 改变测试构造方法的默认装配模式 要改变默认的装配模式可以通过设置spring.test.constructor.autowire.modeJVM 系统属性为all。还可以通过设置SpringProperties机制来完成。\n从Spring Framework 5.3开始，默认模式可以设置为一个JUnit Platform configuration parameter\n如果spring.test.constructor.autowire.mode属性没有设置，那么测试类的构造函数将不会自动装配\n  从Spring Framework 5.2开始，在使用JUnit Jupiter时TestConstructor只能和SpringExtension配合使用。注意在大多数境况下，SpringExtension已经为你自动注册完成了-比如在用了@SpringJUnitConfig和@SpringJUnitWebConfig或者各种来自Spring Boot测试相关的注解时\n @NestedTestConfiguration 它是一个类级别的注解，被用来设置Spring测试配置注解如何在内部测试类中运行。\n如果它没有在测试类显性申明，在他的父类结构，或者在他的封闭类结构中，默认的封闭配置继承模型会被使用。下面的提示展示如何修改默认模式。\n 改变默认的封闭配置继承模式\n默认的封闭配置继承模式是INHERIT，要改变默认的模式可以通过设置spring.test.enclosing.configurationJVM系统属性为OVERRIDE.还可以通过SpringProperties机制来改变\n 支持@NestedTestConfiguration语法的Spring测试框架注解：\n @BootstrapWith @ContextConfiguration @WebAppConfiguration @ContextHierarchy @ActiveProfiles @TestPropertySource @DiritesContext @TestExecutionListeners @Transactional @Commit @Rollback @Sql @SqlConfig @SqlMergeMode @TestContructor   通常情况下@NestedTestConfiguration注解需要和@Nested注解结合使用在JUnit Jupiter中才有意义；但是可能有其他Spring支持的测试框架和继承测试类使用了该注解。\n 详情参考@Nested test class configuration \n@EnabledIf 它表示它修饰的JUnit Jupiter类或者测试方法是否启用，由提供的expression结果决定。具体来说，如果一个表达式的计算结果是Boolean.TRUE或者一个Stringequal为true(忽略大小写)，这个测试就是启用的。当应用于类级别时，所有在该类中的测试方法都会默认启用。\n以下的表达式都可用：\n Spring Expression Language 。举个例子：@EnabledIf(\u0026quot;#{systemProperties\\['os.name'].toLowerCase().contains('mac')}\u0026quot;) Spring Environment 中可用的属性占位符。举个例子：@EnabledIf(\u0026quot;${smoke.tests.enabled}\u0026quot;) 文本。比如：@EnabledIf(\u0026quot;true\u0026quot;)  注意文本表达式如果不是动态的属性占位符的解析结果，那将没有任何意义，因为@EnableIf(\u0026quot;false\u0026quot;)等于@Disabled，并且@EnabledIf(\u0026quot;true\u0026quot;)也没有任何意义。\n你可以将@EnabledIf作为一个元注解去创建自定义的复合注解。比如，你可以创建一个自定义的@EnabledOnMac注解：\n@Target({ElementType.TYPE, ElementType.METHOD})\r@Retention(RetentionPolicy.RUNTIME)\r@EnabledIf(\rexpression = \u0026quot;#{systemProperties['os.name'].toLowerCase().contains('mac')}\u0026quot;,\rreason = \u0026quot;Enabled on Mac OS\u0026quot;\r)\rpublic @interface EnabledOnMac{}\r @DisabledIf 它表示它修饰的JUnit Jupiter类或者测试方法是否弃用，由提供的expression结果决定。具体来说，如果一个表达式的计算结果是Boolean.TRUE或者一个Stringequal为true(忽略大小写)，这个测试就是弃用的。当应用于类级别时，所有在该类中的测试方法都会默认弃用。\n以下的表达式都可用：\n Spring Expression Language 。举个例子：@DisabledIf(\u0026quot;#{systemProperties\\['os.name'].toLowerCase().contains('mac')}\u0026quot;) Spring Environment 中可用的属性占位符。举个例子：@DisabledIf(\u0026quot;${smoke.tests.enabled}\u0026quot;) 文本。比如：@DisabledIf(\u0026quot;true\u0026quot;)  注意文本表达式如果不是动态的属性占位符的解析结果，那将没有任何意义，因为@DisabledIf(\u0026quot;true\u0026quot;)等于@Disabled，并且@EnabledIf(\u0026quot;false\u0026quot;)也没有任何意义。\n你可以将@DisabledIf作为一个元注解去创建自定义的复合注解。比如，你可以创建一个自定义的@DisabledOnMac注解：\n@Target({ElementType.TYPE, ElementType.METHOD})\r@Retention(RetentionPolicy.RUNTIME)\r@DisabledIf(\rexpression = \u0026quot;#{systemProperties['os.name'].toLowerCase().contains('mac')}\u0026quot;,\rreason = \u0026quot;Disabled on Mac OS\u0026quot;\r)\rpublic @interface DisabledOnMac {}\r 4.5. 测试元注解 你可以使用大多数测试相关的注解作为元注解去创建自定义的复合注解，那样可以减少测试套件的重复配置。\n你可以使用下面任何一个注解作为元注解：\n @BootstrapWith @ContextConfiguration @ContextHierarchy @ActiveProfiles @TestPropertySource @DirtiesContext @WebAppConfiguration @TestExecutionListeners @Transactional @BeforeTransaction @AfterTransaction @Commit @Rollback @Sql @SqlConfig @SqlMergeMode @SqlGroup @Repeat (only supported on JUnit 4) @Timed (only supported on JUnit 4) @IfProfileValue (only supported on JUnit 4) @ProfileValueSourceConfiguration (only supported on JUnit 4) @SpringJUnitConfig (only supported on JUnit Jupiter) @SpringJUnitWebConfig (only supported on JUnit Jupiter) @TestConstructor (only supported on JUnit Jupiter) @NestedTestConfiguration (only supported on JUnit Jupiter) @EnabledIf (only supported on JUnit Jupiter) @DisabledIf (only supported on JUnit Jupiter)  考虑下面的例子：\n@RunWith(SpringRunner.class)\r@ContextConfiguration({\u0026quot;/app-config.xml\u0026quot;,\u0026quot;/test-data-access-config.xml\u0026quot;})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\r@Transactional\rpublic class OrderRepositoryTests{}\r@RunWith(SpringRunner.class)\r@ContextConfiguration({\u0026quot;/app-config.xml\u0026quot;, \u0026quot;/test-data-access-config.xml\u0026quot;})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\r@Transactional\rpublic class UserRepositoryTests{}\r 观察上面的Spring测试注解配置基本都是重复的，可以通过自定义注解合并他们：\n@Target(ElementType.TYPE)\r@Retention(RetentionPolicy.RUNTIME)\r@ContextConfiguration({\u0026quot;/app-config.xml\u0026quot;, \u0026quot;/test-data-access-config.xml\u0026quot;})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\r@Transactional\rpublic @interface TransactionalDevTestConfig {}\r 然后你就可以直接使用这个自定义注解去简化JUnit4为基础的测试类：\n@RunWith(SpringRunner.class)\r@TransactionalDevTestConfig\rpublic class OrderRepositoryTests{}\r@RunWith(SpringRunner.class)\r@TransactionalDevTestConfig\rpublic class UserRepositoryTests {}\r 如果我们使用JUnit Jupiter进行测试类编写，那么可以进一步减少重复代码，因为JUnit 5的注解同样可以作为元注解：\n@ExtendWith(SpringExtension.class)\r@ContextConfiguration({\u0026quot;/app-config.xml\u0026quot;, \u0026quot;/test-data-access-config.xml\u0026quot;})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\r@Transactional\rclass OrderRepositoryTest{}\r@ExtendWith(SpringExtension.class)\r@ContextConfiguration({\u0026quot;/app-config.xml\u0026quot;, \u0026quot;/test-data-access-config.xml\u0026quot;})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\r@Transactional\rclass UserRepositoryTests{}\r 观察上面的Spring测试注解配置基本都是重复的，可以通过自定义注解合并他们：\n@Target(ElementType.TYPE)\r@Retention(RetentionPolicy.RUNTIME)\r@ExtendWith(SpringExtension.class)\r@ContextConfiguration({\u0026quot;/app-config.xml\u0026quot;, \u0026quot;/test-data-access-config.xml\u0026quot;})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\r@Transactional\rpublic @interface TransactionalDevTestConfig { }\r 然后你就可以直接使用这个自定义注解去简化JUnit5为基础的测试类：\n@TransactionalDevTestConfig\rclass OrderRepositoryTests { }\r@TransactionalDevTestConfig\rclass UserRepositoryTests { }\r 因为JUnit Jupiter支持@Test,@RepeatedTest,ParameterizedTest等等作为源注解，所以你也可以创建基于方法级别的自定义复合注解，比如我们创建一个注解它结合了来自JUnit Jupiter的@Test，@Tag和来自Spring的@Transactional：\n@Target(ElementType.METHOD)\r@Retention(RetentionPolicy.RUNTIME)\r@Transactional\r@Tag(\u0026quot;integration-test\u0026quot;) // org.junit.jupiter.api.Tag\r@Test // org.junit.jupiter.api.Test\rpublic @interface TransactionalIntegrationTest {\r}\r 然后我们可以在任何JUnit Jupiter测试方法上使用它们：\n@TransactionalIntegrationTest\rvoid saveOrder() { }\r@TransactionalIntegrationTest\rvoid deleteOrder() { }\r 详情参考Spring Annotation Programming Model\n5. Spring TestContext Framework Spring TestContext Framework(在org.springframework.test.context包下)，提供了通用的，注解驱动的单元和集成测试，并且不跟你的测试框架耦合。TestContext framework更看重约定而不是配置，有合理的默认值，并且你可以通过注解参数来修改它。\n另外对于常见的测试架构：JUnit 4，JUnit Jupiter(JUnit 5)，和TestNG，TestContext framework提供了特定的支持。对于JUnit4和TestNG，spring提供了abstract支持类。此外，Spring为JUnit4提供了自定义JUnitRunner和自定义JUnitRules，并且为JUnit Jupiter提供了自定义的Extension，它们可以让你编写所谓的POJO测试类。POJO测试类就是测试类不需要继承一个特定的类结构，比如abstarct父类。\n下面的章节提供了一个TestContext framework的概览。如果你只对使用框架有兴趣，对扩展自定义监听或者自定义加载器不感兴趣的话，可以直接跳过这个章节。\n5.1. 关键抽象概念 框架的核心是由TestContextManager、TestContext、TestExecutionListener、和SmartContextLoader接口组成。每个测试类都会创建一个TestContextManager。反过来，TestContextManger管理着一个TestContext，这个TestContext保存着当前测试的上下文参数。在测试进行中TestContextManger同时也更新TestContext的状态，并且委托给TestExecutionListener的实现，它会通过依赖注入来检测实际测试的运行，管理事务等等。一个SmartContextLoader负责为一个给定的测试类加载ApplicationContext。详情参考javadoc\nTestContext TestContext封装了测试运行所在的上下文（忽略具体的测试框架）并为其所负责的测试实例提供上下文管理和缓存支持。TestContext还能委托SmarkContextLoader去加载ApplicationContext。\nTestContextManager TestContextManger是Spring TestContext Framework的主要切入点，它负责管理一个单独的TestContext并且给每个已经注册的TestExcutionListener在以下定义良好的测试执行点发送信号：\n 在任何\u0026quot;before class\u0026quot;或者\u0026quot;before all\u0026quot;方法之前 测试实例的后期处理 在任何\u0026quot;before\u0026quot;或者\u0026quot;before each\u0026quot;方法之前 在测试方法执行之前但在测试初始化之后 在测试方法执行之后但在测试销毁之前 在任何\u0026quot;after\u0026quot;或者\u0026quot;after each\u0026quot;方法执行之后 在任何\u0026quot;after class\u0026quot;或者\u0026quot;after all\u0026quot;方法执行之后  TestExecutionListener TestExecutionListener定义了一系列测试监听API，它们又TestContextManager注册和发布。详情参考TestExecutionListener Configuration\nContextLoaders ContextLoaders是一个策略接口为一个Spring TestContext Framework管理的集成测试加载一个ApplicationContext。要提供组件类，激活bean定义配置，测试属性资源，上下文结构，和WebApplicationContext的支持你应该实现SmartContextLoader而不是这个接口。\nSmartContextLoader是ContextLoader接口的扩展，它接替了原始ContextLoader极少的SPI。具体来说，一个SmartContextLoader可以选择去处理资源位置，组件类，或者上下文初始化。其次，一个SmartContextLoader可以设置启用bean定义配置和上下文加载的测试属性资源。\nSpring提供了下面的实现：\n DelegatingSmartContextLoader：两个默认加载器之一，它委托给内部的一个AnnotationConfigContextLoader，一个GenericXmlContextLoader，或者一个GenericGroovyXmlContextLoader，取决于测试类的配置声明，或者存在的默认位置或者默认配置类。Groovy支持只在classpath目录下有Groovy时才可用。 WebDelegatingSmartContextLoader:两个默认加载器之一,它委托给内部的一个AnnotationConfigWebContextLoader，一个GenericXmlWebContextLoader，或者一个GenericGroovyXmlWebContextLoader，取决于测试类的配置声明，或者存在的默认位置或者默认配置类。只有在测试类上有@WebAppConfiguration存在时，才能使用webContextLoader。Groovy支持只在classpath目录下有Groovy时才可用。 AnnotationConfigContextLoader:用组件类加载一个标准的ApplicationContext AnnotationConfigWebContextLoader:用组件类加载一个WebApplicationContext GenericGroovyXmlContextLoader:用Groovy脚本或者XML配置文件加载一个标准的ApplicationContext GenericGroovyXmlWebContextLoader:用Groovy脚本或者XML配置文件加载一个WebApplicationContext GenericXmlContextLoader:用XML资源地址加载一个标准的ApplicationContext GenericXmlWebContextLoader:用XML资源地址加载一个WepApplicationContext  5.2. 引导TestContext Framework Spring TestContext Framework内部的默认配置对于一般的使用情况已经足够了。但是，有时开发团队或者第三方框架想改变默认的ContextLoader，实现自定义的TestContext或者ContextCache，增加默认的ContextCustomizerFactory和TestExecutionListener实现集合等等操作。对于这种对TestContext 框架操作的底层的控制，Spring提供了一个引导策略。\nTestContextBootstrapper为TestContext框架定义了SPI。一个TestContextBootstrapper通过TextContextManager被用来为当前测试加载TestExecutionListener实现和构建他管理的TestContext。你可以通过@BootstrapWith为测试类（或者测试类结构）配置一个自定义的引导策略，可以直接使用@BootstrapWith或者把它作为一个元注解.如果没有显式的指定@BootstrapWith，默认情况下使用DefaultTestContextBootstrapper或者WebTestContextBootstrapper，取决于@WebAppConfiguration是否存在\n因为TestContextBootstrapperSPI很可能在未来更改(去适应新需求),我们强烈建议继承AbstractTestContextBootstrapper类或者他的某个具体的字类,而不是实现TestContextBootstrapper这个接口\n5.3. TestExecutionListener配置 Spring提供了下面的TestExecutionListener实现，他们是被默认注册的，按照下面的顺序：\n ServletTestExecutionListener:为WebApplicationContext配置Servlet API模拟。 DirtiesContextBeforeModesTestExecutionListener:为\u0026quot;before\u0026quot;模式处理@DirtiesContext注解。 DependencyInjectionTestExecutionListener:为测试实例提供依赖注入. DirtiesContextTestExecutionListener:为\u0026quot;after\u0026quot;模式处理@DirtiesContext注解。 TransactionalTestExecutionListener:提供默认的rollback的事务测试执行。 SqlScriptsTestExecutionListener:使用@Sql注解时运行配置的SQL脚本. EventPublishingTestExecutionListener:为测试的ApplicationContext发布测试执行事件(参照Test Execution Events) 。  注册TestExecutionListener实现 你可以为测试类和其字类注册TestExecutionListener实现通过使用@TestExecutionListeners注解。详情参考annotation support ,@TestExecutionListeners\n自动化探索默认的TestExecutionListener实现 通过使用@TestExecutionListeners来注册TestExecutionListener实现,适合有限测试方案的自定义监听器。如果自定义监听器要跨越整个测试套件,那么他就会变得十分臃肿。解决这个问题需要通过支持自动探索默认的TestExecutionListener实现来完成，背后依靠SpringFactoriesLoader机制来实现。\n具体来说，spring-test模块申明所有的核心默认TestExecutionListener实现都在META-INF/spring.factories属性文件中的org.springframework.test.context.TestExecutionListenerkey下。第三方框架和开发者可以贡献他们自己的TestExecutionListener到默认的监听者列表，同样通过META-INF/spring.factories属性文件。\nTestExecutionListener实现的顺序 当TestContext框架发现了默认的TesetExecutionListener实现通过前面提到的SpringFactoriesLoader机制，这些初始化的监听器通过spring的AnnotationAwareOrderComparator来排序，而它又使用Spring的Ordered接口和@Order注解来排序。AbstractTestExecutionListener和所有默认的TestExecutionListener都以适当的值实现了Ordered。所以第三方框架和开发者应该确保他们的默认TestExecutionListener实现是是implementsOrdered的或者由@Order注解。通过TestExecutionListener实现的getOrder()方法来查看核心监听器的顺序值。\n合并TestExecutionListener实现 如果一个自定义TestExecutionListener是通过@TestExecutionListeners注册的，那么默认的监听器将不会被注册。在大多数测试场景中，这会强制要求开发者手动申明所有默认的监听器加上用户自定义的监听器：\n@ContextConfiguration\r@TestExecutionListeners({\rMyCustomTestExecutionListener.class,\rServletTestExecutionListener.class,\rDirtiesContextBeforeModesTestExecutionListener.class,\rDependencyInjectionTestExecutionListener.class,\rDirtiesContextTestExecutionListener.class,\rTransactionalTestExecutionListener.class,\rSqlScriptsTestExecutionListener.class\r})\rclass MyTest {\r// class body...\r}\r 这种方法带来的挑战是，你必须要记得所有的默认监听器。并且每个发布版本的监听器可能改变-举个例子SqlScriptsTestExecutionListener是在Spring Framework 4.1引入的，而DirtiesContextBeforeModesTestExecutionListener实在Spring Framework 4.2引入的。此外，第三方框架比如Spring Boot和Spring Security通过前面提到的automatic discovery mechanism注册了他们自己的默认TestExecutionListener实现。\n为了避免记住和重新声明所有默认的监听器，你可以设置@TestExecutionListeners的mergeMode属性为MergeMode.MERGE_WITH_DEFAULTS。这个属性值表实本地申明的监听器应该和默认监听器合并。这个合并算法会移除重复的申明，并且会根据AnnotationAwareOrderComparator排序。如果监听器实现了Ordered或者由@Order注解修饰，那么它可以影响默认监听器的排序。否则，本地声明的监听器会追加到默认监听器列表的末尾。\n举个例子，如果MyCustomTestExecutionListener类配置了order值（举个例子，500）比ServletTestExecutionListener的order值小(恰好是1000)，MyCustomTestExecutionListener可以自动合并到默认集合中并在ServletTestExecutionListener之前，之前的例子可以替换成下面的代码：\n@ContextConfiguration\r@TestExecutionListeners(\rlisteners = MyCustomTestExecutionListener.class,\rmergeMode = MERGE_WITH_DEFAULTS\r)\rclass MyTest {\r// class body...\r}\r 5.4. 测试执行事件 Spring Framework 5.2引入了EventPublishingTestExecutionListener ，提供了一个实现自定义TestExecutionListener的替代方法。在测试ApplicationContext中的组件可以通过EventPublishingTestExecutionListener监听下列的事件，每个事件对应TestExecutionListenerAPI中的一个方法。\n BeforeTestClassEvent PrepareTestInstanceEvent BeforeTestMethodEvent BeforeTestExecutionEvent AfterTestExecutionEvent AfterTestMethodEvent AfterTestClassEvent   这些事件只有在ApplicationContext已经加载后才发布\n 这些事件可能因为多种原因被消费，比如重设模拟bean或者追踪测试执行。选择消费测试执行事件，而不是实现一个自定义TestExecutionListener，其中的一个优点是测试执行事件可以被任何在测试ApplicationContext中注册的Spring bean消耗，这些bean可以直接受利于依赖注入或者ApplicationContext的其他特性。相对应的，在ApplicationContext中的TestExecutionListener并不是一个bean。\n为了监听测试执行事件，一个Spring bean可以选择去实现org.springframework.context.ApplicationListener接口。也可以用@EventListener修饰监听方法并且配置监听上面提到的指定事件类型中的一个。因为这个方法的流行，Spring提供了以下专用的@EventListener注解去简化测试执行事件监听器的注册。这些注解是在org.springframework.test.context.event.annotation包下的。\n @BeforeTestClass @PrepareTestInstance @BeforeTestMethod @BeforeTestExecution @AfterTestExecution @AfterTestMethod @AfterTestClass  异常处理 默认情况下，如果一个测试执行事件监听器在消费事件时抛出了一个异常，这个异常会传递到底层使用的测试框架上（比如JUnit或者TestNG）。比如在消费BeforeTestMethodEvent时抛出一个异常，对应的测试方法将会失败。相反，如果一个异步的测试执行事件监听器抛出一个异常，这个异常是不会传递到底层的测试框架的。异步异常处理的详情，查阅类级别@EventListener的javadoc。\n异步监听器 如果你想要一个特别的测试执行事件监听器去异步处理事件，可以使用Spring的常规@Async支持 。详情查阅类级别@EventListener的javadoc。\n5.5. 上下文管理 每个TestContext都为它负责的测试实例提供了上下文管理和缓存支持。测试实例不会自动接收对配置ApplicationContext的访问。但是，如果测试类实现了ApplicationContextAware接口，会为测试实例提供一个ApplicationContext的引用。注意AbstractJUnit4SpringContextTests和AbstractTestNGSpringContextTests实现了ApplicationContextAware，所以自动提供对ApplicationContext的访问。\n @Autowired ApplicationContext 作为一个实现ApplicationContextAware接口的替代方法，你可以通过设置@Autowired注解在字段上或者setter方法上来注入application context：\n@SpringJUnitConfig\rclass MyTest {\r@Autowired ApplicationContext applicationContext;\r// class body...\r}\r 同样，如果你的测试需要加载一个WebApplicationContext:\n@SpringJUnitWebConfig\rclass MyWebAppTest {\r@Autowired WebApplicationContext wac;\r// class body...\r}\r 通过使用@Autowired进行依赖注入是通过DependencyInjectionTestExecutionListener来提供的，默认情况下就会对它进行配置(参考https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-fixture-di)\n 使用TestContext框架的测试类不需要extends任何特定的类或者实现任何特定接口去配置他们的application context。你只需要在类级别声明一个@ContextConfiguration注解即可。如果你的测试类没有显性的声明application context资源位置或者组件类，配置的ContextLoader会决定怎样从一个默认的位置或者默认的配置类加载一个context。除了资源位置和组件类，一个application context还可以通过application context初始化程序配置。\n下面的几个章节阐述了怎样使用Srping的@ContextConfiguration注解去配置一个测试的ApplicationContext通过使用XML配置文件，Groovy脚本，组件类（典型的@Configuration类），或者上下文初始化程序。另外，你可以实现并配置你自定义的SmartContextLoader为高级的使用场景。\n Context Configuration with XML resources Context Configuration with Groovy Scripts Context Configuration with Component Classes Mixing XML, Groovy Scripts, and Component Classes Context Configuration with Context Initializers Context Configuration Inheritance Context Configuration with Environment Profiles Context Configuration with Test Property Sources Context Configuration with Dynamic Property Sources Loading a WebApplicationContext Context Caching Context Hierarchies  Context Configuration with XML resources 通过XML配置文件为你的测试加载ApplicationContext，需要用@ContextConfiguration注解修饰你的测试类，并用一个由XML文件位置构成的数组来给locations属性赋值。一个相对路径（比如context.xml）会被看做一个classpath资源并且会关联到测试类定义的包下。一个以斜线开头的路径会被看作绝对的classpath路径（比如/org/example/config.xml）。一个路径代表一个资源URL(比如一个路径的前缀是classpath:,file:,http:,等等)。\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from \u0026quot;/app-config.xml\u0026quot; and\r// \u0026quot;/test-config.xml\u0026quot; in the root of the classpath\r@ContextConfiguration(locations={\u0026quot;/app-config.xml\u0026quot;, \u0026quot;/test-config.xml\u0026quot;}) class MyTest {\r// class body...\r}n\r @ContextConfiguration通过标准的Javavalue属性为locations属性提供了一个别名。所以如果你不在@ContextConfiguration申明额外的属性，你可以省略locations：\n@ExtendWith(SpringExtension.class)\r@ContextConfiguration({\u0026quot;/app-config.xml\u0026quot;, \u0026quot;/test-config.xml\u0026quot;}) class MyTest {\r// class body...\r}\r 如果你locations和value属性都没有声明，那么TestContext框架会尝试检测默认的XML资源路径。具体来说，GenericXmlContextLoader 和GenericXmlWebContextLoader 会基于测试类的名称检测资源路径。如果你的类名为com.example.MyTest，GenericXmlContextLoader会从classpath:com/example/MyTest-context.xml加载你的application context。\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from\r// \u0026quot;classpath:com/example/MyTest-context.xml\u0026quot;\r@ContextConfiguration class MyTest {\r// class body...\r}\r Context Configuration with Groovy Scripts 通过使用Groovy Bean Definition DSL 生成的Groovy脚本可以为你的测试生成ApplicationContext，配置Groovy的脚本可以通过@ContextConfiguration的locations和value属性来设置Groovy脚本的资源位置。资源查找语法跟XML文件配置一样。\n 启用Groovy脚本支持\n如果Groovy在classpath路径下，Spring TestContext框架会自动支持用Groovy脚本加载ApplicationContext\n @ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from \u0026quot;/AppConfig.groovy\u0026quot; and\r// \u0026quot;/TestConfig.groovy\u0026quot; in the root of the classpath\r@ContextConfiguration({\u0026quot;/AppConfig.groovy\u0026quot;, \u0026quot;/TestConfig.Groovy\u0026quot;}) class MyTest {\r// class body...\r}\r 如果你同时忽略locations和value属性，测试框架会尝试检测默认的Groovy脚本。具体来说，GenericGroovyXmlContextLoader和GenericGroovyXmlWebContextLoader会检测一个默认的路径，基于测试类的名称。如果你的类名为com.example.MyTset，Groovy上下文加载器会从classpath:com/example/MyTestContext.groovy加载上下文。\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from\r// \u0026quot;classpath:com/example/MyTestContext.groovy\u0026quot;\r@ContextConfiguration class MyTest {\r// class body...\r}\r  同时声明XML配置和Groovy脚本\n你可以同时申明XML配置和Groovy脚本通过@Configuration脚本的locations和value属性。如果配置路径以.xml路径结尾，XmlBeanDefinitionReader会用来加载配置。否则会使用GroovyBeanDefinitionReader。\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from\r// \u0026quot;/app-config.xml\u0026quot; and \u0026quot;/TestConfig.groovy\u0026quot;\r@ContextConfiguration({ \u0026quot;/app-config.xml\u0026quot;, \u0026quot;/TestConfig.groovy\u0026quot; })\rclass MyTest {\r// class body...\r}\r  Context Configuration with Component Classes 使用组件类为你的测试加载一个ApplicationContext，你可以通过@ContextConfiguration注解，并配置classes属性：\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from AppConfig and TestConfig\r@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) class MyTest {\r// class body...\r}\r  Component Classes\n\u0026ldquo;Component Class\u0026quot;组件类指的是：\n 被@Configuration修饰的类 一个组件（就是被@Component，@Service，@Repository，或者其他原始注解修饰的类） 一个JSR-330编译的类，就是被javax.inject注解修饰的类 任何类包含@Bean方法 任何其他类尝试去注册为一个Spring组件(就是说一个在ApplicationContext里的Spring bean)，可能是利用单个构造方法的自动装配，而不是Spring注解 查看@Configuration 和@Bean 的javadoc查找更多详情。关于注解类的配置和语法，特别注意@BeanLite模式的讨论。   如果忽略classes属性，TestContext框架会尝试检测默认配置类是否存在。具体来说，AnnotationConfigContextLoader和AnnotationConfigWebContextLoader会检测所有满足配置类实现需求的static集成类，详情参考@Configuration javadoc。注意配置类的名称是任意的。另外，如果测试类愿意的话他可以包含多个static集成配置类。下面的例子里,OrderServiceTest类声明了一个static集成配置类叫做Config，他会被用来为测试类自动加载ApplicationContext：\n@SpringJUnitConfig // ApplicationContext will be loaded from the\r// static nested Config class\rclass OrderServiceTest {\r@Configuration\rstatic class Config {\r// this bean will be injected into the OrderServiceTest class\r@Bean\rOrderService orderService() {\rOrderService orderService = new OrderServiceImpl();\r// set properties, etc.\rreturn orderService;\r}\r}\r@Autowired\rOrderService orderService;\r@Test\rvoid testOrderService() {\r// test the orderService\r}\r}\r Mixing XML, Groovy Scripts, and Component Classes 有时候会存在混合XML文件,Groovy脚本，和组件类去配置一个ApplicationContext的情况。\n一些第三方框架（比如SpringBoot）对这种混合类型加载提供了良好的支持。但是对Spring框架本身来说，因为之前Spring不支持这种形式的加载，所以在Spring-test模块中，大多数SmartContextLoader实现是只支持一种资源类型的。但是，这不意味着你写代码的时候只能用一种类型。GenericGroovyXmlContextLoader和GenericGroovyXmlWebContextLoader有些不同，他们同时支持XML配置文件和Groovy脚本。此外，第三方框架可以通过@ContextConfiguration的属性locations和classes来实现多类型资源支持，并且，有TestContext框架的标准测试支持，你还可以有如下选项：\n如果你想使用一组资源位置(xml,groovy脚本)和一组@Configuration类来配置你的测试，你必须选择一个作为入口，这个入口必须include或者import其他的资源。比如说，在XML或者Groovy脚本中，你可以include@Configuration类通过component扫描或者把他们作为一般的Spring Bean定义，反之，在@Configuration类中，你可以使用@ImportResource去导入XML配置文件或者Groovy脚本。注意这个方式在语义上跟生产配置应用相同：在生产配置中，你可以定义XML或者Groovy资源集合抑或@Configuration类集合去加载你的ApplicationContext，但是你仍然可以选择include或者import其他类型的配置。\nContext Configuration with Context Initializers 需要通过初始化程序构造ApplicationContext，使用@ContextConfiguration注解的initializers属性即可，该属性需要一个实现ApplicationcontextInitializer类的引用数组。申明初始化构造器之后，他们会被拿来初始化ConfigurableApplicationContext。注意每个初始化程序支持的具体ConfigurableApplicationContext类型必须跟使用中的SmartContextLoader所创建的ApplicationContext类型兼容（通常是GenericApplicationContext）。此外，初始化程序的调用顺序依赖于他们是否实现了Spring的Ordered接口或者以@Order注解修饰或者标准的@Priority注解。\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from TestConfig\r// and initialized by TestAppCtxInitializer\r@ContextConfiguration(\rclasses = TestConfig.class,\rinitializers = TestAppCtxInitializer.class) class MyTest {\r// class body...\r}\r 如果你没有申明任何xml，groovy脚本或者组件类，仅仅声明了初始化程序，那么初始化程序将负责加载context中的bean-举个例子，通过编程方式从xml文件或者配置类中加载bean定义。\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be initialized by EntireAppInitializer\r// which presumably registers beans in the context\r@ContextConfiguration(initializers = EntireAppInitializer.class) class MyTest {\r// class body...\r}\r Context Configuration Inheritance @ContextConfiguration提供了inheritLocations和inheritInitializers属性来设置当前测试类是否从父类继承 资源位置或者组件类和初始化程序\n 从Spring Framework 5.3开始，属性为false，配置信息还是可以从包围类继承\n 下面的例子展示了测试类ExtendedTests如何按照base-config.xml，extended-config.xml的顺序加载ApplicaitonContext。extened-config.xml可以覆盖base-config.xml中的bean配置。\n@ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from \u0026quot;/base-config.xml\u0026quot;\r// in the root of the classpath\r@ContextConfiguration(\u0026quot;/base-config.xml\u0026quot;) class BaseTest {\r// class body...\r}\r// ApplicationContext will be loaded from \u0026quot;/base-config.xml\u0026quot; and\r// \u0026quot;/extended-config.xml\u0026quot; in the root of the classpath\r@ContextConfiguration(\u0026quot;/extended-config.xml\u0026quot;) class ExtendedTest extends BaseTest {\r// class body...\r}\r 组件类也按照同样的加载顺序，覆盖规则也完全一样：\n// ApplicationContext will be loaded from BaseConfig\r@SpringJUnitConfig(BaseConfig.class) class BaseTest {\r// class body...\r}\r// ApplicationContext will be loaded from BaseConfig and ExtendedConfig\r@SpringJUnitConfig(ExtendedConfig.class) class ExtendedTest extends BaseTest {\r// class body...\r}\r 下面的例子展示了初始化程序的继承关系，他们的执行顺序跟父子关系无关，参考上一章节对初始化程序执行顺序的描述：\n// ApplicationContext will be initialized by BaseInitializer\r@SpringJUnitConfig(initializers = BaseInitializer.class) class BaseTest {\r// class body...\r}\r// ApplicationContext will be initialized by BaseInitializer\r// and ExtendedInitializer\r@SpringJUnitConfig(initializers = ExtendedInitializer.class) class ExtendedTest extends BaseTest {\r// class body...\r}\r Context Configuration with Environment Profiles 当有多个环境的配置时，Spring提供@ActiveProfiles注解，可以让你指定当前激活的环境配置。\n 你可以在任何SmartContextLoader的实现类上使用@ActvieProfiles注解，但是旧的ContextLoader实现上是不支持的\n 下面是一个xml配置和一个@Configuration配置类\n\u0026lt;!-- app-config.xml --\u0026gt;\r\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxmlns:jdbc=\u0026quot;http://www.springframework.org/schema/jdbc\u0026quot;\rxmlns:jee=\u0026quot;http://www.springframework.org/schema/jee\u0026quot;\rxsi:schemaLocation=\u0026quot;...\u0026quot;\u0026gt;\r\u0026lt;bean id=\u0026quot;transferService\u0026quot;\rclass=\u0026quot;com.bank.service.internal.DefaultTransferService\u0026quot;\u0026gt;\r\u0026lt;constructor-arg ref=\u0026quot;accountRepository\u0026quot;/\u0026gt;\r\u0026lt;constructor-arg ref=\u0026quot;feePolicy\u0026quot;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;bean id=\u0026quot;accountRepository\u0026quot;\rclass=\u0026quot;com.bank.repository.internal.JdbcAccountRepository\u0026quot;\u0026gt;\r\u0026lt;constructor-arg ref=\u0026quot;dataSource\u0026quot;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;bean id=\u0026quot;feePolicy\u0026quot;\rclass=\u0026quot;com.bank.service.internal.ZeroFeePolicy\u0026quot;/\u0026gt;\r\u0026lt;beans profile=\u0026quot;dev\u0026quot;\u0026gt;\r\u0026lt;jdbc:embedded-database id=\u0026quot;dataSource\u0026quot;\u0026gt;\r\u0026lt;jdbc:script\rlocation=\u0026quot;classpath:com/bank/config/sql/schema.sql\u0026quot;/\u0026gt;\r\u0026lt;jdbc:script\rlocation=\u0026quot;classpath:com/bank/config/sql/test-data.sql\u0026quot;/\u0026gt;\r\u0026lt;/jdbc:embedded-database\u0026gt;\r\u0026lt;/beans\u0026gt;\r\u0026lt;beans profile=\u0026quot;production\u0026quot;\u0026gt;\r\u0026lt;jee:jndi-lookup id=\u0026quot;dataSource\u0026quot; jndi-name=\u0026quot;java:comp/env/jdbc/datasource\u0026quot;/\u0026gt;\r\u0026lt;/beans\u0026gt;\r\u0026lt;beans profile=\u0026quot;default\u0026quot;\u0026gt;\r\u0026lt;jdbc:embedded-database id=\u0026quot;dataSource\u0026quot;\u0026gt;\r\u0026lt;jdbc:script\rlocation=\u0026quot;classpath:com/bank/config/sql/schema.sql\u0026quot;/\u0026gt;\r\u0026lt;/jdbc:embedded-database\u0026gt;\r\u0026lt;/beans\u0026gt;\r\u0026lt;/beans\u0026gt;\r @ExtendWith(SpringExtension.class)\r// ApplicationContext will be loaded from \u0026quot;classpath:/app-config.xml\u0026quot;\r@ContextConfiguration(\u0026quot;/app-config.xml\u0026quot;)\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\rclass TransferServiceTest {\r@Autowired\rTransferService transferService;\r@Test\rvoid testTransferService() {\r// test the transferService\r}\r}\r 当TransferServiceTest运行时，他的ApplicationContext会从app-config.xml配置文件加载。查看app-config.xml你会发现，accountRepository有一个dataSourcebean依赖，但是这个dataSourcebean没有定义为一个顶级的bean，相反，dataSourcebean定义了三次，分别在productionprofile，devprofile，和defaultprofile。\n通过@ActiveProfiles(\u0026quot;dev\u0026quot;)，我们命令Spring启用{\u0026quot;dev\u0026quot;}配置信息去加载ApplicationContext。最终，会创建一个集成数据库并填充测试数据，并且accountRepositroy装配时会带上一个开发的DataSource引用。\n当没有明确指定一个profile时，Spring会启用defaultprofile。他可以作为一个默认的备用方案。\n下面展示如何使用@Configuration替代xml配置：\n@Configuration\r@Profile(\u0026quot;dev\u0026quot;)\rpublic class StandaloneDataConfig {\r@Bean\rpublic DataSource dataSource() {\rreturn new EmbeddedDatabaseBuilder()\r.setType(EmbeddedDatabaseType.HSQL)\r.addScript(\u0026quot;classpath:com/bank/config/sql/schema.sql\u0026quot;)\r.addScript(\u0026quot;classpath:com/bank/config/sql/test-data.sql\u0026quot;)\r.build();\r}\r}\r @Configuration\r@Profile(\u0026quot;production\u0026quot;)\rpublic class JndiDataConfig {\r@Bean(destroyMethod=\u0026quot;\u0026quot;)\rpublic DataSource dataSource() throws Exception {\rContext ctx = new InitialContext();\rreturn (DataSource) ctx.lookup(\u0026quot;java:comp/env/jdbc/datasource\u0026quot;);\r}\r}\r @Configuration\r@Profile(\u0026quot;default\u0026quot;)\rpublic class DefaultDataConfig {\r@Bean\rpublic DataSource dataSource() {\rreturn new EmbeddedDatabaseBuilder()\r.setType(EmbeddedDatabaseType.HSQL)\r.addScript(\u0026quot;classpath:com/bank/config/sql/schema.sql\u0026quot;)\r.build();\r}\r}\r @Configuration\rpublic class TransferServiceConfig {\r@Autowired DataSource dataSource;\r@Bean\rpublic TransferService transferService() {\rreturn new DefaultTransferService(accountRepository(), feePolicy());\r}\r@Bean\rpublic AccountRepository accountRepository() {\rreturn new JdbcAccountRepository(dataSource);\r}\r@Bean\rpublic FeePolicy feePolicy() {\rreturn new ZeroFeePolicy();\r}\r}\r @SpringJUnitConfig({\rTransferServiceConfig.class,\rStandaloneDataConfig.class,\rJndiDataConfig.class,\rDefaultDataConfig.class})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\rclass TransferServiceTest {\r@Autowired\rTransferService transferService;\r@Test\rvoid testTransferService() {\r// test the transferService\r}\r}\r 上面的例子中将xml配置文件拆分成四个独立的@Configuration类：\n TransferServiceConfig：使用@Autowired注解通过依赖注入获取一个dataSource StandaloneDataConfig：为开发测试定义一个dataSource，它集成了一个数据库 JndiDataCOnfig：为生产环境定义一个dataSrouce，从JNDI检索而得 DefaultDataConfig：定义一个默认环境，申明了一个集成的数据库  跟xml配置一样,TransferServiceTest同样声明了@ActiveProfiles(\u0026quot;dev\u0026quot;)，但是这次申明了所有组件类。测试类的具体内容没有任何改变。\n通常情况下，配置信心会用在多个测试类上，为了避免重复申明，可以创建一个基类去配置@ActiveProfiles注解，以及其他注解配置，然后其他的测试类都实现这个基类：\n 从Spring Framework 5.3开始，测试配置可以从包围类继承\n @SpringJUnitConfig({\rTransferServiceConfig.class,\rStandaloneDataConfig.class,\rJndiDataConfig.class,\rDefaultDataConfig.class})\r@ActiveProfiles(\u0026quot;dev\u0026quot;)\rabstract class AbstractIntegrationTest {\r}\r // \u0026quot;dev\u0026quot; profile inherited from superclass\rclass TransferServiceTest extends AbstractIntegrationTest {\r@Autowired\rTransferService transferService;\r@Test\rvoid testTransferService() {\r// test the transferService\r}\r}\r @ActvieProfiles注解支持inheritProfiles属性，提供一个boolean值就可以配置是否从父类集成配置信息：\n// \u0026quot;dev\u0026quot; profile overridden with \u0026quot;production\u0026quot;\r@ActiveProfiles(profiles = \u0026quot;production\u0026quot;, inheritProfiles = false)\rclass ProductionTransferServiceTest extends AbstractIntegrationTest {\r// test body\r}\r 此外，有些时候只能用编程的形式解析要激活哪个配置信息，而不是用声明的方式-基于下面这几个方面：\n 当前的操作系统 测试是否运行在一个不断集成构建的服务 是否存在某一环境参数 是否存在类级别的自定义注解 其他情况  通过编程的方式解析激活的配置，你需要实现ActiveProfilesResolver并且通过resolver属性去注册它。更多信息，请参考javadoc ：\n// \u0026quot;dev\u0026quot; profile overridden programmatically via a custom resolver\r@ActiveProfiles(\rresolver = OperatingSystemActiveProfilesResolver.class,\rinheritProfiles = false)\rclass TransferServiceTest extends AbstractIntegrationTest {\r// test body\r}\r public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {\r@Override\rpublic String[] resolve(Class\u0026lt;?\u0026gt; testClass) {\rString profile = ...;\r// determine the value of profile based on the operating system\rreturn new String[] {profile};\r}\r}\r Context Configuration with Test Property Sources 相对于@Configuration配置的@PropertySource，你同样可以使用@TestPropertySource在测试类上去声明属性资源。这些申明的测试属性资源会被添加到Environment中的PropertySource集合中，为注解的集成测试类加载ApplicationContext。\n 你可以在任何实现SmartContextLoader的类上使用@TestPropertySource，但是他不支持在ContextLoader的实现上申明。\nSmartContextLoader的实现可以通过MergedContextConfiguraiton中的getPropertySourceLocations()和getPropertySourceProperties()方法来合并测试属性资源值。\n 声明测试属性资源 你可以通过@TestPropertySource的locations和value属性来配置测试的属性文件。\n传统的和XML基础的属性文件格式都支持-举个例子classpath:/com/example/test.properties或者file:///path/to/file.xml\n每个path都会被翻译为一个SpringResource。一个相对路径（比如\u0026quot;test.properties)会被看做一个classpath资源，他指向了当前测试类所在的包。如果一个路径是以斜线开头，会被当做绝对路径（比如：\u0026quot;/org/example/test.xml\u0026rdquo;）。引用了URL的路径（比如说，以classpath:，file:，或者http:开头的路径）会使用指定的资源协议去加载。资源位置通配符（比如*/.properties）是不允许的：每个位置必须被解析为一个具体的.properties或者.xml资源。\n@ContextConfiguration\r@TestPropertySource(\u0026quot;/test.properties\u0026quot;) class MyIntegrationTests {\r// class body...\r}\r 你可以配置内联属性通过properties属性，以key-value的结构赋值，下面的例子会展示如何使用。所有的key-value值对会被添加到包围的Environment中，对一个单独测试PropertySource它们有最高的优先级。\nkey-value值对支持的语法跟java属性文件中的键值定义语法一样：\n key=value key:value key value  @ContextConfiguration\r@TestPropertySource(properties = {\u0026quot;timezone = GMT\u0026quot;, \u0026quot;port: 4242\u0026quot;}) class MyIntegrationTests {\r// class body...\r}\r  从Spring Framework 5.2开始，@TestPropertySource可以被用作可重复注解。这意味着你可以为一个测试类声明多次该注解。后面的@TestPropertySource的locations和properties属性会覆盖之前@TestPropertySource声明的。\n另外，你申明的复合注解里面可能都包含了@TestPropertySource，那么所有的@TestPropertySource都会为你的测试属性提供资源。\n直接声明的@TestPropertySource的优先级都会高于复合注解中的声明\n 默认属性文件检测 如果@TestPropertySource注解的locations和properties属性都没有声明，那么他会查找一个默认的属性文件，路径基于当前注解修饰的测试类所在位置。比如测试类在com.example.MyTest，那么默认的属性文件路径为classpath:com/example/MyTest.properties。如果找不到默认文件，那么将会抛出一个IllegalStateException。\n优先级 测试配置的属性优先级比操作系环境，java系统，或者任何通过@PropertySource或者编程方式声明的属性配置优先级都要高。因此测试属性可以选择性的覆盖所有系统属性和application属性资源。此外，内联属性的优先级是高于资源位置的。但是，有个例外，由@DynamicPropertySource申明的属性优先级是高于@TestPropertySource的。\n下面的例子中，timezone和port属性和定义在/test.properties中的所有属性会覆盖在系统或者application中相同的属性名称配置。此外如果/test.properties中也有timezone和port属性，那么他们会被由properties声明内联属性所覆盖。\n@ContextConfiguration\r@TestPropertySource(\rlocations = \u0026quot;/test.properties\u0026quot;,\rproperties = {\u0026quot;timezone = GMT\u0026quot;, \u0026quot;port: 4242\u0026quot;}\r)\rclass MyIntegrationTests {\r// class body...\r}\r 继承并覆盖测试属性资源 @TestPropertySource支持inheritLocations和inheritProperties属性来设置是否从父类继承配置位置和内联属性信息，这两个参数的默认值都为ture。在值为ture的情况下，就代表可以从父类继承配置信息，并且如果有相同名称的配置，那么后出现的会覆盖之前的。其他的优先级信息跟前面章节提到的一致。\n如果inheritLocations和inheritProperties属性为false，那么一丝就是不从父类继承配置信息，当前测试类的配置会替代父类的。\n 从Spring Framework 5.3开始，测试配置可以从环绕类中获取\n 下面的例子展示了怎么从父类继承配置资源位置信息：\n@TestPropertySource(\u0026quot;base.properties\u0026quot;)\r@ContextConfiguration\rclass BaseTest {\r// ...\r}\r@TestPropertySource(\u0026quot;extended.properties\u0026quot;)\r@ContextConfiguration\rclass ExtendedTest extends BaseTest {\r// ...\r}\r 下面的例子展示了如何从父类继承内联属性：\n@TestPropertySource(properties = \u0026quot;key1 = value1\u0026quot;)\r@ContextConfiguration\rclass BaseTest {\r// ...\r}\r@TestPropertySource(properties = \u0026quot;key2 = value2\u0026quot;)\r@ContextConfiguration\rclass ExtendedTest extends BaseTest {\r// ...\r}\r Context Configuration with Dynamic Property Sources 从Spring Framework 5.2.5版本开始，TestContext 框架通过@DynamicPropertySource注解提供了动态属性的支持。这个注解可以在继承测试类需要动态资源属性的时候提供帮助。\n相对于作用在类级别的@TestPropertySource，@DynamicPropertySource只能作用在静态方法上，并且该方法必须有一个DynamicPropertyRegistry参数，这个参数被用来向Environment添加 name-value 格式的数据。这些动态的参数值都是通过一个Supplier来提供的，它只有在属性被解析的时候才会调用。通常来说，方法引用就是被用来提供参数的，就像下面的例子一样，使用TestContainers项目去管理一个在Spring ApplicationContext之外的Redis container。通过redis.host和redis.port属性，让redis容器管理的ip和host也对testApplicationContext的组件可用。这些属性可以通过Spring的Environment抽象访问或者直接在Spring管理的组件中注入-举个例子，分别通过@Value(\u0026quot;${redis.host}\u0026quot;)和@Value(\u0026quot;${redis.port}\u0026quot;)赋值\n 如果你的@DynamicPropertySource声明在基类，并且子类测试失败，因为属性值在子类之中已经被改变。那么你需要在基类上声明@DirtiesContext，以确保每个子类的ApplcationContext都有正确的属性值\n @SpringJUnitConfig(/* ... */)\r@Testcontainers\rclass ExampleIntegrationTests {\r@Container\rstatic RedisContainer redis = new RedisContainer();\r@DynamicPropertySource\rstatic void redisProperties(DynamicPropertyRegistry registry) {\rregistry.add(\u0026quot;redis.host\u0026quot;, redis::getContainerIpAddress);\rregistry.add(\u0026quot;redis.port\u0026quot;, redis::getMappedPort);\r}\r// tests ...\r}\r 优先级 动态属性拥有最高的优先级，意思就是会覆盖来自@TestPropertySource、操作系统环境、java系统属性、或者通过@PropertySource和编码方式申明的属性。因为他的高优先级特性，可以用来覆盖指定的属性值。\nLoading a WebApplicationContext 如果你需要的上下文对象是WebApplcationContext而不是ApplicationContext，那你需要在每个测试类上声明@WebAppConfiguration注解。\n在TestContext框架为你的测试类生成WebApplicationContext时，会在后台为你的WebApplicationContext提供一个MockServletContext。默认情况下，MockServletContext的基础资源路径被设定为src/main/webapp。这个相对路径跟JVM的根路径关联（一般来说就是你的项目路径）。如果你熟悉maven项目的Web应用目录结构，你肯定知道WAR根目录的默认位置就是src/main/webapp。你可以提供自定义路径去覆盖默认的（@WebAppConfiguration(\u0026quot;src/test/webapp\u0026quot;)）。如果你想引用的基础资源路径是来自classpath而不是文件系统，可以使用Spring的classpath:前缀。\n注意Spring测试对WebApplicationContext实现的支持等同于对ApplicationContext实现的支持。这句话的意思就是ApplicationContext可用的注解，WebaApplicationContext同样可用，并且使用方式也一样-例如：@Configuration、@ContextConfiguration、@ActiveProfiles、@TestExecutionListeners、@Sql、@Rollback，等等其他注解。\n下面例子展示如果加载WebApplicationContext。第一个例子展示默认配置：\n@ExtendWith(SpringExtension.class)\r// defaults to \u0026quot;file:src/main/webapp\u0026quot;\r@WebAppConfiguration\r// detects \u0026quot;WacTests-context.xml\u0026quot; in the same package\r// or static nested @Configuration classes\r@ContextConfiguration\rclass WacTests {\r//...\r}\r 如果@WebAppConfiguration没有指定一个基础资源路径，那么默认的file:src/main/webapp路径将会使用。同样的，如果申明@ContextConfiguration没有指定资源locations，组件类，或者contextinitializers，Spring会尝试在当前测试类的所在路径检测WacTests-context.xml文件，或者静态集成的@Configuration类。\n下面的例子展示了如何清晰的声明一个@WebAppConfiguration基础资源路径，和@ContextConfiguration的XML资源路径：\n@ExtendWith(SpringExtension.class)\r// file system resource\r@WebAppConfiguration(\u0026quot;webapp\u0026quot;)\r// classpath resource\r@ContextConfiguration(\u0026quot;/spring/test-servlet-config.xml\u0026quot;)\rclass WacTests {\r//...\r}\r 这里有个重要的事情需要注意，默认情况下，@WebAppConfiguration资源路径是以文件系统为基础的，然而@ContextConfiguration资源路径是以classpath为基础的。\n下面展示了如果通过Spring前缀改变默认的路径语法：\n@ExtendWith(SpringExtension.class)\r// classpath resource\r@WebAppConfiguration(\u0026quot;classpath:test-web-resources\u0026quot;)\r// file system resource\r@ContextConfiguration(\u0026quot;file:src/main/webapp/WEB-INF/servlet-config.xml\u0026quot;)\rclass WacTests {\r//...\r}\r Web Mocks 为了提供完整的测试支持，TestContext框架默认启用了ServletTestExecutionListener。当在测试一个WebApplcationContext时，TestExecutionListener在每个测试方法之前，通过Spring Web的RequestContextHolder配置好默认的线程本地状态，并且基于@WebAppConfiguration配置的基础资源路径创建MockHttpServletRequest，MockHttpServletResponse，和ServletWebRequest。ServletTestExecutionListener同时也确保了MockHttpServletRequest和MockHttpServletResponse能够注入到测试实例当中，当测试完毕，他会清空线程本地状态。\n下面的实例展示了那些mock对象可以注入到你的测试实例当中。注意WebApplicationContext和MockServletContext都是被缓存起来的通用测试对象，然而其他的mock对象都是每个测试方法维护一个，其中的逻辑是通过ServletTestExecutionListener来实现的。\n@SpringJUnitWebConfig\rclass WacTests {\r@Autowired\rWebApplicationContext wac; // cached\r@Autowired\rMockServletContext servletContext; // cached\r@Autowired\rMockHttpSession session;\r@Autowired\rMockHttpServletRequest request;\r@Autowired\rMockHttpServletResponse response;\r@Autowired\rServletWebRequest webRequest;\r//...\r}\r Context Caching 一旦TestContext框架为一个测试加载了ApplicationContext(或者WebApplicationContext)，这个上下文对象会被缓存并且在接下来的测试中复用。测试的上下文对象是否从缓存中读取，要看他是否申明了相同唯一的上下文配置，并且是在同一个测试套件中。要了解测试框架的缓存机制，就必须知道唯一和测试套件分别代表了什么。\nSpring测试框架会根据context的配置参数生成一个唯一的key值。下面是影响这个key值的配置参数：\n locations (from @ContextConfiguration) classes (from @ContextConfiguration) contextInitializerClasses (from @ContextConfiguration) contextCustomizers (from ContextCustomizerFactory) – 这个包含了@DynamicPropertySource的方法以及Spring Boot支持的测试特性，比如@MockBean和@SpyBean contextLoader (from @ContextConfiguration) parent (from @ContextHierarchy) activeProfiles (from @ActiveProfiles) propertySourceLocations (from @TestPropertySource) propertySourceProperties (from @TestPropertySource) resourceBasePath (from @WebAppConfiguration)  举个例子，TestClassA根据@ContextConfiguration的属性{\u0026quot;app-config.xml\u0026quot;, \u0026quot;test-config.xml\u0026quot;}初始化了context，接下来测试框架会加载该ApplicationContext并且根据前面的路径生成一个key，保存到static上下文缓存中。如果TestClassB同样申明了{\u0026quot;app-config.xml\u0026quot;, \u0026quot;test-config.xml\u0026quot;}，并且没有@WebAppConfiguration，不一样的ContextLoader，不一样的启用配置， 不一样的上下文初始化程序，不一样的测试属性资源，或者不一样的父上下文类，那么这两个类就会共享同一个ApplicationContext。\n 测试套件和分支进程\nSpring测试框架缓存上下文对象在一个静态的参数里，意思就是如果测试类来自两个不同的进程，就算满足上面两个条件，缓存机制也不可能生效。\n因此如果想利用Spring测试的上下文缓存机制，必须确保在同一个进程或者同一个测试套件中。同样，如果通过build框架执行的测试，比如Ant，Maven，或者Gradle，必须确保build框架在测试之间没有fork。比如说，Maven Surefire插件的forkMode如果设置为always或者pertest，那么上下文缓存就不会生效。\n 上下文缓存的最大个数是32个。当达到最大值时，一个最近使用最少(LRU)的驱逐策略将会被使用来驱逐和关闭陈旧的上下文。想配置缓存的最大数量，可以通过命令行或者JVM系统属性的构建脚本，名字叫spring.test.context.cache.maxSize。或者通过编程的方式使用SpringProperties设置相同的属性。\n缓存多个应用上下文在给定测试套件中会造成测试套件无意义的长时间运行，当然最好是能知道目前有多少个上下文缓存。通过设置org.springframework.test.context.cache的log等级为DEBUG即可实现。\n极少数情况测试会污染上下文对象（比如修改bean的定义或者上下文对象的状态），你可以使用@DirtiesContext注解来表示下次测试运行之前重载上下文。这个注解是DirtiesContextBeforeModesTestExecutionListener和DirtiesContextTestExecutionListener提供的，他们两个都是默认启用。\nContext Hierarchies 有时候需要用到上下文的层次结构，比如说在开发Spring MVC Web应用的时候，你需要一个由SpringContextLoaderListener加载的根WebApplicationContext，和一个由SpringDispatcherServlet加载的子WebApplicationContext。由根对象的申明的组件和基础配置会在子对象中通过web指定的组件去调用。\n@ContextHierarchy注解可以申明context的层次结构。如果一个层次结构中的多个类都有该注解，那么你可以合并或者覆盖指定的并已命名的层级。当需要合并一个给定层级的配置时，他们的资源类型必须一样（XML，或者组件类），否则将会被视为两个层级。\n下面的例子是以JUnit Jupiter为基础的，展示了需要使用上下文层次的常见场景。\n单个类有上下文层次 ControllerIntegrationTests展示了一个典型的Spring MVC web应用的测试场景，申明的上下文层次包含两个层级，一个是根WebApplicaitonContext，另外一个是dispatcher servletWebApplicationContext。测试类中的wac参数，注入的是上下文层次结构中最后的那一个。\n@ExtendWith(SpringExtension.class)\r@WebAppConfiguration\r@ContextHierarchy({\r@ContextConfiguration(classes = TestAppConfig.class),\r@ContextConfiguration(classes = WebConfig.class)\r})\rclass ControllerIntegrationTests {\r@Autowired\rWebApplicationContext wac;\r// ...\r}\r 类层次中有隐式的父context 下面的例子展示了父子类的层次结构，一共会加载三个上下文对象， 每个子类上下文都是基于父类上下文：\n@ExtendWith(SpringExtension.class)\r@WebAppConfiguration\r@ContextConfiguration(\u0026quot;file:src/main/webapp/WEB-INF/applicationContext.xml\u0026quot;)\rpublic abstract class AbstractWebTests {}\r@ContextHierarchy(@ContextConfiguration(\u0026quot;/spring/soap-ws-config.xml\u0026quot;))\rpublic class SoapWebServiceTests extends AbstractWebTests {}\r@ContextHierarchy(@ContextConfiguration(\u0026quot;/spring/rest-ws-config.xml\u0026quot;))\rpublic class RestWebServiceTests extends AbstractWebTests {}\r 类层次中有合并的上下文层次配置 下面的例子展示了如何通过指定层级名称去合并上下文配置。一共会加载三个上下文对象，一个是parent，一个是父类child，还有一个是父类和子类child层级之和。\n@ExtendWith(SpringExtension.class)\r@ContextHierarchy({\r@ContextConfiguration(name = \u0026quot;parent\u0026quot;, locations = \u0026quot;/app-config.xml\u0026quot;),\r@ContextConfiguration(name = \u0026quot;child\u0026quot;, locations = \u0026quot;/user-config.xml\u0026quot;)\r})\rclass BaseTests {}\r@ContextHierarchy(\r@ContextConfiguration(name = \u0026quot;child\u0026quot;, locations = \u0026quot;/order-config.xml\u0026quot;)\r)\rclass ExtendedTests extends BaseTests {}\r 类层次中有覆盖上下文层次配置 相对于上一个例子，下面要展示的是如果覆盖父类的层级配置。通过设定@ContextConfiguration的参数inheritLocations为false，即可让子类覆盖child层级的配置，并同时继承parent层级。\n@ExtendWith(SpringExtension.class)\r@ContextHierarchy({\r@ContextConfiguration(name = \u0026quot;parent\u0026quot;, locations = \u0026quot;/app-config.xml\u0026quot;),\r@ContextConfiguration(name = \u0026quot;child\u0026quot;, locations = \u0026quot;/user-config.xml\u0026quot;)\r})\rclass BaseTests {}\r@ContextHierarchy(\r@ContextConfiguration(\rname = \u0026quot;child\u0026quot;,\rlocations = \u0026quot;/test-user-config.xml\u0026quot;,\rinheritLocations = false\r))\rclass ExtendedTests extends BaseTests {}\r  如果你在测试中使用@DirtiesContext，并且对应的上下文对象还在一个上下文层级结构中，那么你可以通过hierarchyMode去控制上下文缓存如何清理，详情参考@DirtiesContext in Spring Testing Annotations 和@DirtiesContext\n 5.6. 测试资源的依赖注入 当你使用DependencyInjectionTestExecutionListener（默认配置），测试实例中的依赖会从上下文中的bean中注入。你可以使用setter注入，字段注入，或者两者同时存在，取决于你选择哪个注解和你是否要将他们放进setter方法。如果使用JUnit Jupiter你还可以选择构造器注入。为了跟Spring的基于注解的注入支持保持一致，你还可以使用@Autowired注解或者@Inject注解来自JSR-330申明在字段或者setter上。\n 对于JUnit Jupiter以外的测试框架，TestContext框架是不参与测试类的初始化的。因此，如果使用@Autowired或者@Inject在构造器上，将不会有任何效果\n  虽然生产代码不鼓励使用字段注入，但是在测试代码中没有这个提议。其中差别的原理是因为你永远不会直接实例化你的测试类。因此，没必要保证能够调用测试类的public构造或者setter方法。\n 因为@Autowired是根据类型的自动装配，如果你有多个bean定义了相同的类型，那么你就无法通过这种方式获取正确的bean。 这种情况下，你可以搭配@Qualifier使用@Autowired。或者使用@Inject搭配@Named使用。另外，如果你的测试可以访问他的ApplicationContext，你可以直接查找对应bean：applicationContext.getBean(\u0026quot;titleRepository\u0026quot;,TitleRepository.class)。\n如果你不想依赖注入应用到你的测试实例上，不在字段或者setter方法上使用@Autowired或者@Inject。你可以整个关掉依赖注入，通过直接配置@TestExecutionListeners，并且在监听器集合中省略DependencyInjectionTestExecutionListener.class。\n考虑测试类中调用HibernateTitleRepository类访问数据库的场景，下面的例子通过依赖注入实现了测试。他们的上下文配置在所有的样例代码之后。\n 下面的依赖注入行为不是JUnit Jupiter特有的，所有支持的测试框架都能适配。\n下面例子中调用的静态断言方法，省略了import\n @Autowired field\n@ExtendWith(SpringExtension.class)\r// specifies the Spring configuration to load for this test fixture\r@ContextConfiguration(\u0026quot;repository-config.xml\u0026quot;)\rclass HibernateTitleRepositoryTests {\r// this instance will be dependency injected by type\r@Autowired\rHibernateTitleRepository titleRepository;\r@Test\rvoid findById() {\rTitle title = titleRepository.findById(new Long(10));\rassertNotNull(title);\r}\r}\r @Autowired setter\n@ExtendWith(SpringExtension.class)\r// specifies the Spring configuration to load for this test fixture\r@ContextConfiguration(\u0026quot;repository-config.xml\u0026quot;)\rclass HibernateTitleRepositoryTests {\r// this instance will be dependency injected by type\rHibernateTitleRepository titleRepository;\r@Autowired\rvoid setTitleRepository(HibernateTitleRepository titleRepository) {\rthis.titleRepository = titleRepository;\r}\r@Test\rvoid findById() {\rTitle title = titleRepository.findById(new Long(10));\rassertNotNull(title);\r}\r}\r 上面的测试类用了相同的XML上下文文件（repository-config.xml）：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans\rhttps://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt;\r\u0026lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --\u0026gt;\r\u0026lt;bean id=\u0026quot;titleRepository\u0026quot; class=\u0026quot;com.foo.repository.hibernate.HibernateTitleRepository\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;sessionFactory\u0026quot; ref=\u0026quot;sessionFactory\u0026quot;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;bean id=\u0026quot;sessionFactory\u0026quot; class=\u0026quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean\u0026quot;\u0026gt;\r\u0026lt;!-- configuration elided for brevity --\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;/beans\u0026gt;\r  如果你继承了一个Spring提供的测试基类，刚好它使用了@Autowired在一个setter方法上，那么影响的类型可能有多个bean定义在你的应用上下文中（举个例子，多个DataSourcebean）。在这种情况下，你可以重写setter方法并且使用@Qualiifier注解去指明一个特定的目标bean，就像下面的例子一样（但也确保委托给超类中的重写方法）：\n@Autowired\r@Override\rpublic void setDataSource(@Qualifier(\u0026quot;myDataSource\u0026quot;) DataSource dataSource) {\rsuper.setDataSource(dataSource);\r}\r 指定的qualifier值代表要注入的那个目标DataSourcebean。它的值匹配的是定义中的申明。Bean的名称被用作后备的qualifier值，因此也可以用来有效的指向特定的Bean（Bean id）。\n 5.7. 测试Request和Session范围的bean 从早期开始Spring就一直支持Request和Session范围的bean，你可以根据下面的步骤来测试你的request范围和session范围的bean：\n 确保你的测试类被@WebAppConfiguration注解修饰。 注入模拟request或者session到你的测试实例中，并且根据需要准备你的测试资源。 通过依赖注入调用WebApplicationContext中配置的web组件。 对模拟对象进行断言。  下面的代码片段是一个用户登录案例的XML配置。注意userServicebean有一个request范围的loginActionbean依赖。并且，LoginAction通过使用SpEL表达式初始化，表达式从HTTP请求中获取用户名和密码。在我们的测试中，我们希望通过TestContext框架的mock管理来配置这些请求参数。下面首先是配置xml：\n\u0026lt;beans\u0026gt;\r\u0026lt;bean id=\u0026quot;userService\u0026quot; class=\u0026quot;com.example.SimpleUserService\u0026quot;\rc:loginAction-ref=\u0026quot;loginAction\u0026quot;/\u0026gt;\r\u0026lt;bean id=\u0026quot;loginAction\u0026quot; class=\u0026quot;com.example.LoginAction\u0026quot;\rc:username=\u0026quot;#{request.getParameter('user')}\u0026quot;\rc:password=\u0026quot;#{request.getParameter('pswd')}\u0026quot;\rscope=\u0026quot;request\u0026quot;\u0026gt;\r\u0026lt;aop:scoped-proxy/\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;/beans\u0026gt;\r 在下面的RequestScopedBeanTests类中，我们同时注入了UserService和MockHttpServletRequest到我们的测试实例中。在requestScope()测试方法中，我们通过设置MockHttpServletRequest中的request参数来配置我们的测试资源。当userService的loginUser()方法被调用时，我们可以确定service中访问的loginAction是当前MockHttpServletRequest范围中的。\n@SpringJUnitWebConfig\rclass RequestScopedBeanTests {\r@Autowired UserService userService;\r@Autowired MockHttpServletRequest request;\r@Test\rvoid requestScope() {\rrequest.setParameter(\u0026quot;user\u0026quot;, \u0026quot;enigma\u0026quot;);\rrequest.setParameter(\u0026quot;pswd\u0026quot;, \u0026quot;$pr!ng\u0026quot;);\rLoginResults results = userService.loginUser();\r// assert results\r}\r}\r 下面的代码片段跟之前的请求范围的bean类似。但是，这次userServicebean有了一个session范围的依赖userPreferencesbean。注意这个UserPreferencesbean通过一个SpEL表达式初始化，它从HTTP session中获取了主题参数。在我们的测试中，需要配置mock session的主题参数。\n\u0026lt;beans\u0026gt;\r\u0026lt;bean id=\u0026quot;userService\u0026quot; class=\u0026quot;com.example.SimpleUserService\u0026quot;\rc:userPreferences-ref=\u0026quot;userPreferences\u0026quot; /\u0026gt;\r\u0026lt;bean id=\u0026quot;userPreferences\u0026quot; class=\u0026quot;com.example.UserPreferences\u0026quot;\rc:theme=\u0026quot;#{session.getAttribute('theme')}\u0026quot;\rscope=\u0026quot;session\u0026quot;\u0026gt;\r\u0026lt;aop:scoped-proxy/\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;/beans\u0026gt;\r 在下面的SessionScopedBeanTests类中，我们同时注入UserService和MockHttpService到我们的测试实例当中。在sessionScope()方法中，我们通过设置MockHttpSession中的theme属性来配置我们的测试资源，我们可以确定service内部调用的userPreferences是当前MockHttpSession范围中的。\n@SpringJUnitWebConfig\rclass SessionScopedBeanTests {\r@Autowired UserService userService;\r@Autowired MockHttpSession session;\r@Test\rvoid sessionScope() throws Exception {\rsession.setAttribute(\u0026quot;theme\u0026quot;, \u0026quot;blue\u0026quot;);\rResults results = userService.processUserPreferences();\r// assert results\r}\r}\r 5.8. 事务管理 在TestContext框架中，事务管理是在TransactionalTestExecutionListener中的，并且它是默认配置，即使你不显式的在你的测试类上申明@TestExecutionListeners。为了开启事务支持，你必须配置一个PlatformTransactionManagerbean在ApplicationContext中，它是随着@ContextConfiguration语法加载的（详情参考下文）。另外，你必须申明@Transactional注解在测试类或者方法上。\n5.8.1. 测试管理的事务 测试管理的是事务指的是通过使用TransactionalTestExecutionListener申明管理的或者是编程方式通过TestTransaction。你不应该将它和Spring管理的事务混淆（直接由Spring管理的在测试类的ApplicationContext中的事务），或者应用管理的事务混淆（测试中调用的通过编码方式直接管理的在应用代码中的事务）。Spring管理的事务和应用管理的事务通常都可以参与到测试管理的事务当中。但是，当Spring管理或者应用管理的事务配置的是任何传播类型，而不是REQUIRED或者SUPPORTS类型时，需要特别小心（详情参考transaction propagation\n 抢占式超时和测试管理的事务\n当使用来自测试框架任何形式的抢占式超时和Spring的测试管理事务配合使用时一定要小心。 典型的就是，Spring测试支持绑定事务状态到当前的线程上（通过一个java.lang.ThreadLocal参数）在当前的测试方法执行之前。如果测试框架为了支持抢占式超时，在一个新的线程调用当前的测试方法，那么在当前测试方法中的任何action都不会在测试管理的事务当中被调用。结果就是，测试管理的事务不会回滚任何action。相对的，这些action会被提交到持久储存中。\n下面就是可能引起这种问题的情形，但并不是全部：\n JUnit 4的@Test(timeout = ...)支持和TimeOut规则。 JUnit Jupiter 在org.junit.jupiter.api.Assertions类中的assertTimeoutPreemptively(...)方法。 TestNG的@Test(timeOut=...)支持   5.8.2 启用和关闭事务 用@Transactional修饰一个测试方法，可以让测试在事务中运行，默认情况下，该事务会在测试完成后自动回滚。如果测试类被@Transactional修饰，类层次结构中的所有方法都会在事务中运行。测试方法如果没有被@Transactional注解修饰（在类或者方法上），那么测试就不会在事务中运行。注意@Transactional不支持测试生命周期方法——比如说，方法有Jupiter的@BeforeAll，@BeforeEach，等等。此外，测试有@Transactional注解但是propagation属性是NOT_SUPPORTED或者NEVER，方法也不会在事务中运行。\n@Transactional属性支持\n   属性 是否支持测试管理的事务     value和transactionManager yes   propagation 只有Propagation.NOT_SUPPORTED和Propagation.NEVER支持   isolation no   timeout no   readOnly no   rollbackFor和rollbackForClassName no:使用TestTransaction.flagForRollback()替代   noRollbackFor和noRollbackForClassName no:使用TestTransaction.flagForCommit()代替     方法级别的生命周期函数——举个例子，被JUnit jupiter的@BeforeEach或者@AfterEach注解修饰的——是运行在测试管理的事务中的。另一方法，suite级别和类级别的生命周期方法——举个例子，被JUnit Jupiter的@BeforeAll或者AfterAll注解修饰的和被TestNG的@BeforeSuite，@AfterSuite，@BeforeClass，或者@AfterClass注解修饰的方法——是不会运行在测试管理的事务当中的。\n如果你需要在事务中运行suit级别或者类级别的生命周期方法，你可以注入对应的PlatformTransactionManager到你的测试类中，然后和TransactionTempalte一起使用，通过编码的方式实现事务管理。\n 注意，AbstractTransactionalJUnit4SpringContextTests和AbstractTransactionalTestNGSpringContextTests在类级别已经预配置了事务的支持。\n下面的例子展示了一个常用的场景：为一个Hibernate为基础的UserRepository写一个集成测试。\n@SpringJUnitConfig(TestConfig.class)\r@Transactional\rclass HibernateUserRepositoryTests {\r@Autowired\rHibernateUserRepository repository;\r@Autowired\rSessionFactory sessionFactory;\rJdbcTemplate jdbcTemplate;\r@Autowired\rvoid setDataSource(DataSource dataSource) {\rthis.jdbcTemplate = new JdbcTemplate(dataSource);\r}\r@Test\rvoid createUser() {\r// track initial state in test database:\rfinal int count = countRowsInTable(\u0026quot;user\u0026quot;);\rUser user = new User(...);\rrepository.save(user);\r// Manual flush is required to avoid false positive in test\rsessionFactory.getCurrentSession().flush();\rassertNumUsers(count + 1);\r}\rprivate int countRowsInTable(String tableName) {\rreturn JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);\r}\rprivate void assertNumUsers(int expected) {\rassertEquals(\u0026quot;Number of rows in the [user] table.\u0026quot;, expected, countRowsInTable(\u0026quot;user\u0026quot;));\r}\r}\r 这里是不需要在createUser()方法执行后再去清理数据库的，因为任何改变都会通过TransactionalTestExecutionListener自动回滚。\n5.8.3. 事务回滚和提交行为 默认情况下，测试执行完成后会默认回滚；但是事务提交和回滚是可以配置的，通过@Commit和@Rollback注解。\n5.8.4. 手写事务管理 你可以通过在TestTransaction中的静态方法来以编码的方式管理事务。举个例子，你可以在测试方法，before方法，和after方法中start或者end当前测试管理的事务或者说rollback或者commit当前测试管理的事务。每当TransactionalTestExecutionListener启用，TestTransaction就是自动支持的。\n下面的例子展示了TestTransaction的部分特征，详情参考TestTransaction\n@ContextConfiguration(classes = TestConfig.class)\rpublic class ProgrammaticTransactionManagementTests extends\rAbstractTransactionalJUnit4SpringContextTests {\r@Test\rpublic void transactionalTest() {\r// assert initial state in test database:\rassertNumUsers(2);\rdeleteFromTables(\u0026quot;user\u0026quot;);\r// changes to the database will be committed!\rTestTransaction.flagForCommit();\rTestTransaction.end();\rassertFalse(TestTransaction.isActive());\rassertNumUsers(0);\rTestTransaction.start();\r// perform other actions against the database that will\r// be automatically rolled back after the test completes...\r}\rprotected void assertNumUsers(int expected) {\rassertEquals(\u0026quot;Number of rows in the [user] table.\u0026quot;, expected, countRowsInTable(\u0026quot;user\u0026quot;));\r}\r}\r 5.8.5. 在一个事务之外运行代码 有些时候，你可能需要在事务测试方法之前或者之后运行代码，并且在事务上下文之外——举个例子，在运行测试之前验证初始化数据库的状态，或者在运行测试之后验证预期的事务提交行为。TransactionalTestExecutionListener为这种场景提供了@BeforeTransaction和@AfterTransaction注解。你可以把他们中的一个用在测试类的void方法上，或者测试接口的任何defaultvoid方法，然后TransactionalTestExecutionListener确保方法在合适的时间运行。\n 任何before方法(比如JUnit Jupiter的@BeforeEach)和任何after方法（比如JUnit Jupiter的@AfterEach）是运行在一个事务中的。此外，被@BeforeTransaction或者@AfterTransaction修饰的方法，不会在没有事务的测试方法执行流程中运行。\n 5.8.6. 配置一个事务管理器 TransactionalTestExecutionListener是期望在测试的ApplicationContext中有一个PlatformTransactionManager的。如果在测试的ApplicationContext中有多个PlatformTransactionManagerbean，你可以通过@Transactional(\u0026quot;myTxMgr\u0026quot;)申明qualifier，或者@Transactional(transactionManager = \u0026quot;myTxMgr\u0026quot;)，或者TransactionManagementConfigurer的@Configuration类实现。详情参考javadoc for TestContextTransactionUtils.retrieveTransactionManager()\n5.8.7. 展示所有事务相关的注解 下面展示了所有支持的事务相关的注解：\n@SpringJUnitConfig\r@Transactional(transactionManager = \u0026quot;txMgr\u0026quot;)\r@Commit\rclass FictitiousTransactionalTest {\r@BeforeTransaction\rvoid verifyInitialDatabaseState() {\r// logic to verify the initial state before a transaction is started\r}\r@BeforeEach\rvoid setUpTestDataWithinTransaction() {\r// set up test data within the transaction\r}\r@Test\r// overrides the class-level @Commit setting\r@Rollback\rvoid modifyDatabaseWithinTransaction() {\r// logic which uses the test data and modifies database state\r}\r@AfterEach\rvoid tearDownWithinTransaction() {\r// run \u0026quot;tear down\u0026quot; logic within the transaction\r}\r@AfterTransaction\rvoid verifyFinalDatabaseState() {\r// logic to verify the final state after transaction has rolled back\r}\r}\r  当测试ORM代码时避免误报 当你的测试应用代码修改Hibernate session或者JPA持久上下文状态时，确保刷新底层的工作单元。未能刷新底层的工作单元可能产生误报：你的测试通过，但是相同的代码在线上生产环境抛异常。注意，这可以适用于任何在内存中维护工作单元的ORM框架。\n下面的Hibernate为基础的测试实例，一个方法展示了误报，另外一个方法正确的暴露了刷新session的结果：\n// ...\r@Autowired\rSessionFactory sessionFactory;\r@Transactional\r@Test // no expected exception!\rpublic void falsePositive() {\rupdateEntityInHibernateSession();\r// False positive: an exception will be thrown once the Hibernate\r// Session is finally flushed (i.e., in production code)\r}\r@Transactional\r@Test(expected = ...)\rpublic void updateWithSessionFlush() {\rupdateEntityInHibernateSession();\r// Manual flush is required to avoid false positive in test\rsessionFactory.getCurrentSession().flush();\r}\r// ...\r 下面的例子展示的是JPA的：\n// ...\r@PersistenceContext\rEntityManager entityManager;\r@Transactional\r@Test // no expected exception!\rpublic void falsePositive() {\rupdateEntityInJpaPersistenceContext();\r// False positive: an exception will be thrown once the JPA\r// EntityManager is finally flushed (i.e., in production code)\r}\r@Transactional\r@Test(expected = ...)\rpublic void updateWithEntityManagerFlush() {\rupdateEntityInJpaPersistenceContext();\r// Manual flush is required to avoid false positive in test\rentityManager.flush();\r}\r// ...\r  5.9. 执行SQL脚本 在对一个关系数据库写集成测试的时候，经常需要运行SQL脚本去修改数据库的schema或者插入测试数据到表中。spring-jdbc模块提供了初始化集成或者已存在数据库的支持，通过在ApplicationContext加载时执行SQL脚本。\n下面的章节是如何以编码的形式和申明的形式运行SQL脚本\n5.9.1. 编码形式执行SQL脚本 Spring提供了下面的选项，以在集成测试方法中编码的形式执行SQL脚本。\n org.springframework.jdbc.datasource.init.ScriptUtils org.springframework.jdbc.datasource.init.ResourceDatabasePopulator org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests  ScriptUtils提供了一个有关SQL脚本的静态实用方法集合，并且他主要是为框架内部使用的。但是，如果你需要完全的控制SQL脚本的解析和运行，ScriptUtils可能比之后提到的工具更符合你的需求。详情参考他的javadoc\nResourceDatabasePopulator提供了一个对象基础的API通过定义在外部的SQL脚本，手动编码执行填充，初始化，或者清除数据库。ResourceDatabasePopulator提供许多参数，包括：配置字符编码，语句分隔符，注释分隔符，和异常处理。每个配置参数都有一个合理的默认值。详情参考javadoc 。要运行ResourceDatabasePopulator配置的脚本，针对java.sql.Connection你可以调用populate(Connection)方法，针对javax.sql.DataSource你可以调用execute(DataSource)方法。\n下面的例子指定了一个有关测试schema和测试数据的SQL叫阿苯，设置了语句分隔符为@@，并且针对DataSource运行脚本。\n@Test\rvoid databaseTest() {\rResourceDatabasePopulator populator = new ResourceDatabasePopulator();\rpopulator.addScripts(\rnew ClassPathResource(\u0026quot;test-schema.sql\u0026quot;),\rnew ClassPathResource(\u0026quot;test-data.sql\u0026quot;));\rpopulator.setSeparator(\u0026quot;@@\u0026quot;);\rpopulator.execute(this.dataSource);\r// run code that uses the test schema and data\r}\r 注意ResourceDatabasePopulator内部委托了ScriptUtils去解析和运行SQL脚本。类似的是，在AbstractTransactionalJUnit4SpringContextTests和AbstractTransactionalTestNGSpringContextTests中的executeSqlScript(..)方法，内部使用的是ResourceDatabasePopulator去运行SQL脚本。\n5.9.2. 通过注解@Sql执行脚本 除了前面提到过的通过编程的方式实现脚本执行，Spring TestContext框架还支持通过注解执行脚本，通过注解你可以在测试方法之前或者之后执行脚本。@Sql可以修饰到类或者方法上，可以配置独立的sql脚本或者sql脚本的资源路径，他的支持由SqlScriptsTestExecutionListener提供，这个listener是默认启用的。\n 方法级别的@Sql申明会默认覆盖类级别的声明。从Spring Framework 5.2开始，是否覆盖可以通过@SqlMergeMode来配置，他可以在类级别或者方法级别配置，详情参考之前提到的@SqlMergeMode\n 5.9.3. 路径资源语法 每个path都会被翻译为Spring的Resource。一个相对路径（比如，\u0026quot;schema.sql\u0026quot;）会被当做classpath资源，他会跟测试类所在的包相关联。路径以斜杠开头会被当做绝对路径（比如\u0026quot;/org/example/schema.sql\u0026quot;）。一个路径引用了一个URL（比如，一个path以classpath:，file:，http:开头）会按照指定的资源协议来加载。\n下面的例子展示了在一个以JUnit Jupiter为基础的测试类中，类和方法都被@Sql修饰的例子：\n@SpringJUnitConfig\r@Sql(\u0026quot;/test-schema.sql\u0026quot;)\rclass DatabaseTests {\r@Test\rvoid emptySchemaTest() {\r// run code that uses the test schema without any test data\r}\r@Test\r@Sql({\u0026quot;/test-schema.sql\u0026quot;, \u0026quot;/test-user-data.sql\u0026quot;})\rvoid userTest() {\r// run code that uses the test schema and test data\r}\r}\r 5.9.4. 默认脚本检测 如果@Sql注解没有声明任何脚本或者资源位置，那么会去检测默认的脚本位置，具体默认位置取决于注解申明位置，在类和方法上略有区别。如果没有在默认位置找到对应的sql脚本，会抛出IllegalStateException异常。\n 类级别的申明：如果注解的测试类是com.example.MyTest，那么对应的默认脚本就是classpath:com/example/MyTest.sql。 方法级别的申明：如果注解的方法叫做testMethod()并且它是定义在com.example.MyTest类中，那么对应的默认脚本是classpath:com/example/MyTest.testMethod.sql。  5.9.5. 申明多个@Sql集 如果你需要对一个测试类或者测试方法配置多个SQL脚本集合，他们可能有不同的语法配置，不同的异常处理规则，或者不同的执行阶段，你可以申明多个@Sql实例。如果是Java 8 ，那么你可以重复使用@Sql注解。否则，你需要使用@SqlGroup注解去包含多个@Sql实例。\n下面的例子是Java 8的重复注解申明：\n@Test\r@Sql(scripts = \u0026quot;/test-schema.sql\u0026quot;, config = @SqlConfig(commentPrefix = \u0026quot;`\u0026quot;))\r@Sql(\u0026quot;/test-user-data.sql\u0026quot;)\rvoid userTest() {\r// run code that uses the test schema and test data\r}\r 在上面的例子中，test-schema.sql脚本使用了一个不同的语法：单行注释。\n下面的例子跟之前的例子相同，只不过是@Sql被@SqlGroup包装了一下。上面的例子在Java8的背景下，@SqlGroup是可选的，但是为了兼容性，比如需要兼容Kotlin，那么你只能选择@SqlGroup。\n@Test\r@SqlGroup({\r@Sql(scripts = \u0026quot;/test-schema.sql\u0026quot;, config = @SqlConfig(commentPrefix = \u0026quot;`\u0026quot;)),\r@Sql(\u0026quot;/test-user-data.sql\u0026quot;)\r)}\rvoid userTest() {\r// run code that uses the test schema and test data\r}\r 5.9.6. 脚本执行阶段 默认情况下@Sql的脚本都是在测试方法之前执行的，如果你需要在测试方法之后执行（比如，清楚数据库状态），那么@Sql的属性executionPhase可以帮到你。\n@Test\r@Sql(\rscripts = \u0026quot;create-test-data.sql\u0026quot;,\rconfig = @SqlConfig(transactionMode = ISOLATED)\r)\r@Sql(\rscripts = \u0026quot;delete-test-data.sql\u0026quot;,\rconfig = @SqlConfig(transactionMode = ISOLATED),\rexecutionPhase = AFTER_TEST_METHOD\r)\rvoid userTest() {\r// run code that needs the test data to be committed\r// to the database outside of the test's transaction\r}\r 注意ISOLATED和AFTER_TEST_METHOD是分别从Sql.TransactionMode和Sql.ExecutionPhase静态导入的。\n5.9.7. 通过@SqlConfig进行脚本配置 你可以配置脚本解析或者异常处理通过使用@SqlConfig注解。当作为一个类级别的注解申明时，@SqlConfig服务于整个测试类的层次结构，对其中的所有SQL脚本生效。当通过config属性直接申明到@Sql注解里的时候，@SqlConfig作为一个本地配置服务，只对@Sql注解范围内的SQL脚本生效。每个@SqlConfig的属性都有一个隐性的默认值。因为Java语言规范中定义的注解属性规则，注解属性是不能分配null值的。因此，为了支持覆盖继承的全局属性，@SqlConfig属性有一个显性的默认值为 \u0026ldquo;\u0026quot;(字符串)，{}(数组)，或者DEFAULT(枚举)。这种方法允许本地的@SqlConfig提供除了\u0026rdquo;\u0026quot;，{}，或者DEFAULT以外的值来选择性的覆盖来自全局的每个属性。只要本地@SqlConfig没有提供一个显性的属性值（\u0026quot;\u0026quot;,{},DEFAULT除外），那么对应属性仍然从全局继承。\n@Sql和@SqlConfig提供的配置选项跟ScriptUtils和ResourceDatabasePopulator提供的相等，但是是\u0026lt;jdbc:initialize-database/\u0026gt;提供的XML命名空间元素的超集。详情参考@Sql 和@SqlConfig\n5.9.8. @Sql的事务管理 默认情况下，SqlScriptsTestExecutionListener会推断@Sql配置的脚本期望的事务语义。具体来说，SQL脚本没有运行在一个事务中，但在一个Spring管理的事务中（举个例子，一个由TransactionalTestExecutionListener管理的事务，当测试被@Transactional注解修饰时），或者在一个隔离的事务当中，取决于@SqlConfig属性transactionMode的取值和测试ApplicationContext中是否有PlatformTransactionManager存在。就算最低的要求，也需要一个javax.sql.DataSource在测试ApplicationContext中存在。\n如果SqlScriptsTestExecutionListener使用的算法通过检测DataSource和PlatformTransactionManager来推断的事务语义不符合你的需求，你可以指定显式名称通过设置@SqlConfig的属性dataSource和transactionManager。此外，你可以空值事务的传播方式通过设置@SqlConfig的transactionMode属性（比如，是否脚本应该运行在一个隔离的事务中）。详情参考@SqlConfig 和 SqlScriptsTestExecutionListener\n@SpringJUnitConfig(TestDatabaseConfig.class)\r@Transactional\rclass TransactionalSqlScriptsTests {\rfinal JdbcTemplate jdbcTemplate;\r@Autowired\rTransactionalSqlScriptsTests(DataSource dataSource) {\rthis.jdbcTemplate = new JdbcTemplate(dataSource);\r}\r@Test\r@Sql(\u0026quot;/test-data.sql\u0026quot;)\rvoid usersTest() {\r// verify state in test database:\rassertNumUsers(2);\r// run code that uses the test data...\r}\rint countRowsInTable(String tableName) {\rreturn JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);\r}\rvoid assertNumUsers(int expected) {\rassertEquals(expected, countRowsInTable(\u0026quot;user\u0026quot;),\r\u0026quot;Number of rows in the [user] table.\u0026quot;);\r}\r}\r 注意这里不需要在执行完userTest()方法后清理数据库，因为所有对数据库的修改（不管是测试方法中的，还是/test-data.sql脚本中的）都会由TransactionalTestExecutionListener自动回滚。\n5.9.9. @SqlMergeMode合并或者覆盖配置 从Spring Framework 5.2开始，合并方法级别的和类级别的@Sql申明成为可能。比如说，这能让你为每个测试类提供一次数据库schema配置或者提供一些常见的测试数据，然后在每个测试方法提供指定的测试数据。要开启@Sql合并，在你的测试类或者方法上修饰@SqlMergeMode(MERGE)。要为指定的方法或者子类关闭合，你可以设置模式为@SqlMergeMode(OVERRIDE)。\n5.10. 并发测试执行 Spring Framework 5.0引入了在单个JVM中并发执行测试的基础支持，当然是使用Spring TestContext框架前提下。一般来说，这意味着大多数测试类或者测试方法都可以在不修改任何测试代码或者配置的前提下并发的执行。\n 怎样设置并发测试执行，详情可以参考你使用的测试框架，构建工具，或者IDE。\n 记住在你的测试套件中引入并发可能会导致一些意想不到的副作用，奇怪的运行时行为，和间歇的测试失败或者产生随机性。因此Spring团队对于何时不适于使用并发测试有以下总结：\n 使用Spring框架的@DirtiesContext。 使用Spring Boot的@MockBean或者@SpyBean。 使用JUnit 4的@FixMethodOrder或者任何是设计来确保测试方法按照指定顺序执行的框架特征。注意，当整个测试类是并发运行的时候，并不适用。 改变共享服务或者系统的状态（比如数据库，消息代理，文件系统等等）。这适用于集成或者外部系统。   如果并发测试执行失败过后，当前测试的ApplicationContext不再可用，这通常意味着ApplicationContext在另一个线程中被从ContextCache中移除了。\n这可能是因为@DirtiesContext或者是ContextCache自动清除的。如果@DirtiesContext是罪魁祸首，你要么避免使用@DirtiesContext，要么避免使用并发测试。如果是由于ContextCache已经超过最大容量，你可以增加缓存数量的最大值。\n  在Spring TestContext框架中测试要并发执行，只有底层TestContext实现提供了一个 copy constructor时才有效(参考javadoc )。但是，如果使用第三方提供的自定义TestContext实现，你需要验证它是否适配并发测试的执行。\n 5.11. TestContext 框架支持类 这个章节描述了Spring TestContext框架支持的各种类。\n5.11.1. Spring JUnit 4 Runner TestContext框架提供了完整的JUnit 4集成，通过一个自定义的runner（在JUnit4.12或者更高版本支持）。通过修饰测试@RunWith(SpringJUnit4ClassRunner.class)或者更短的变体@RunWith(SpringRunner.class)，开发者可以实现JUnit 4为基础的单元和集成测试并且同事获得TestContext框架带来的好处，比如加载ApplicationContext，测试示例的依赖注入，测试方法的事务管理等等。如果你想使用其他的runner（比如JUnit 4的Parameterizedrunner）或者第三方的runner（比如MockitoJUnitRunner），更多参考Spring’s support for JUnit rules\n下面的代码展示了配置一个测试类运行自定义SpringRunner的最低需求：\n@RunWith(SpringRunner.class)\r@TestExecutionListeners({})\rpublic class SimpleTest {\r@Test\rpublic void testMethod() {\r// test logic...\r}\r}\r 上面的例子中@TestExecutionListeners被配置为一个空的list，这样会关闭所有默认的listener，否则需要通过@ContextConfiguration配置一个ApplicationContext。\n5.11.2. Spring JUnit 规则 org.springframework.test.context.junit4.rules包提供了以下JUnit 4规则（在JUnit4.12或者更高版本支持）：\n SpringClassRule SpringMethodRule  SpringClassRule是一个JUnitTestRule，他支持TestContext框架类级别的特征，但是SpringMethodRule是一个JUnitMethodRule，他支持TestContext框架实例级别或者方法级别的特征。\n相对于SpringRunner，Spring规则基础的Junit支持具有独立于任何org.junit.runner.Runner实现的有点，因此，可以和已存在的runner（比如JUnit4的Parameterized）或者第三方的runner结合使用（MockitoJUnitRunner）。\n为了支持TestContext框架的完整功能，你必须结合一个SpringClassRule和一个SpringMethodRule。下面的例子展示了在继承测试中如何正确的申明这些规则：\n// Optionally specify a non-Spring Runner via @RunWith(...)\r@ContextConfiguration\rpublic class IntegrationTest {\r@ClassRule\rpublic static final SpringClassRule springClassRule = new SpringClassRule();\r@Rule\rpublic final SpringMethodRule springMethodRule = new SpringMethodRule();\r@Test\rpublic void testMethod() {\r// test logic...\r}\r}\r 5.11.3. JUnit 4 支持类 org.springframework.test.context.junit4为JUnit4(在JUnit4.12或者更高版本支持)为基础的测试案例提供了以下支持类：\n AbstractJUnit4SpringContextTests AbstractTransactionalJUnit4SpringContextTests  AbstractJUnit4SpringContextTests是一个抽象测试基类，他集成了在JUnit 4环境的TestContext框架带有显式的ApplicationContext测试支持。当你extendAbstractJUnit4SpringContextTests，你可以访问一个protected``applicationContext实例参数，用它来执行显式的bean查找或者测试整个上下文的状态。\nAbstractTransactionalJUnit4SpringContextTests是对AbstractJUnit4SpringContextTests的一个抽象事物的扩展，它新增了一些有关JDBC的便捷访问。这个类需要ApplicationContext中定义了一个javax.sql.DataSourcebean和一个PlatformTransactionManagerbean。当你extendAbstractTransactionalJUnit4SpringContextTests，你可以访问一个protected``jdbcTemplate实例参数，你可以用它来跑SQL语句。你可以在数据库相关代码运行前后确定数据库的状态，Spring会确保应用代码的query在相同的事务中。当配合ORM工具使用时，需要确保避免false positives，之前提到过。AbstractTransactionalJUnit4SpringContextTests也提供了快捷方法，他们都是委托JdbcTestUtils的方法完成的通过前面提到的jdbcTemplate。此外，AbstractTransactionalJUnit4SpringContextTests提供了一个executeSqlScript(..)方法可以运行SQL脚本。\n 这些类方便了扩展。但是如果你不像你的测试类跟Spring指定的类结构绑定，那么你可以通过@RunWith(SpringRunner.class)或者 Spring’s JUnit rules。\n 5.11.4. SpringExtension for JUnit Jupiter TestContext框架为JUnit5引入的JUnit Jupiter测试框架提供了完整的集成。通过注解测试类@ExtendWith(SpringExtension.class)，你可以实现标准的JUnit Jupiter为基础的单元或者集成测试同事也可以从TestContext框架中受益。\n此外，多亏了JUnit Jupiter丰富的扩展，Spring提供了以下特征，它比Spring对JUnit4和TestNG特征的支持要更多更完善：\n 测试构造方法，测试方法，和测试声明周期回调方法的依赖注入。详情参考Dependency Injection with SpringExtension 强力支持基于SpEL表达式的条件化测试执行 ，环境变量，系统属性等等。参考@EnabledIf和@DisabledIf在Spring JUnit Jupiter Testing Annotations 中 自定义复合注解由Spring和JUnit Jupiter的注解组成。参考@TransactionalDevTestConfig和@TransactionalIntegrationTest的例子在Meta-Annotation Support for Testing  下面的例子是一个使用实例：\n// Instructs JUnit Jupiter to extend the test with Spring support.\r@ExtendWith(SpringExtension.class)\r// Instructs Spring to load an ApplicationContext from TestConfig.class\r@ContextConfiguration(classes = TestConfig.class)\rclass SimpleTests {\r@Test\rvoid testMethod() {\r// test logic...\r}\r}\r 因为你也可以使用JUnit 5的注解作为元注解，所以Spring提供了@SpringJUnitConfig和@SpringJUnitWebConfig他们组合了必要的注解。\n下面是一个@SpringJUnitConfig的例子：\n// Instructs Spring to register the SpringExtension with JUnit\r// Jupiter and load an ApplicationContext from TestConfig.class\r@SpringJUnitConfig(TestConfig.class)\rclass SimpleTests {\r@Test\rvoid testMethod() {\r// test logic...\r}\r}\r 同样的，下面是一个@SpringJUnitWebConfig例子，为JUnit Jupiter创建了一个WebApplicationContext：\n// Instructs Spring to register the SpringExtension with JUnit\r// Jupiter and load a WebApplicationContext from TestWebConfig.class\r@SpringJUnitWebConfig(TestWebConfig.class)\rclass SimpleWebTests {\r@Test\rvoid testMethod() {\r// test logic...\r}\r}\r 详情参考Spring JUnit Jupiter Testing Annotations\n5.11.5. Dependency Injection with SpringExtension SpringExtension实现了来自JUnit Jupiter的ParameterResoler扩展API，它让Spring为测试构造函数，测试方法，和测试生命周期回调函数提供了依赖注入。\n具体来说，SpringExtension你可以注入来自测试的ApplicationContext中的依赖到测试构造函数和被@BeforeAll, @AfterAll, @BeforeEach, @AfterEach, @Test, @RepeatedTest, @ParameterizedTest，和其他注解修饰的方法中。\n构造函数注入 如果构造器中的指定参数是ApplicationContext类型（或者其子类型）或者是其被以下注解或者元注解修饰：@Autowired，@Qualifier，或者@Value，Spring会根据来自测试ApplicationContext中对应bean或者value来注入值。\nSpring可以为测试类的构造函数配置自动装配所有的参数，如果构造函数是考虑成为自动装配化的。一个构造函数是否考虑自动装配化，下面的条件有一个满足就可以（按优先顺序）。\n 构造函数被@Autowired修饰。 @TestConstructor注解在测试类上存在或者他的元注解，并且autowireMode属性要为ALL。 默认的测试构造函数自动装配模式改为了ALL。  详情参考@TestConstructor\n 如果测试类的构造函数考虑成为自动装配化的，Spring会承担构造函数所有参数的解析工作。这会导致，这样的构造函数不会有其他通过JUnit Jupiter注册的ParameterResolver能够解析他的参数。\n  如果测试方法申明了@DirtiesContext来在方法执行前或者执行后关闭ApplicationContext，那么就不能将构造器注入和JUnit Jupiter的@TestInstance(PER_CLASS)配合使用。\n原因是因为@TestInstance(PER_CLASS)让JUnit Jupiter去缓存了测试方法调用之间的测试实例。因此，测试实例将会保留即将被关闭的ApplicationContext中的bean引用。因为在这种场景下，测试类的构造器只会被调用一次，依赖注入不会再次执行，接下来的测试交互的都是一个关闭的ApplicationContext，会直接抛出异常。\n要配合@TestInstance(PER_CLASS)使用before test method或者after test method模式的@DirtiesContext，必须要通过字段或者setter方式的依赖注入，这样就能在测试方法调用之间重新注入。\n 下面的例子中，Spring注入来自ApplicationContext的OrderServicebean到OrderServiceIntegrationTests构造方法中。\n@SpringJUnitConfig(TestConfig.class)\rclass OrderServiceIntegrationTests {\rprivate final OrderService orderService;\r@Autowired\rOrderServiceIntegrationTests(OrderService orderService) {\rthis.orderService = orderService;\r}\r// tests that use the injected OrderService\r}\r 注意这个特征让测试依赖成为final，因此不能更改。\n如果spring.test.constructor.autowire.mode属性值是all(详情参考@TestConstructor )，我们可以忽略之前例子中构造方法上的@Autowired，结果如下：\n@SpringJUnitConfig(TestConfig.class)\rclass OrderServiceIntegrationTests {\rprivate final OrderService orderService;\rOrderServiceIntegrationTests(OrderService orderService) {\rthis.orderService = orderService;\r}\r// tests that use the injected OrderService\r}\r 方法注入 如果JUnit Jupiter测试方法或者测试声明周期回调方法的一个参数是ApplicationContext类型（或者是其子类型）或者是被一下注解或元注解修饰的：@Autowird，@Qualifier，或者@Value，Spring会为指定的参数注入ApplicationContext中对应的bean。\n下面的就是一个方法注入的实例：\n@SpringJUnitConfig(TestConfig.class)\rclass OrderServiceIntegrationTests {\r@Test\rvoid deleteOrder(@Autowired OrderService orderService) {\r// use orderService from the test's ApplicationContext\r}\r}\r 因为在JUnit Jupiter中对ParameterResolver支持的稳健性，你可以有多个依赖注入到单个方法中，不仅是来自Spring，也可以是来自JUnit Jupiter或者其他第三方的扩展。\n下面的例子展示如何同时有Spring和JUnit Jupiter的注入到同一个测试方法中：\n@SpringJUnitConfig(TestConfig.class)\rclass OrderServiceIntegrationTests {\r@RepeatedTest(10)\rvoid placeOrderRepeatedly(RepetitionInfo repetitionInfo,\r@Autowired OrderService orderService) {\r// use orderService from the test's ApplicationContext\r// and repetitionInfo from JUnit Jupiter\r}\r}\r 注意使用来自JUnit Jupiter的@RepeatedTest，可以让方法有权限访问RepetitionInfo。\n5.11.6. @Nested测试类配置 从Spring Framework 5.0开始，Spring TestContext框架支持在JUnit Jupiter的@Nested测试类上使用测试相关的注解；但是，直到Spring Framework5.3，类级别的测试配置注解才从封闭类继承而来，就像他们继承来自父类的一样。\nSpring Framework 5.3 引入了良好的内部类配置继承支持，并且将会默认启用。要改变默认的INHERIT模式为OVERRIDE模式，你可以给每个@Nested测试类添加一个@NestedTestConfiguration(EnclosingConfiguration.OVERRIDE)。一个显式@NestedTestConfiguration申明不仅对注解修饰的测试类有效也对其子类和集成的类有效。因此，你可以用@NestedTestConfiguration注解修饰顶级测试类，让后递归应用到其所有集成的测试类上。\n为了允许开发团队修改默认的模型为OVERRIDE——举个例子，为了兼容Spring Framework 5.0到5.2——默认的模型可以全局修改通过JVM系统属性或者一个在classpath根路径下的spring.properties文件。详情参考\u0026ldquo;Changing the default enclosing configuration inheritance mode\u0026rdquo;\n下面的Hello World例子是非常简单的，他展示了怎样申明常用的配置到顶级类上，方便它的集成类能够继承这些配置。在这个例子中，只有TestConfig配置类是继承的。每个集成测试类提供了它自己的激活配置文件，结果就是每个继承测试类都有一个不同的ApplicationContext。\n@SpringJUnitConfig(TestConfig.class)\rclass GreetingServiceTests {\r@Nested\r@ActiveProfiles(\u0026quot;lang_en\u0026quot;)\rclass EnglishGreetings {\r@Test\rvoid hello(@Autowired GreetingService service) {\rassertThat(service.greetWorld()).isEqualTo(\u0026quot;Hello World\u0026quot;);\r}\r}\r@Nested\r@ActiveProfiles(\u0026quot;lang_de\u0026quot;)\rclass GermanGreetings {\r@Test\rvoid hello(@Autowired GreetingService service) {\rassertThat(service.greetWorld()).isEqualTo(\u0026quot;Hallo Welt\u0026quot;);\r}\r}\r}\r 5.11.7. TestNG支持类 org.springframework.test.context.testng为TestNG为基础的测试案例提供了以下支持类：\n AbstractTestNGSpringContextTests AbstractTransactionalTestNGSpringContextTests  AbstractTestNGSpringContextTests是一个抽象测试基类，他集成了在TestNG环境的TestContext框架带有显式的ApplicationContext测试支持。当你extendAbstractTestNGSpringContextTests，你可以访问一个protected``applicationContext实例参数，用它来执行显式的bean查找或者测试整个上下文的状态。\nAbstractTransactionalTestNGSpringContextTests是对AbstractTestNGSpringContextTests的一个抽象事物的扩展，它新增了一些有关JDBC的便捷访问。这个类需要ApplicationContext中定义一个javax.sql.DataSourcebean和一个PlatformTransactionManagerbean。当你extendAbstractTransactionalTestNGSpringContextTests，你可以访问一个protected``jdbcTemplate实例参数，你可以用它来跑SQL语句。你可以在数据库相关代码运行前后确定数据库的状态，Spring会确保应用代码的query在相同的事务中。当配合ORM工具使用时，需要确保避免false positives，之前提到过。AbstractTransactionalTestNGSpringContextTests也提供了快捷方法，他们都是委托JdbcTestUtils的方法完成的通过前面提到的jdbcTemplate。此外，AbstractTransactionalTestNGSpringContextTests提供了一个executeSqlScript(..)方法可以运行SQL脚本。\n 这些类方便了扩展。如果你不想你的测试类和Spring指定的类结构绑定，你可以配置你自己的自定义测试类，通过使用@ContextConfiguration,@TestExecutionListeners等，并且通过TestContextManager手动检测你的测试类。关于如何检测你的测试类，参考AbstractTestNGSpringContextTests源码。\n 6. WebTestClient WebTestClient是一个设计用于测试服务应用的HTTP客户端。它包装了Spring的WebClient ，并且用它来执行请求，并且暴露一个验证response的测试门面。WebTestClient可以用来执行端对端的HTTP测试。它也可以用来测试Spring MVC和Spring WebFlux应用，而且不需要运行服务，通过模拟请求和返回对象。\n Kotlin用户：查看this section 相关的WebTestClient使用。\n 6.1. 配置 要配置一个WebTestClient，你需要选择一个服务配置来绑定。这可以是众多模拟服务器配置中的一个或者一个实时线上服务器的连接。\n绑定到Controller 这个配置允许你测试指定的controller通过虚拟的request和response对象，并且不需要运行服务。\n对于WebFlux应用，使用下面的代码加载基础框架等于WebFlux Java config ，注册给定的controller，然后创建一个WebHandler chain 去处理request：\nWebTestClient client =\rWebTestClient.bindToController(new TestController()).build();\r 对于Spring MVC，使用下面的代码委托StandaloneMockMvcBuilder去加载与WebMvc Java config 等效的基础架构，注册给定的controller，并且创建一个MockMvc 实例去处理request：\nWebTestClient client =\rMockMvcWebTestClient.bindToController(new TestController()).build();\r 绑定到 ApplicationContext 这个配置允许你通过Spring MVC或者Spring WebFlux基础框架和controller申明来加载Spring配置，并且通过模拟的request和response对象处理去处理请求，而无需运行服务。\n对于WebFlux，使用以下内容传递SpringApplicationContext到WebHttpHandlerBuilder 中去创建WebHandler chain 以处理请求：\n@SpringJUnitConfig(WebConfig.class) class MyTests {\rWebTestClient client;\r@BeforeEach\rvoid setUp(ApplicationContext context) { client = WebTestClient.bindToApplicationContext(context).build(); }\r}\r 对于Spring MVC，使用以下内容传递SpringApplicationContext到MockMvcBuilders.webAppContextSetup 去创建一个MockMvc 实例以处理请求：\n@ExtendWith(SpringExtension.class)\r@WebAppConfiguration(\u0026quot;classpath:META-INF/web-resources\u0026quot;) @ContextHierarchy({\r@ContextConfiguration(classes = RootConfig.class),\r@ContextConfiguration(classes = WebConfig.class)\r})\rclass MyTests {\r@Autowired\rWebApplicationContext wac; WebTestClient client;\r@BeforeEach\rvoid setUp() {\rclient = MockMvcWebTestClient.bindToApplicationContext(this.wac).build(); }\r}\r 绑定到 Router Function 这个配置允许你在不启动服务的情况下通过模拟request和response对象测试functional endpoints\n对于WebFlux，使用下面内容委托给RouterFunctions.toWebHandler去创建一个服务配置以处理请求：\nRouterFunction\u0026lt;?\u0026gt; route = ...\rclient = WebTestClient.bindToRouterFunction(route).build();\r 对于Spring MVC，目前还没有测试WebMvc functional endpoints 的选项。\n绑定到服务器 这个配置连接到一个运行的服务上以进行完整的，端对端的HTTP测试：\nclient = WebTestClient.bindToServer().baseUrl(\u0026quot;http://localhost:8080\u0026quot;).build();\r 客户端配置 除了之前梯级的服务配置以外，你还可以配置客户端选项，包括 base URL，默认 headers，客户端过滤器等等。这些选项在bindToServcer()之后都是很容易获得的。对于其他配置选项，你可以使用configureClient()将服务转为客户端配置：\nclient = WebTestClient.bindToController(new TestController())\r.configureClient()\r.baseUrl(\u0026quot;/test\u0026quot;)\r.build();\r 6.2. 写测试 直到通过exchange()执行请求为止，WebTestClient提供和WebClient 相同的API。参考WebClient 文档以查找如何准备一个有任何内容的请求，包括 form data， multipart data，等等。\n在调用exchange()之后，WebTestClient从WebClient偏离，转变工作流的方向去验证response。\n使用下面内容去断言response的状态和header：\nclient.get().uri(\u0026quot;/persons/1\u0026quot;)\r.accept(MediaType.APPLICATION_JSON)\r.exchange()\r.expectStatus().isOk()\r.expectHeader().contentType(MediaType.APPLICATION_JSON)\r 然后你可以通过下面任何一种方法去解码reponse的body：\n expectBody(Class)：解码为单个对象。 expectBodyList(Class)：解码并收集对象到List。 expectBody()：解码到JSON Content 或者一个空的body byte[]  然后在高等级的结果对象上执行断言：\nclient.get().uri(\u0026quot;/persons\u0026quot;)\r.exchange()\r.expectStatus().isOk()\r.expectBodyList(Person.class).hasSize(3).contains(person);\r 如果内置的断言效率太低，你还可以用其他的断言代替：\nimport org.springframework.test.web.reactive.server.expectBody\rclient.get().uri(\u0026quot;/persons/1\u0026quot;)\r.exchange()\r.expectStatus().isOk()\r.expectBody(Person.class)\r.consumeWith(result -\u0026gt; {\r// custom assertions (e.g. AssertJ)...\r});\r 或者你可以退出工作流，并获取一个EntityExchangeResult：\nEntityExchangeResult\u0026lt;Person\u0026gt; result = client.get().uri(\u0026quot;/persons/1\u0026quot;)\r.exchange()\r.expectStatus().isOk()\r.expectBody(Person.class)\r.returnResult();\r  当你需要解码的目标类型是一个泛型时，请寻找接受ParameterizedTypeReference 而不是Class\u0026lt;T\u0026gt;的重载方法\n No Content 如果不期待response会返回任何内容，你可以这样断言：\nclient.post().uri(\u0026quot;/persons\u0026quot;)\r.body(personMono, Person.class)\r.exchange()\r.expectStatus().isCreated()\r.expectBody().isEmpty();\r 如果需要忽略response内容，下面就是是释放内容并不需要任何断言：\nclient.get().uri(\u0026quot;/persons/123\u0026quot;)\r.exchange()\r.expectStatus().isNotFound()\r.expectBody(Void.class);\r JSON Content 你可以使用expectBody()，他没有目标类型，他断言的目标是为加工的内容而不是高等级的对象。\n用JSONAssert 验证完整的JSON内容：\nclient.get().uri(\u0026quot;/persons/1\u0026quot;)\r.exchange()\r.expectStatus().isOk()\r.expectBody()\r.json(\u0026quot;{\\\u0026quot;name\\\u0026quot;:\\\u0026quot;Jane\\\u0026quot;}\u0026quot;)\r 用JSONPath 验证JSON内容：\nclient.get().uri(\u0026quot;/persons\u0026quot;)\r.exchange()\r.expectStatus().isOk()\r.expectBody()\r.jsonPath(\u0026quot;$[0].name\u0026quot;).isEqualTo(\u0026quot;Jane\u0026quot;)\r.jsonPath(\u0026quot;$[1].name\u0026quot;).isEqualTo(\u0026quot;Jason\u0026quot;);\r Streaming Responses 要测试一个可能无穷尽的流，比如说\u0026quot;text/event-stream\u0026quot;或者\u0026quot;application/x-ndjson\u0026quot;，通过验证response状态和header开始，然后获取一个FluxExchangeResult：\nFluxExchangeResult\u0026lt;MyEvent\u0026gt; result = client.get().uri(\u0026quot;/events\u0026quot;)\r.accept(TEXT_EVENT_STREAM)\r.exchange()\r.expectStatus().isOk()\r.returnResult(MyEvent.class);\r 现在你已经准备好通过来自reactor-test的StepVerifier去消耗response流了：\nFlux\u0026lt;Event\u0026gt; eventFlux = result.getResponseBody();\rStepVerifier.create(eventFlux)\r.expectNext(person)\r.expectNextCount(4)\r.consumeNextWith(p -\u0026gt; ...)\r.thenCancel()\r.verify();  MockMvc断言 WebTestClient是一个HTTP客户端，因此他只能验证客户端的response，包括状态，head,和body。\n当用一个MockMVC服务配置测试一个Spring MVC应用时，你有一个额外的选择可以在服务response上执行更多的断言。通过在断言body后获取一个ExchangeResult来实现：\n// For a response with a body\rEntityExchangeResult\u0026lt;Person\u0026gt; result = client.get().uri(\u0026quot;/persons/1\u0026quot;)\r.exchange()\r.expectStatus().isOk()\r.expectBody(Person.class)\r.returnResult();\r// For a response without a body\rEntityExchangeResult\u0026lt;Void\u0026gt; result = client.get().uri(\u0026quot;/path\u0026quot;)\r.exchange()\r.expectBody().isEmpty();\r 然后切换到MockMvc服务response断言：\nMockMvcWebTestClient.resultActionsFor(result)\r.andExpect(model().attribute(\u0026quot;integer\u0026quot;, 3))\r.andExpect(model().attribute(\u0026quot;string\u0026quot;, \u0026quot;a string value\u0026quot;));\r 7. MockMvc Spring MVC Test 框架，也叫作MockMvc，为测试Spring MVC应用提供了支持。他执行了完整的Spring MVC请求处理，但是是通过模拟的request和response对象从而代替一个运行的服务。\nMockMvc可以用在它自己身上去支持请求和response验证。它也可以通过WebTestClient来使用，他是通过插入到WebTestClient中作为处理请求的服务。WebTestClient带来的好处是可以不用再看着未加工的数据，可以将response body解码到高等级对象中，并且还可以切换到完整的端对端的HTTP测试，并且使用的是相同的测试API。\n7.1. 大纲 你可以在普通的单元测试中使用controller，通过初始化一个controller，注入他的依赖，并调用他的方法。 但是，这样的测试不能验证 request mappings, data binding, message conversion, type conversion, validation, 并且不能涉及任何支持@InitBinder，@ModelAttribute，或者@ExceptionHandler的方法。\nSpring MVC Test框架，也叫MockMVC，旨在不需要运行服务的情况下提供更完整的Spring MVC controller测试支持。这是通过调用DispacherServlet并且传递了一个来自spring-test模组的模拟的Servlet API实现 ，它复制了完整的Spring MVC请求处理逻辑，并且不需要启动服务。\nMockMvc 是一个服务端的测试框架，他通过使用轻量和目标性的测试可以让你验证Spring MVC应用的大多数功能。\n静态导入 当使用MockMvc直接执行请求时，你会需要静态导入：\n MockMvcBuilders.* MockMvcRequestBuilders.* MockMvcResultMatchers.* MockMvcResultHandlers.*  一个简单的方法去记住这些类，可以通过ide搜索MockMvc*。\n当通过WebTestClient使用MockMvc时，你不需要静态导入。WebTestClient提供了流畅的API并且不需要静态导入。\n配置选择 MockMvc可以有两个方法可以配置。一个是直接指出你想要测试的controller，并且以编程的方式配置Spring MVC基础结构。另外一个是指出带有Spring MVC和controller基础结构的Spring配置。\n配置MockMvc去测试一个指定的controller：\nclass MyWebTests {\rMockMvc mockMvc;\r@BeforeEach\rvoid setup() {\rthis.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();\r}\r// ...\r}\r 当通过WebTestClient使用时，也可以使用这个配置，它会委托给跟上面相同的构造器。\n通过Spring配置来初始化MockMvc：\n@SpringJUnitWebConfig(locations = \u0026quot;my-servlet-context.xml\u0026quot;)\rclass MyWebTests {\rMockMvc mockMvc;\r@BeforeEach\rvoid setup(WebApplicationContext wac) {\rthis.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();\r}\r// ...\r}\r 或者在通过WebTestClient使用时仍然可以使用上面的配置，WebTestClient委托给跟上面相同的builder来完成。\n你应该使用哪个配置选项？\nwebAppContextSetup加载你实际的Spring MVC配置，生成一个更加完整的集成测试。因为TestContext框架加载了Spring配置，它帮助测试更快的运行，即使你在你的测试套件中引入了更多的测试。此外，你可以通过Spring配置注入模拟service到controller中以在web层测试上保持专注。下面的例子通过Mockito申明了一个模拟的service：\n\u0026lt;bean id=\u0026quot;accountService\u0026quot; class=\u0026quot;org.mockito.Mockito\u0026quot; factory-method=\u0026quot;mock\u0026quot;\u0026gt;\r\u0026lt;constructor-arg value=\u0026quot;org.example.AccountService\u0026quot;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r 然后你可以将这个模拟service注入到测试中，配置并验证你的期望结果：\n@SpringJUnitWebConfig(locations = \u0026quot;test-servlet-context.xml\u0026quot;)\rclass AccountTests {\r@Autowired\rAccountService accountService;\rMockMvc mockMvc;\r@BeforeEach\rvoid setup(WebApplicationContext wac) {\rthis.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();\r}\r// ...\r}\r 另一方面，standaloneSetup更接近于单元测试。他一次测试一个controller。你可以通过模拟依赖手动注入controller，并且不会涉及加载Spring配置。这样的测试更专注于样式，使得查看被测试的controller，或是任何指定的Spring MVC配置是否是运行的必要条件等等操作更加容易。用standaloneSetup写临时的测试去验证指定的操作或者debug一个问题都非常方便。\n像大多数的“集成测试和单元测试对比”的讨论，都没有完全正确或者错误的答案。但是，使用standaloneSetup确实会需要一些额外的webAppContextSetup测试，这是为了验证你的Spring MVC配置。当然，你也可以把所有的测试都用webAppContextSetup来写，可以让你的测试都是基于实际的Spring MVC配置进行。\n配置特征 不管使用哪种MockMvc构建方法，所有的MockMvcBuilder实现都提供了一些常用并且非常有用的特征。比如，你可以为所有的request申明一个Acceptheader并且假定所有response的状态都是200并且还带一个Content-typeheader：\n// static import of MockMvcBuilders.standaloneSetup\rMockMvc mockMvc = standaloneSetup(new MusicController())\r.defaultRequest(get(\u0026quot;/\u0026quot;).accept(MediaType.APPLICATION_JSON))\r.alwaysExpect(status().isOk())\r.alwaysExpect(content().contentType(\u0026quot;application/json;charset=UTF-8\u0026quot;))\r.build();\r 此外，第三方框架（和应用）可以预包装配置指令，就像MockMvcConfigurer中的一样。Spring框架也有一个继承的实现，可以帮助你在request之间保存和复用HTTP session：\n// static import of SharedHttpSessionConfigurer.sharedHttpSession\rMockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())\r.apply(sharedHttpSession())\r.build();\r// Use mockMvc to perform requests...\r 详情参考ConfigurableMockMvcBuilder 列出了所有MockMvc builder的特征。\n执行请求 这个章节讲述MockMvc自身怎样执行请求和验证response。如果是通过WebTestClient使用，可以参考之前的章节。\n使用任何HTTP方法执行请求：\nmockMvc.perform(post(\u0026quot;/hotels/{id}\u0026quot;, 42).accept(MediaType.APPLICATION_JSON));\r 你也可以执行文件上传请求，它内部使用的是MockMultipartHttpServletRequest，没有实际解析一个multipart request：\nmockMvc.perform(multipart(\u0026quot;/doc\u0026quot;).file(\u0026quot;a1\u0026quot;, \u0026quot;ABC\u0026quot;.getBytes(\u0026quot;UTF-8\u0026quot;)));\r 你可以在URI模板样式中指定请求参数：\nmockMvc.perform(get(\u0026quot;/hotels?thing={thing}\u0026quot;, \u0026quot;somewhere\u0026quot;));\r 你可以通过下面的方式呈现参数：\nmockMvc.perform(get(\u0026quot;/hotels\u0026quot;).param(\u0026quot;thing\u0026quot;, \u0026quot;somewhere\u0026quot;));\r 如果应用代码依赖Servlet请求参数，并且没有清晰的检查请求string(大多数情况都是这样)，那么你选择那个方法都没有关系。但是，请记住，URI模板提供的请求参数是已经解码的，但是通过param(...)提供的请求参数 are expected to already be decoded。\n在大多数情况下，更偏向于将context path和Servlet path从请求URI中分离。如果你必须测试一个完整的请求URI，那么请确保contextPath和servletPath的准确性：\nmockMvc.perform(get(\u0026quot;/app/main/hotels/{id}\u0026quot;).contextPath(\u0026quot;/app\u0026quot;).servletPath(\u0026quot;/main\u0026quot;))\r 在上面的例子中，如果每个请求都附带contextPath和servletPath是十分笨重的。相对的，你可以提前设置好默认属性：\nclass MyWebTests {\rMockMvc mockMvc;\r@BeforeEach\rvoid setup() {\rmockMvc = standaloneSetup(new AccountController())\r.defaultRequest(get(\u0026quot;/\u0026quot;)\r.contextPath(\u0026quot;/app\u0026quot;).servletPath(\u0026quot;/main\u0026quot;)\r.accept(MediaType.APPLICATION_JSON)).build();\r}\r}\r 上面的属性通过MockMvc影响每一个请求执行。如果给定的请求指定了同样的属性，那么它会覆盖默认值。这就是为什么默认请求中的HTTP方法和URI无关紧要的原因，因为他们都必须在每个请求中指定。\n定义预期结果 你可以通过一个或者多个.andExpect(..)定义预期结果：\nmockMvc.perform(get(\u0026quot;/accounts/1\u0026quot;)).andExpect(status().isOk());\r MockMvcResultMatchers.*提供了很多预期结果，他们中的一些可以嵌套为更详情的结果。\n预期结果可以划分为两个大致的种类。一个是验证response的属性（比如，response status,header,和内容）。这是要断言的最重要的结果内容。\n第二个断言的分类超出了response的范围。这些断言让你检查Spring MVC指定的切面，比如哪个controller方法处理了这个请求，是否有异常出现并被处理，model的具体内容，那个view被选中，什么flash属性被添加等等。他们也能让你检查Servlet指定的切面，比如说request和session属性。\n下面的测试断言了绑定或者验证失败：\nmockMvc.perform(post(\u0026quot;/persons\u0026quot;))\r.andExpect(status().isOk())\r.andExpect(model().attributeHasErrors(\u0026quot;person\u0026quot;));\r 许多时候，转存执行测试请求后的结果都是非常有用的。你可以像下边这样做，print()是由MockMvcResultHandlers静态导入的：\nmockMvc.perform(post(\u0026quot;/persons\u0026quot;))\r.andDo(print())\r.andExpect(status().isOk())\r.andExpect(model().attributeHasErrors(\u0026quot;person\u0026quot;));\r 只要请求进程不会产生一个不能处理的异常，print()方法就会打印所有可用的结果数据到System.out中。这里有一个log()方法和两个额外的print()方法的变体，一个接收OutputStream，另外一个接收Writer。举个例子，调用print(System.err)打印结果到System.err，当调用print(myWriter)打印结果到一个自定义的writer。如果你想用log的形式而不是print，那么你可以调用log()方法，他会将结果数据作为一条单一的DEUBG信息在org.springframework.test.web.servlet.resultlogging目录下。\n某些情况你可能想直接获得结果对象进行验证，你可以通过.andReturn()，在所有的expect方法之后调用：\nMvcResult mvcResult = mockMvc.perform(post(\u0026quot;/persons\u0026quot;)).andExpect(status().isOk()).andReturn();\r// ...\r 如果所有的测试都检测一个预期结果，那么你可以在构建MockMvc时就设置默认的预期结果：\nstandaloneSetup(new SimpleController())\r.alwaysExpect(status().isOk())\r.alwaysExpect(content().contentType(\u0026quot;application/json;charset=UTF-8\u0026quot;))\r.build()\r 注意这些通用的预期结果始终都是可用的，并且不能够被覆盖，除非创建一个单独的MockMvc实例。\n当一个JSON response内容包含一个由Spring HATEOAS 创建的多媒体连接，你可以通过使用JsonPath表达式来验证结果连接：\nmockMvc.perform(get(\u0026quot;/people\u0026quot;).accept(MediaType.APPLICATION_JSON))\r.andExpect(jsonPath(\u0026quot;$.links[?(@.rel == 'self')].href\u0026quot;).value(\u0026quot;http://localhost:8080/people\u0026quot;));\r 当XML response内容包含一个由Spring HATEOAS 创建的多媒体连接，你可以通过使用XPath表达式验证结果连接。\nMap\u0026lt;String, String\u0026gt; ns = Collections.singletonMap(\u0026quot;ns\u0026quot;, \u0026quot;http://www.w3.org/2005/Atom\u0026quot;);\rmockMvc.perform(get(\u0026quot;/handle\u0026quot;).accept(MediaType.APPLICATION_XML))\r.andExpect(xpath(\u0026quot;/person/ns:link[@rel='self']/@href\u0026quot;, ns).string(\u0026quot;http://localhost:8080/people\u0026quot;));\r 异步请求 这个章节展示怎样使用MockMvc进行异步请求处理。如果通过WebTestClient使用MockMvc，那么是不需要特别处理的，因为默认就是异步请求。\nSpring MVC支持Servlet 3.0 异步请求 ，是通过退出Servlet容器线程，并允许应用异步计算response，然后通过异步调度去完成对Servlet容器线程的处理。\n在Spring MVC测试中，异步请求可以通过先断言产生的异步value开始，然后手动执行异步调度，并且最终验证response。下面的例子测试的controller方法返回的deferredResult，Callable，或者交互类型比如ReactorMono：\n@Test\rvoid test() throws Exception {\rMvcResult mvcResult = this.mockMvc.perform(get(\u0026quot;/path\u0026quot;))\r//检测response状态是仍然未改变的\r.andExpect(status().isOk()) //异步处理必须有一个started\r.andExpect(request().asyncStarted())\r//等待并断言异步结果\r.andExpect(request().asyncResult(\u0026quot;body\u0026quot;)) .andReturn();\r//手动执行异步调度（因为没有运行的容器）\rthis.mockMvc.perform(asyncDispatch(mvcResult))\r//验证最终response .andExpect(status().isOk()) .andExpect(content().string(\u0026quot;body\u0026quot;));\r}\r Streaming Response 在Spring MVC测试中是有没有选项去测试无容器的返回流的。但是你可以通过WebTestClient请求去测试流。在Spring Boot中你可以测试一个运行的服务 通过WebTestClient。另外一个优势是他有能力使用来自项目Reactor的StepVerifier，可以允许在流数据上申明预期结果。\n过滤器注册 当配置一个MockMvc实例时，你可以注册一个或者多个ServletFilter实例：\nmockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();\r 注册的过滤器是通过来自spring-test的MockFilterChain来调用的，并且最后一个过滤器委托给了DispacherServlet。\n更多代码实例 MockMvc ，WebTestClient\n8. 测试客户端应用 你可以使用客户端测试，它内部使用的是RestTemplate。这个逻辑是申明期待的请求和提供\u0026quot;stub\u0026quot;response，所以你可以在不运行服务的情况下检测代码。\nRestTemplate restTemplate = new RestTemplate();\rMockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();\rmockServer.expect(requestTo(\u0026quot;/greeting\u0026quot;)).andRespond(withSuccess());\r// Test code that uses the above RestTemplate ...\rmockServer.verify();\r 在之前的例子中，MockRestServiceServer（客户端REST测试的核心类）用一个自定义的ClientHttpRequestFactory配置了RestTemplate，并断言了一个预期的真实请求和返回\u0026quot;stub\u0026quot;response。在这个案例中，我们期待一个到/greeting的请求，并且希望返回一个200 response，并带着text/plain内容。我们可以根据需要定义其他的请求和stub response。当我们定义期待的request和stub response时，restTemplate可以照常在客户端代码中使用。在测试结束时，mockServer.verify()可以用来验证所有的期望结果是否都被满足了。\n默认情况下，请求应按照expect申明期望的顺序执行。当构建服务时你可以设置ignoreExpectOrder选项，在这种情况下会检测所有的expect以找到一个跟给定request匹配。这意味着请求可以以任何顺序进入：\nserver = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();\r 即使改为无序请求，每个请求也只允许运行一次。expect方法提供一个重载变体，可以接受一个ExpectedCount参数以指定一个数量范围（比如说，一次，多次，max,min,between,等等）。下面的例子使用了times：\nRestTemplate restTemplate = new RestTemplate();\rMockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();\rmockServer.expect(times(2), requestTo(\u0026quot;/something\u0026quot;)).andRespond(withSuccess());\rmockServer.expect(times(3), requestTo(\u0026quot;/somewhere\u0026quot;)).andRespond(withSuccess());\r// ...\rmockServer.verify();\r 注意，当ignoreExpectOrder没有设置的时候（默认情况），请求会按照expect申明期望的顺序，并且这个顺序只会对第一次出现的期望请求有效。举个例子，如果/something期待出现两次接下来是三次/somewhere，这里应该有一个/something请求是在/somewhere请求之前的，但是剩下的请求可以在任何时间进入。\n对于上面的所有内容，还有另外一个实现方式，客户端的测试支持也提供了一个ClientHttpRequestFactory实现，你可以配置到一个RestTemplate中去将它绑定到MockMvc实例上。它允许你使用服务端的逻辑处理请求并且不需要运行一个服务：\nMockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();\rthis.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));\r// Test code that uses the above RestTemplate ...\r 8.1. 静态导入 作为服务端的测试，要流畅测试客户端需要一些静态导入。只要搜索MockRest*即可。\n8.2. 更多代码实例 Client-side test\n","id":116,"section":"posts","summary":"1. 概览 一般情况下我们要测试项目或者平台的某个功能，先要部署启动应用才能进行，如果在不启动应用或者连接其他企业级平台的情况下，就能做相应的集成","tags":["spring","unit-test","junit4","junit5","testng","mockmvc"],"title":"Spring集成测试","uri":"https://www.mingaccount.com/2017/09/spring-test/","year":"2017"},{"content":"vi run.sh\r# 查看当前脚本格式，如果结果是:fileformat=dos，则需要改为unix\r:set ff\r# 更改脚本格式为unix\r:set ff=unix\r ","id":117,"section":"posts","summary":"vi run.sh # 查看当前脚本格式，如果结果是:fileformat=dos，则需要改为unix :set ff # 更改脚本格式为unix :set ff=unix","tags":["linux"],"title":"linux sh文件运行异常，出现异常文件结尾或者乱码字符","uri":"https://www.mingaccount.com/2017/09/linux-sh-exception/","year":"2017"},{"content":" QPS：Query Per Second TPS：Transaction Per Second PV：Page View RT：Response Time UV：Unique Visitor DAU：Daily Actived Users MAU：Monthly Actived Users IaaS: Infrastructure as a service PaaS: Platform as a service SaaS: Software as a service LXC: Linux Containers CI/CD: Continuous Integration (CI) and Continuous Deployment or Continuous Delivery (CD)  ","id":118,"section":"posts","summary":"QPS：Query Per Second TPS：Transaction Per Second PV：Page View RT：Response Time UV：Unique Visitor DAU：Daily Actived Users M","tags":["website build"],"title":"QPS、TPS、PV等网站业务关键字释义","uri":"https://www.mingaccount.com/2017/09/qps-tps-pv-andsoon/","year":"2017"},{"content":"完全处理后的controller @RestController\rpublic class TestController{\r@GetMapping\r@UnknownExceptionHandler(msg = \u0026quot;test1 exception\u0026quot;, baseException = TestException.class)\rpublic String test(String arg) {\rif(StringUtils.isEmpty(arg)){\rthrow new TestException(\u0026quot;参数arg不能为空\u0026quot;);\r}\rreturn \u0026quot;test\u0026quot;;\r}\r@PostMapping\r@UnknownExceptionHandler(msg = \u0026quot;test2 exception\u0026quot;, baseException = TestException.class)\rpublic Map\u0026lt;String, String\u0026gt; test2(String arg) {\r//...\rreturn map;\r}\r@GetMapping\r@UnknownExceptionHandler( baseException = TestException.class)\rpublic void test3(String arg) {\r//... }\r}\r 统一处理返回结果和业务异常后，不需要在controller写try/catch捕获未知异常，通过@UnknownExceptionHandler直接将未知异常包装为包含提示信息的指定业务异常；同时controller的返回值也不需要去手动包装，直接返回即可。\n不管异常还是正常结果，都统一包装为下边的格式：\n{\r\u0026quot;code\u0026quot;: 1000,\r\u0026quot;msg\u0026quot;: \u0026quot;success\u0026quot;,\r\u0026quot;data\u0026quot;: {\u0026quot;id\u0026quot;: \u0026quot;...\u0026quot;,\u0026quot;name\u0026quot;: \u0026quot;...\u0026quot;...}\r}\r 统一Exception处理和结果处理 @RestControllerAdvice\r@Slf4j\rpublic class CustomResponseBodyAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; {\rprivate static final Class\u0026lt;? extends Annotation\u0026gt; ANNOTATION_TYPE = RequestMapping.class;\r/**\r* 目标返回值包装方法是元注解中有@RequestMapping的方法\r*/\r@Override\rpublic boolean supports(MethodParameter methodParameter, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; aClass) {\rreturn AnnotatedElementUtils.hasMetaAnnotationTypes(methodParameter.getMethod(),ANNOTATION_TYPE);\r}\r/**\r* 包装controller方法的返回结果\r* @param o\r* @param methodParameter\r* @param mediaType\r* @param aClass\r* @param serverHttpRequest\r* @param serverHttpResponse\r* @return\r*/\r@Override\rpublic Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {\rif (o instanceof ResultEntity) {\rreturn o;\r}\rreturn ResultEntity.builder().code(ResponseInfoEnum.SUCCESS.getCode()).msg(ResponseInfoEnum.SUCCESS.getMessage()).data(o).build();\r}\r/**\r* 已知异常处理\r* @param baseException 自定义异常父类\r* @return 异常结果包装\r*/\r@ExceptionHandler(value = BaseException.class)\rpublic ResultEntity baseExceptionHandler(BaseException baseException) {\rlog.error(baseException.getMessage(), baseException);\rreturn baseException.getResultEntity();\r}\r/**\r* 未知异常处理\r* @param e 未知异常\r* @return 异常结果包装\r*/\r@ExceptionHandler(value = Exception.class)\rpublic ResultEntity unknownExceptionHandler(Exception e) {\rlog.error(e.getMessage(), e);\rreturn new BaseException() {\r@Override\rprotected ResponseInfoEnum getInfoEnum() {\rreturn ResponseInfoEnum.UNKNOWN_EXCEPTION;\r}\r}.getResultEntity();\r}\r}\r 异常父类 public abstract class BaseException extends RuntimeException {\r/**\r* 给前端展示的信息\r*/\rprivate String viewMessage;\rpublic BaseException(){\rsuper();\r}\rpublic BaseException(String message) {\rsuper(message);\rviewMessage = message;\r}\rpublic BaseException(String message, Throwable cause) {\rsuper(message, cause);\rviewMessage = message;\r}\rpublic BaseException(Throwable cause) {\rsuper(cause);\r}\rpublic BaseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\rsuper(message, cause, enableSuppression, writableStackTrace);\rviewMessage = message;\r}\rpublic ResultEntity getResultEntity() {\rResultEntity resultEntity = new ResultEntity();\rresultEntity.setData(null);\rresultEntity.setCode(getInfoEnum().getCode());\rresultEntity.setMsg(viewMessage == null ? getInfoEnum().getMessage() : viewMessage);\rreturn resultEntity;\r}\r/**\r* 获取{@link ResponseInfoEnum}\r* @return\r*/\rprotected abstract ResponseInfoEnum getInfoEnum();\r}\r 测试异常子类 public class TestException extends BaseException {\rprivate final ResponseInfoEnum responseInfoEnum = ResponseInfoEnum.TEST_EXCEPTION;\rpublic TestException() {\rsuper();\r}\rpublic TestException(String message) {\rsuper(message);\r}\rpublic TestException(String message, Throwable cause) {\rsuper(message, cause);\r}\rpublic TestException(Throwable cause) {\rsuper(cause);\r}\rpublic TestException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\rsuper(message, cause, enableSuppression, writableStackTrace);\r}\r@Override\rprotected ResponseInfoEnum getInfoEnum() {\rreturn responseInfoEnum;\r}\r}\r 异常信息枚举 public enum ResponseInfoEnum {\rTEST_EXCEPTION(1001,\u0026quot;测试异常\u0026quot;);\r//异常码\rprivate int code;\r//异常信息\rprivate String msg;\rResponseInfoEnum(int code, String msg) {\rthis.code = code;\rthis.msg = msg;\r}\rpublic int getCode() {\rreturn code;\r}\rpublic String getMessage() {\rreturn msg;\r}\rpublic void setMsg(String msg) {\rthis.msg = msg;\r}\r}\r 统一返回对象 @Data\r@NoArgsConstructor\r@AllArgsConstructor\r@Builder\rpublic class ResultEntity\u0026lt;T\u0026gt; {\rprivate int code;\rprivate String msg;\rprivate T data;\r}\r @UnknownExceptionHandler切面 注解定义：\n@Retention(RetentionPolicy.RUNTIME)\r@Target(ElementType.METHOD)\rpublic @interface UnknownExceptionHandler {\rString msg() default \u0026quot;\u0026quot;;\rClass\u0026lt;? extends BaseException\u0026gt; baseException();\r}\r 切面代码：\n@Aspect\r@Component\rpublic class UnknownExceptionAdvice {\r@Pointcut(\u0026quot;within(com.ming.dictionary..*)\u0026quot;)\rpublic void withinPackage() {}\r/**\r* 通过注解{@link UnknownExceptionHandler}支持的未知异常处理\r* 如果项目基础异常{@link BaseException}的子类，直接抛出\r* 如果是未知异常，则需要获取{@link UnknownExceptionHandler}注解的异常信息\r* @param ex 方法本来抛出的异常\r* @param unknownExceptionHandler 目标方法的注解\r* @throws Throwable 抛出原本异常或者包装异常\r*/\r@AfterThrowing(pointcut = \u0026quot;@annotation(unknownExceptionHandler)\u0026quot; +\r\u0026quot;\u0026amp;\u0026amp; withinPackage() \u0026quot;\r, throwing = \u0026quot;ex\u0026quot;\r, argNames = \u0026quot;ex,unknownExceptionHandler\u0026quot;\r)\rpublic void unknownExceptionHandler(Throwable ex, UnknownExceptionHandler unknownExceptionHandler) throws Throwable {\rif (ex instanceof BaseException) {\rthrow ex;\r}else{\rBaseException baseException;\rtry {\rString msg = unknownExceptionHandler.msg();\rif(StringUtils.isNotEmpty(msg)) {\rbaseException = unknownExceptionHandler.baseException().getConstructor(String.class,Throwable.class).newInstance(msg,ex);\r}else{\rbaseException = unknownExceptionHandler.baseException().getConstructor(Throwable.class).newInstance(ex);\r}\r} catch (Exception e) {\rthrow new BaseException() {\r@Override\rprotected ResponseInfoEnum getInfoEnum() {\rreturn ResponseInfoEnum.UNKNOWN_EXCEPTION;\r}\r};\r}\rthrow baseException;\r}\r}\r}\r ","id":119,"section":"posts","summary":"完全处理后的controller @RestController public class TestController{ @GetMapping @UnknownExceptionHandler(msg = \u0026quot;test1 exception\u0026quot;, baseException = TestException.class) public String test(String arg) { if(StringUtils.isEmpty(arg)){ throw new TestException(\u0026quot;参数arg不能为空\u0026quot","tags":["java","spring"],"title":"统一结果处理和业务异常包装","uri":"https://www.mingaccount.com/2017/08/exception-and-result-handler/","year":"2017"},{"content":"objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r ","id":120,"section":"posts","summary":"objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);","tags":["jackson"],"title":"Jackson反序列化的时候忽略实体中不存在的元素","uri":"https://www.mingaccount.com/2017/08/jackson-deserialize-ignore-absence-element/","year":"2017"},{"content":"简介 maven profile插件可以根据环境参数，系统os，文件是否存在，和JDK版本等条件决定是否激活配置。激活的配置可以是环境参数的赋值，对应版本的依赖，部分pom标签的替换或者是整个pom的替换。\n 详情参考maven profile\n 实例 下面的例子是通过profile对不同环境的配置文件进行筛选，首先是文件结构：\n-src.main.resources\r-env\r-dev.properties\r-test.properties\r-prod.properties\r-application.properties\r application.properties spring.datasource.username=@datasource.username@\rspring.datasource.password=@datasource.password@\r 可以看到文件中只包含了数据库的用户名密码，根据环境的不同，对应的数据库用户名和密码不同。\n这里用了Spring-boot框架，参数的引用需要用@包裹，如果是yml文件，除了@还需要把整个引用用引号括起来，比如：\u0026quot;@datasource.password@\u0026quot;\nenv/*.properties datasource.username=dev\rdatasource.password=123\r env下每个环境对应的properties文件，都对datasource.username和datasource.password有明确赋值。下一步就是要将这些文件跟环境变量相关联。\npom.xml \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;\u0026gt;\r...\r\u0026lt;profiles\u0026gt;\r\u0026lt;profile\u0026gt;\r\u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt;\r\u0026lt;activation\u0026gt;\r\u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt;\r\u0026lt;/activation\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;env\u0026gt;dev\u0026lt;/env\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/profile\u0026gt;\r\u0026lt;profile\u0026gt;\r\u0026lt;id\u0026gt;test\u0026lt;/id\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;env\u0026gt;test\u0026lt;/env\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/profile\u0026gt;\r\u0026lt;profile\u0026gt;\r\u0026lt;id\u0026gt;prod\u0026lt;/id\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;env\u0026gt;prod\u0026lt;/env\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/profile\u0026gt;\r\u0026lt;/profiles\u0026gt;\r\u0026lt;build\u0026gt;\r\u0026lt;!-- filters用于将环境文件的参数导入到pom中，让pom可以通过${}方式调用文件中的属性 --\u0026gt;\r\u0026lt;filters\u0026gt;\r\u0026lt;filter\u0026gt;src/main/resources/env/${env}.properties\u0026lt;/filter\u0026gt;\r\u0026lt;/filters\u0026gt;\r\u0026lt;/build\u0026gt;\r\u0026lt;!-- resources让指定目录下的属性文件可以通过${}方式访问pom中的属性值(spring boot用@包围) --\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt;\r\u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt;\r\u0026lt;includes\u0026gt;\r\u0026lt;include\u0026gt;*.properties\u0026lt;/include\u0026gt;\r\u0026lt;/includes\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;/project\u0026gt;\r 上面的配置缺一不可。在profiles中，dev是默认激活的，而其他两个profile没有默认触发条件，只有通过命令行参数直接激活。\n# 替换测试环境配置\rmvn clean verify -Ptest\r# 替换生产环境配置\rmvn clean verify -Pprod\r # 替换测试环境配置\rmvn clean verify -Denv=test\r# 替换生产环境配置\rmvn clean verify -Denv=prod\r 上面两种方式达到的效果是一样的，不过一个是通过profile触发的，另外一个是直接给env变量赋值触发的\n","id":121,"section":"posts","summary":"简介 maven profile插件可以根据环境参数，系统os，文件是否存在，和JDK版本等条件决定是否激活配置。激活的配置可以是环境参数的赋值，对应版","tags":["maven"],"title":"maven profile","uri":"https://www.mingaccount.com/2017/08/maven-profile/","year":"2017"},{"content":"跟参数lower_case_table_names相关\n执行语句，查询该参数值\nSHOW VARIABLES LIKE ‘%case%’\r lower_case_table_names参数值为0代表大小写敏感\n需要将lower_case_table_names的值改为1\n编辑/etc下的my.cnf文件，可能在根目录下，或者在mysql目录下\n添加如下配置，然后重启mysql\n[mysqld]\rlower_case_table_names=1\r ","id":122,"section":"posts","summary":"跟参数lower_case_table_names相关 执行语句，查询该参数值 SHOW VARIABLES LIKE ‘%case%’ lower_case_table_name","tags":["mysql"],"title":"Mysql表名忽略大小写","uri":"https://www.mingaccount.com/2017/08/mysql-table-name-case-insensitive/","year":"2017"},{"content":"请求头枚举类  public enum HttpHeader {\rAUTHORIZATION(\u0026quot;Authorization\u0026quot;),\rAUTHENTICATION_TYPE_BASIC(\u0026quot;Basic\u0026quot;),\rX_AUTH_TOKEN(\u0026quot;X-AUTH-TOKEN\u0026quot;),\rWWW_Authenticate(\u0026quot;WWW-Authenticate\u0026quot;),\rX_FORWARDED_FOR(\u0026quot;X-Forwarded-For\u0026quot;),\rPROXY_CLIENT_IP(\u0026quot;Proxy-Client-IP\u0026quot;),\rWL_PROXY_CLIENT_IP(\u0026quot;WL-Proxy-Client-IP\u0026quot;),\rHTTP_CLIENT_IP(\u0026quot;HTTP_CLIENT_IP\u0026quot;),\rHTTP_X_FORWARDED_FOR(\u0026quot;HTTP_X_FORWARDED_FOR\u0026quot;);\rprivate String key;\rprivate HttpHeader(String key) {\rthis.key = key;\r}\rpublic String key() {\rreturn this.key;\r}\r}\r 工具类  public class RemoteIpHelper {\rprivate static final String UNKNOWN = \u0026quot;unknown\u0026quot;;\rpublic static String getRemoteIpFrom(HttpServletRequest request) {\rString ip = null;\rint tryCount = 1;\rwhile (!isIpFound(ip) \u0026amp;\u0026amp; tryCount \u0026lt;= 6) {\rswitch (tryCount) {\rcase 1:\rip = request.getHeader(X_FORWARDED_FOR.key());\r//get first ip\rif (ip != null \u0026amp;\u0026amp; ip.indexOf(\u0026quot;,\u0026quot;) != -1) {\rip = ip.substring(0, ip.indexOf(\u0026quot;,\u0026quot;));\r}\rbreak;\rcase 2:\rip = request.getHeader(PROXY_CLIENT_IP.key());\rbreak;\rcase 3:\rip = request.getHeader(WL_PROXY_CLIENT_IP.key());\rbreak;\rcase 4:\rip = request.getHeader(HTTP_CLIENT_IP.key());\rbreak;\rcase 5:\rip = request.getHeader(HTTP_X_FORWARDED_FOR.key());\rbreak;\rdefault:\rip = request.getRemoteAddr();\r}\rtryCount++;\r}\rreturn ip;\r}\rprivate static boolean isIpFound(String ip) {\rreturn ip != null \u0026amp;\u0026amp; ip.length() \u0026gt; 0 \u0026amp;\u0026amp; !UNKNOWN.equalsIgnoreCase(ip);\r}\r}\r ","id":123,"section":"posts","summary":"请求头枚举类 public enum HttpHeader { AUTHORIZATION(\u0026quot;Authorization\u0026quot;), AUTHENTICATION_TYPE_BASIC(\u0026quot;Basic\u0026quot;), X_AUTH_TOKEN(\u0026quot;X-AUTH-TOKEN\u0026quot;), WWW_Authenticate(\u0026quot;WWW-Authenticate\u0026quot;), X_FORWARDED_FOR(\u0026quot;X-Forwarded-For\u0026quot;), PROXY_CLIENT_IP(\u0026quot;Proxy-Client-IP\u0026quot;), WL_PROXY_CLIENT_IP(\u0026quot;WL-Proxy-Client-IP\u0026quot;), HTTP_CLIENT_IP(\u0026quot;HTTP_CLIENT_IP\u0026quot;), HTTP_X_FORWARDED_FOR(\u0026quot;HTTP_X_FORWARDED_FOR\u0026quot;); private String key; private HttpHeader(String key) { this.key = key; } public String key() { return this.key; } } 工具类 public class RemoteIpHelper { private static final String UNKNOWN = \u0026quot;unknown\u0026quot;; public static String getRemoteIpFrom(HttpServletRequest request) { String ip = null; int tryCount = 1; while (!isIpFound(ip) \u0026amp;\u0026amp; tryCount","tags":["java"],"title":"通过request获取客户端IP","uri":"https://www.mingaccount.com/2017/08/request-get-client-id/","year":"2017"},{"content":"简介 Maven release不在maven默认生命周期内，需要通过plugin来实现。Maven release可以自动管理pom.xml中的版本号，以及git tag的版本号。\n常用的命令有以下几个：\n mvn release:clean删除由mvn release:prepare生成的所有文件 mvn release:prepare它会运行mvn clean verify命令生成jar包，并且会往git上提交并push当前版本tag，同时为当前版本的代码创建分支，然后修改pom中的版本号（默认叠加1，可以手动指定），最后commit对pom.xml的修改（可以通过mvn release:rollback命令回滚prepare的修改（包括git提交），但是提交的tag无法回滚）。 mvn release:perform它会将prepare创建的版本分支代码拉倒本地，并执行mvn deploy命令，相当于完整的maven默认生命周期流程。   参考Maven Release Plugin\n 运行要求 要运行release相关命令，首先需要配置pom.xml\n\u0026lt;project\u0026gt;\r...\r\u0026lt;scm\u0026gt;\r\u0026lt;developerConnection\u0026gt;scm:git:https://github.com/..../....\u0026lt;/developerConnection\u0026gt;\r\u0026lt;/scm\u0026gt;\r\u0026lt;build\u0026gt;\r\u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-release-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.0.0-M1\u0026lt;/version\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r...\r\u0026lt;/build\u0026gt;\r...\r\u0026lt;/project\u0026gt;\r 和是必不可少的\n中的指向的就是git的项目地址，最后不加.git\ngit认证 除了上面两个必要标签，还需要注意的是访问git的配置信息\n对于maven来说，并不知道你的git用户名密码所以需要在settings.xml中新增\n\u0026lt;servers\u0026gt;\r\u0026lt;server\u0026gt;\r\u0026lt;id\u0026gt;git\u0026lt;/id\u0026gt;\r\u0026lt;username\u0026gt;*******@outlook.com\u0026lt;/username\u0026gt;\r\u0026lt;password\u0026gt;{wb83456gfhgV71sdfewrvx453EJt4iOVlQ=}\u0026lt;/password\u0026gt;\r\u0026lt;/server\u0026gt;\r\u0026lt;/servers\u0026gt;\r 其中id是pom.xml用来匹配对应服务的，需要在pom.xml中配置该id：\n\u0026lt;properties\u0026gt;\r\u0026lt;project.scm.id\u0026gt;git\u0026lt;/project.scm.id\u0026gt;\r\u0026lt;/properties\u0026gt;\r 密码加密 此外之前settings.xml中的是加密的，没有明文密码。获取加密密码还需要更多配置：\n 需要执行mvn --encrypt-master-password命令，获得master密码 然后将master密码保存到${user.home}/.m2/settings-security.xml文件中，只需要以下结构：  \u0026lt;settingsSecurity\u0026gt;\r\u0026lt;master\u0026gt;{jSMOWnoPFgsHVpMvz5VrIt5kRbzGpI8u+9EF1iFQyJQ=}\u0026lt;/master\u0026gt;\r\u0026lt;/settingsSecurity\u0026gt;\r 执行mvn --encrypt-password命令，按照提示输入你的git密码以获取密文。   更多关于Maven密码加密，参考Maven Password Encrypt\n  由于mvn release:perform内部执行了mvn deploy命令，因此想要mvn release:perform正常运行，必须在pom.xml中配置\u0026lt;distributionManagement\u0026gt;\n 参考maven distributionManagement\n 如果没有计划将生成的jar包分发到仓库管理器上（例如nexus），又想执行perform，那么可以将deploy插件屏蔽掉\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;\u0026gt;\r...\r\u0026lt;plugins\u0026gt;\r...\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-deploy-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r\u0026lt;/project\u0026gt;\r ","id":124,"section":"posts","summary":"简介 Maven release不在maven默认生命周期内，需要通过plugin来实现。Maven release可以自动管理pom.xml中的版本号，","tags":["maven"],"title":"Maven release","uri":"https://www.mingaccount.com/2017/07/maven-release/","year":"2017"},{"content":"多个where条件，每个条件对应的更新值不同，需要mysql批量更新\nUPDATE test_table\rSET\rtest_target = test_id CASE\rWHEN \u0026quot;123\u0026quot; THEN \u0026quot;456\u0026quot;\rWHEN \u0026quot;789\u0026quot; THEN \u0026quot;101\u0026quot;\rEND\rWHERE\rtest_id in ['123','789']\r 但是在程序中，直接写常量的情况太少，大多数都需要变量遍历\n下面是mybatis的应用：\nUPDATE\rtable\rSET\rtarget = CASE id\r\u0026lt;foreach collection=\u0026quot;items\u0026quot; item=\u0026quot;item\u0026quot; close=\u0026quot; END\u0026quot; \u0026gt;\rWHEN #{item.id} THEN #{item.target}\r\u0026lt;/foreach\u0026gt;\rWHERE\rapply_id IN\r\u0026lt;foreach collection=\u0026quot;items\u0026quot; item=\u0026quot;item\u0026quot; open=\u0026quot;(\u0026quot; close=\u0026quot;)\u0026quot; separator=\u0026quot;,\u0026quot; \u0026gt;\r#{item.id}\r\u0026lt;/foreach\u0026gt;\r ","id":125,"section":"posts","summary":"多个where条件，每个条件对应的更新值不同，需要mysql批量更新 UPDATE test_table SET test_target = test_id CASE WHEN \u0026quot;123\u0026quot; THEN \u0026quot;456\u0026quot; WHEN \u0026quot;789\u0026quot; THEN \u0026quot;101\u0026quot; END WHERE test_id in ['123','789'] 但是在程序中，直接写常量的情况太","tags":["mysql"],"title":"Mysql批量更新","uri":"https://www.mingaccount.com/2017/07/mysql-batch-update/","year":"2017"},{"content":"usermod -d /var/lib/mysql/ mysql\rln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock\rchown -R mysql:mysql /var/lib/mysql\r ","id":126,"section":"posts","summary":"usermod -d /var/lib/mysql/ mysql ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock chown -R mysql:mysql /var/lib/mysql","tags":["mysql"],"title":"Mysql启动报错mkdir: cannot create directory ‘//.cache’: Permission denied","uri":"https://www.mingaccount.com/2017/07/mysql-startup-exception/","year":"2017"},{"content":"lifecycle-phase maven有三个内部生命周期：default，clean，和site。\n每个生命周期由多个阶段(phase)组成\nclean    Phase Description     pre-clean execute processes needed prior to the actual project cleaning   clean remove all files generated by the previous build   post-clean execute processes needed to finalize the project cleaning    default    Phase Description     validate validate the project is correct and all necessary information is available.   initialize initialize build state, e.g. set properties or create directories.   generate-sources generate any source code for inclusion in compilation.   process-sources process the source code, for example to filter any values.   generate-resources generate resources for inclusion in the package.   process-resources copy and process the resources into the destination directory, ready for packaging.   compile compile the source code of the project.   process-classes post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.   generate-test-sources generate any test source code for inclusion in compilation.   process-test-sources process the test source code, for example to filter any values.   generate-test-resources create resources for testing.   process-test-resources copy and process the resources into the test destination directory.   test-compile compile the test source code into the test destination directory   process-test-classes post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes.   test run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.   prepare-package perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package.   package take the compiled code and package it in its distributable format, such as a JAR.   pre-integration-test perform actions required before integration tests are executed. This may involve things such as setting up the required environment.   integration-test process and deploy the package if necessary into an environment where integration tests can be run.   post-integration-test perform actions required after integration tests have been executed. This may including cleaning up the environment.   verify run any checks to verify the package is valid and meets quality criteria.   install install the package into the local repository, for use as a dependency in other projects locally.   deploy done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.    site    Phase Description     pre-site execute processes needed prior to the actual project site generation   site generate the project\u0026rsquo;s site documentation   post-site execute processes needed to finalize the site generation, and to prepare for site deployment   site-deploy deploy the generated site documentation to the specified web server    phase-goal 生命周期对应的每个阶段（phase），都应有一个目标（goal），实际上起作用的就是这些目标语句（没有goal的phase没有意义）。phase相当于goal的封装，一个phase可以封装多个goal，除了maven默认的goal，你还可以绑定自定义的goal。\n每个阶段对应的目标，根据pom.xml文件中的\u0026lt;packaging\u0026gt;标签的值而略有不同。详情参考Built-in Lifecycle Bindings\n","id":127,"section":"posts","summary":"lifecycle-phase maven有三个内部生命周期：default，clean，和site。 每个生命周期由多个阶段(phase)组成 clean Phase Description pre-clean execute processes needed prior to the actual project cleaning clean","tags":["maven"],"title":"Markdown生命周期","uri":"https://www.mingaccount.com/2017/07/markdown-lifecycle/","year":"2017"},{"content":"compile This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.\nprovided This is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. A dependency with this scope is added to the classpath used for compilation and test, but not the runtime classpath. It is not transitive.\nruntime This scope indicates that the dependency is not required for compilation, but is for execution. Maven includes a dependency with this scope in the runtime and test classpaths, but not the compile classpath.\ntest This scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive. Typically this scope is used for test libraries such as JUnit and Mockito. It is also used for non-test libraries such as Apache Commons IO if those libraries are used in unit tests (src/test/java) but not in the model code (src/main/java).\nsystem This scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.\nimport This scope is only supported on a dependency of type pom in the section. It indicates the dependency is to be replaced with the effective list of dependencies in the specified POM\u0026rsquo;s section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.\n 详情参考Maven Scope\n ","id":128,"section":"posts","summary":"compile This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects. provided This is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet","tags":["maven"],"title":"Maven依赖scope属性","uri":"https://www.mingaccount.com/2017/06/maven-dependency-scope/","year":"2017"},{"content":"# 编译项目\rmvn compile\r# 执行项目中的单元测试\r# 查找单元测试类的默认规则：**/*Test.java;**/Test*.java;**/*TestCase.java\r# 排除单元测试类的默认规则：**/Abstract*Test.java;**/Abstract*TestCase.java\rmvn test\r# 编译测试代码但不执行\rmvn test-compile\r# 生成JAR文件，在${basedir}/target 目录下\rmvn package\r# 官方默认推荐命令。代表执行集成测试或者一些质量验证，除了对应的当前阶段，还执行了validate，compile，test，package\rmvn verify\r# 将生成JAR文件安装到本地仓库，本地仓库默认路径：${user.home}/.m2/repository\rmvn install\r# 生成项目基础信息网站\rmvn site\r# 删除 target 目录下的所有构建数据\rmvn clean\r# 根据模板创建maven项目\rmvn archetype:generate\r# 构建完整依赖，能够独立运行的jar包\rmvn clean package\r# 运行Spring-boot项目\rmvn spring-boot:run\r# 删除target目录内容，重新编译测试构建，然后部署到远程共享仓库\rmvn clean deploy\r# 从本地仓库删除指定jar\rmvn dependency:purge-local-repository -DmanualInclude=\u0026quot;groupId:artifactId, ...\u0026quot;\r# 项目依赖结构\rmvn dependency:tree\r# 项目依赖分析\rmvn dependency:analyze\r# plugin详情，加上-Dgoal可以查看指定goal的详情\rmvn release:help -Ddetail -Dgoal=stage\r# 安装jar包到本地仓库\rmvn install:install-file \\\r-Dfile=\u0026lt;path-to-file\u0026gt; \\\r-DgroupId=\u0026lt;group-id\u0026gt; \\\r-DartifactId=\u0026lt;artifact-id\u0026gt; \\\r-Dversion=\u0026lt;version\u0026gt; \\\r-Dpackaging=\u0026lt;packaging\u0026gt; \\\r-DgeneratePom=true\r# 离线打包\rmvn -o package\r# 指定自定义settings.xml运行命令\rmvn -s YourOwnSettings.xml clean install\r# 加密密码，用于settings.xml中的服务密码等\rmvn --encrypt-password \u0026lt;password\u0026gt;\r# 加载资源文件，通常用于检查指定${}是否正常赋值\rmvn process-resources\r ","id":129,"section":"posts","summary":"# 编译项目 mvn compile # 执行项目中的单元测试 # 查找单元测试类的默认规则：**/*Test.java;**/Test*.java;**/*TestCa","tags":["maven"],"title":"Maven命令备忘","uri":"https://www.mingaccount.com/2017/06/maven-common-command/","year":"2017"},{"content":"GsonBuilder gsonBuilder = new GsonBuilder();\rgsonBuilder.setLongSerializationPolicy( LongSerializationPolicy.STRING );\rGson gson = gsonBuilder.create();\r ","id":130,"section":"posts","summary":"GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setLongSerializationPolicy( LongSerializationPolicy.STRING ); Gson gson = gsonBuilder.create();","tags":["java"],"title":"阻止Gson将long类型的字段转为科学计数法","uri":"https://www.mingaccount.com/2017/06/gson-scientific-notation/","year":"2017"},{"content":"1.切面编程核心概念  切面编程Aspect-oriented Programming (AOP)\n AOP只是一个概念，跟Spring是独立关系\n最典型的AOP实现框架AspectJ，是一个十分成熟的框架，Spring AOP相比只是基于它做了一些功能的强化，是互补关系\n几个核心的参数概念（基于AspectJ）\n Aspect: 切面编程的核心是切面，因此首先需要一个切面类(@Aspect注解修饰的类) Join point: 代表需要切面处理的方法（Spring AOP只针对方法，因此以下简称目标方法） Advice: 切面类需要在目标方法运行的哪个阶段进行处理，比如before(调用之前)，after(调用之后)，around(前后都进行处理) Pointcut: 当前的切面类需要监听的目标方法有什么特征，或者说切面类要怎样找到需要处理的目标方法，比如被注解@Log修饰的方法 Introduction: 申明一个额外的方法或者字段去代表目标方法的对象，意思就是你可以给目标方法所在类追加一个父类（接口），并指定一个实现去代表它（AspectJ称为inter-type declaration） Target object: 目标方法所在的对象，也叫作advised object。但是Spring AOP是通过运行时代理实现的，意思就是这个对象是一个代理类的对象  完整的Advice类型包括：\n Before advice: 在目标方法之前 After returning advice: 在目标方法return之后，如果目标方法没有抛异常的话 After throwing advice: 在目标方法抛完异常之后 After (finally) advice: 相当于finally Around advice: 在方法执行前后做处理，可以处理参数，捕获异常，修改返回结果  建议使用最小范围的Advice，比如说仅需要处理返回结果，只需要设定类型为After returning advice即可\n能不使用Around advice的时候尽量不使用，因为它需要你手动去调用目标方法(通过动态代理)，尽可能地减少出错\nSpring AOP默认使用标准的JDK dynamic proxies作为AOP的代理，就是切面类中调用目标方法的过程。\n2.基于AspectJ的Spring AOP实例 2.1 配置类 注解EnableAspectJAutoProxy，让Spring在目标方法被执行时，自动拦截方法调用并生成代理类\n@Configuration\r@EnableAspectJAutoProxy\rpublic class AppConfig {\r}\r 2.2 切面类声明 注意切面类的方法不能作为目标方法被拦截\npackage org.xyz;\rimport org.aspectj.lang.annotation.Aspect;\r@Component\r@Aspect\rpublic class NotVeryUsefulAspect {\r}\r 2.3 切面方法特征申明(Pointcut) Spring AOP只支持方法执行的切入点，所以Pointcut就是在申明怎么匹配目标目标方法\n一个Pointcut的声明有两个部分\n 新建一个方法，任意参数，任意名称，返回值必须是void 新建的方法需要一个@Pointcut注解，这个注解和他的参数叫做pointcut表达式  下面是一个例子，代表pointcut的名字是anyOldTransfer，匹配的目标方法是任何方法名叫做transfer的\n@Pointcut(\u0026quot;execution(* transfer(..))\u0026quot;)\rprivate void andOldTransfer(){}\r 注解Pointcut的value就是AspectJ5的pointcut表达式\n2.3.1 支持的Pointcut标识符 在pointcut表达式中，Spring AOP支持下列的AspectJ pointcut 标识符(PCD)：\n execution: 用于直接匹配目标方法。对Spring AOP来说，这是主要的pointcut指示符 within: 限制目标方法是在匹配的类型中申明 this: 限制目标方法，其bean引用(Spring AOP代理)是给定类型的实例 target: 限制目标方法，其目标对象(正在代理的应用程序对象)是给定类型的实例 args: 限制目标方法，其参数是给定类型的实例 @target: 限制目标方法，其类有指定类型的注解 @args: 限制目标方法，其实际传输的参数，每个参数的类型都有给定的注解 @within: 限制目标方法，其所在类型有给定的注解 @annotation: 限制目标方法有给定注解  在AspectJ中，因为Aspect是一个基于类型的语法，this和target都指向同一个对象。\n但在SpringAOP中，this和target是有区别的，Spring AOP是基于代理的系统，this代表的是代理对象，target代表的才是目标方法所在的对象\n Spring不支持以下AspectJ的pointcut标识符：\ncall, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this, and @withincode\n如果使用这些pointcut标识符会抛出IllegalArgumentException\n  因为Spring AOP以代理为基础的特性，是不会拦截在目标方法所在类中的调用的，换句话说目标方法所在类的其他方法中调用了目标方法是不会触发拦截的 这个特性是由Spring AOP默认使用的JDK proxies造成的，可以通过替换Spring's proxy-based AOP framework为Spring-driven native AspectJ weaving 来解决，但是需要对waving有一定熟练度\n Spring AOP支持一个额外的PCD，叫做bean。这个标识符可以让你限制目标方法去匹配一个或多个指定的Spring bean(多个通过通配符)\nbean(idOrNameOfBean)\r idOrNameOfBean可以是任何Spring bean的名称。如果你确定了多个bean名称的规则，可以也只能用*号去写PCD表达式来选择他们\n当bean需要和其他的PCD一起使用的时候，同样可以使用\u0026amp;\u0026amp;(and)，!(negation),||(or)来连接\n2.3.2 组合pointcut表达式 你可以组合pointcut表达式通过使用\u0026amp;\u0026amp;，||和!\n@Pointcut(\u0026quot;execution(public * *(..))\u0026quot;)\rprivate void anyPublicOperation(){}\r@Pointcut(\u0026quot;within(com.xyz.myapp.trading..*)\u0026quot;)\rprivate void inTrading(){}\r@Pointcut(\u0026quot;anyPublicOperation() \u0026amp;\u0026amp; inTrading()\u0026quot;)\rprivate void tradingOperation(){}\r 对上面的三个pointcut逐个解析\n anyPublicOperation 匹配任何目标方法是public的 inTrading 匹配任何目标方法在trading模块路径下 tradingOperation 任何目标方法是public，并且在trading模块下  从小的命名组件完成了一个复杂的pointcut表达式的构建，这是一个最好的实现方式，正如上面的实例。\n当通过名字引用pointcut，跟一般java的可见规则一样(private,protected,public)，意味着你可以引用其他类的pointcut，只要对应pointcut的类修饰符可见。 pointcut的可见性不影响切面的匹配，只影响pointcut表达式的引用\n2.3.3 分享共用的Pointcut定义 在开发中有很多切面是经常使用到的，推荐定义一个CommonPointcuts切面类来定义共用的pointcut表达式\n典型的类似下边的这个例子：\npackage com.xyz.myapp;\rimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Pointcut;\r@Aspect\rpublic class CommonPointcuts {\r/**\r* 在web层的切面，任何在web目录以及子目录类中定义的方法\r*/\r@Pointcut(\u0026quot;within(com.xyz.myapp.web..*)\u0026quot;)\rpublic void inWebLayer() {}\r/**\r* service层的切面，任何在service目录以及子目录类中定义的方法\r*/\r@Pointcut(\u0026quot;within(com.xyz.myapp.service..*)\u0026quot;)\rpublic void inServiceLayer() {}\r/**\r* dao层的切面，任何在dao目录以及子目录类中定义的方法\r*/\r@Pointcut(\u0026quot;within(com.xyz.myapp.dao..*)\u0026quot;)\rpublic void inDataAccessLayer() {}\r/**\r* 业务Service切面，任何在service接口中定义的方法,假定接口在\u0026quot;service\u0026quot;package中，并且子包中有其实现类\r*\r* 也可以使用bean(*Service)，但是要确保Service的命名规则\r*/\r@Pointcut(\u0026quot;execution(* com.xyz.myapp..service.*.*(..))\u0026quot;)\rpublic void businessService() {}\r/**\r* 任何在dao接口中定义的方法，假定接口在\u0026quot;dao\u0026quot;package中，并且子包有其实现类\r*/\r@Pointcut(\u0026quot;execution(* com.xyz.myapp.dao.*.*(..))\u0026quot;)\rpublic void dataAccessOperation() {}\r}\r 你可以引用这些pointcut定义，在任何你需要他们的地方。举个例子，给所有service层都加上事务，你可以这样写：\n\u0026lt;aop:config\u0026gt;\r\u0026lt;aop:advisor\rpointcut=\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;\radvice-ref=\u0026quot;tx-advice\u0026quot;/\u0026gt;\r\u0026lt;/aop:config\u0026gt;\r\u0026lt;tx:advice id=\u0026quot;tx-advice\u0026quot;\u0026gt;\r\u0026lt;tx:attributes\u0026gt;\r\u0026lt;tx:method name=\u0026quot;*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt;\r\u0026lt;/tx:attributes\u0026gt;\r\u0026lt;/tx:advice\u0026gt;\r 关于具体的\u0026lt;aop:config\u0026gt;和\u0026lt;aop:advisor\u0026gt;元素使用方式可以参考 Schema-based AOP Support\n关于事务元素的使用可以参考 Transaction Management\n2.3.4 实例 Spring AOP 的用户最经常使用的pointcut标识符是execution，execution表达式的格式如下：\n execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)\rthrows-pattern?)\r   以上表达式中，除了ret-type-pattern，name-pattern和param-pattern是必须的，其他的都是可选参数\n  ret-type-pattern指代返回类型\n *号是最常用到的，代表可以返回任何类型 一个完全限定的类型名称，只有在方法返回指定类型的时候才会匹配    name-pattern 指代方法名称\n 你可以使用*号来代替部分或者全部方法名 如果你指定了declaring-type-pattern，用.号连接name-component    param-pattern 指代方法参数\n ()代表方法没有任何参数 (..)代表方法可能没有参数，也可能有任意数量任意类型的参数 (*) 代表方法有一个任意类型的参数 (*,String) 代表方法有两个参数，一个是任意类型，一个必须是String    完整的AspectJ pointcut表达式语法结构可以参考Language Semantics\n一下的实例展示了经常使用到的pointcut表达式：\n 任何执行的public方法   execution(public * *(..))\n  任何执行的方法是以set开头的   execution(* set*(..))\n  任何执行的方法是AccountService中定义的   execution(* com.xyz.service.AccountService.*(..))\n  任何执行的方法是定义在service包中的   execution(* com.xyz.service.*.*(..))\n  任何执行的方法是定义在service包或者其子包中的   execution(* com.xyz.service..*.*(..))\n  任何在service包下的方法   within(com.xyz.service.*)\n  任何在service包或其子包下的方法   within(com.xyz.service..*)\n  任何方法的代理是实现AccountService接口的   this(com.xyz.service.AccountService)\n一般用于绑定结构，具体用法在后面会提到\n  任何方法的目标对象是实现AccountService接口的   target(com.xyz.service.AccountService)\n一般用于绑定结构，具体用法在后面会提到\n  任何执行的方法有一个参数，并且这个参数在运行时是通过Serializable传递的   args(java.io.Serializable)\n一般用于绑定接口，具体用法在后面会提到\n注意这里的参数匹配跟execution(* *(java.io.Serializable))是不同的\nargs代表参数在运行时是以Serializable传递的\nexecution代表参数必须是Serializable类型\n  任何方法的目标对象有@Transactional注解   @target(org.springframework.transaction.annotation.Transactional)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法的目标对象的申明类型有@Transactional注解   @within(org.springframework.transaction.annotation.Transactional)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法上有@Transactional注解   @annotation(org.springframework.transaction.annotation.Transactional)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法只有一个参数，并且该参数在运行时传递有@Classified注解   @args(com.xyz.security.Classified)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法所属的Spring bean的名称是tradeService   bean(tradeService)\n  任何方法所属的Spring bean的名称是以Service结尾   bean(*Service)\n 2.3.5 写好pointcuts表达式 AspectJ不会直接采用你写的pointcut表达式，进行分析校验后，你的表达式会被重写\n关于表达式的顺序，AspectJ也会重排，意味着不需要担心你的表达式写法会影响匹配效率\n但是你直接选用的pointcut标识符还是会对匹配效率造成影响，原则上应该选用搜索范围更小的定义 AspectJ的标识符可以分为三类：类型，范围，和上下文：(以下标识符包括Spring不支持的)\n 类型：指定类型的连接点：execution,get,set,call,和withcode 范围：指定范围内的连接点：within和withcode 上下文：指定上下文：this,target,和@annotation  一个好的pointcut表达式至少要包含类型和范围两个类型\n如果只有类型和上下文，会影响性能，因为需要一些额外的处理和分析\n但是范围不同，他的匹配速度非常快，一个好的pointcut表达式应该尽可能的包含一个\n2.4 申明Advice Advice需要关联一个pointcut表达式，并申明在匹配的pointcut之前(before)，之后(after)，或者前后(around)运行\n引用pointcut表达式可简单引用已命名的pointcut表达式，或者就地申明pointcut表达式\n2.4.1 Before Advice 你可以在一个切面类中申明before advice通过使用@Before注解:\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Before;\r@Aspect\rpublic class BeforeExample {\r@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doAccessCheck() {\r// ...\r}\r}\r 如果我们不引用已声明的pointcut，可以直接就地申明：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Before;\r@Aspect\rpublic class BeforeExample {\r@Before(\u0026quot;execution(* com.xyz.myapp.dao.*.*(..))\u0026quot;)\rpublic void doAccessCheck() {\r// ...\r}\r}\r 2.4.2 After Returning Advice After Returning Advice在方法正常return后运行。\n你可以申明它通过使用@AfterReturning注解：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterReturning;\r@Aspect\rpublic class AfterReturningExample {\r@AfterReturning(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doAccessCheck() {\r// ...\r}\r}\r  你可以拥有多个advice，在同一个切面类中\n 有些时候，你需要在advice方法中访问目标方法的返回值。你可以使用@AfterReturning的参数结构去绑定返回参数：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterReturning;\r@Aspect\rpublic class AfterReturningExample {\r@AfterReturning(\rpointcut=\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;,\rreturning=\u0026quot;retVal\u0026quot;)\rpublic void doAccessCheck(Object retVal) {\r// ...\r}\r}\r returning参数所用的名字，必须跟advice方法的参数名相同\n并且返回值的类型也必须匹配(这里用的Object，可匹配所有返回值)\n注意想通过after returning advice返回一个完全不同的引用是不可能的\n2.4.3 After Throwing Advice After Throwing Advice当目标方法是因为抛出异常退出的时候执行。 可以通过@AfterThrowing注解来实现：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterThrowing;\r@Aspect\rpublic class AfterThrowingExample {\r@AfterThrowing(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doRecoveryActions() {\r// ...\r}\r}\r 在通常使用情况下，你可能需要在指定异常的时候运行Advice，或者获取方法抛出的异常（想获得异常，又不想限制，使用Throwable）\n你可以使用@AfterThrowing的属性throwing来实现：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterThrowing;\r@Aspect\rpublic class AfterThrowingExample {\r@AfterThrowing(\rpointcut=\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;,\rthrowing=\u0026quot;ex\u0026quot;)\rpublic void doRecoveryActions(DataAccessException ex) {\r// ...\r}\r}\r 同样throwing中的名字必须跟advice方法的参数名称相同\n当然也有类型限制，advice方法的参数类型，必须跟目标方法抛出的异常类型相同\n2.4.4 After (Finally) Advice After (Finally) Advice是在目标方法执行退出后运行\n它通过注解@After来实现，用该注解的时候，你需要同时处理正常返回现象和异常退出现象\n这个Advice通常用来处理资源释放问题或者其他相似的情形：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.After;\r@Aspect\rpublic class AfterFinallyExample {\r@After(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doReleaseLock() {\r// ...\r}\r}\r 2.4.5 Around Advice Around Advice是最后一个advice，也是最强大的一个。你可以在方法执行前，执行后做处理，甚至可以决定什么时候运行，怎样运行，是否运行目标方法\n它经常使用的场景是在方法运行前后有状态信息需要分享的，比如方法的运行时间等等\n在选择Advice的时候，始终使用功能最弱的那个，比如能用Before，就不用Around\nAround Advice通过注解@Around来申明。advice方法的第一个参数类型必须是ProceedingJoinPoint\n在advice方法中，通过调用第一个参数的proceed()方法，可以执行目标方法\nproceed可以传递一个Object[]参数，这个数组，是目标方法所需要的所有参数 如何使用Around Advice？下面是一个例子：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Around;\rimport org.aspectj.lang.ProceedingJoinPoint;\r@Aspect\rpublic class AroundExample {\r@Around(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;)\rpublic Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {\r// start stopwatch\rObject retVal = pjp.proceed();\r// stop stopwatch\rreturn retVal;\r}\r}\r around advice 的返回值就是方法调用者看到的返回值。举个例子，一个简单的缓存切面，如果缓存里面有直接从缓存返回，如果缓存里面没有再调用proceed()方法。\n注意proceed有可能调用一次，或者多次，甚至不调用，这都是合法的\n2.4.6 advice参数 访问当前的 JoinPoint 任何的advice方法都可以申明JoinPoint作为第一个参数（除了around例外，不过它的第一个参数ProceedingJoinPoint，也是JoinPoint的子类)\nJoinPoint提供了一些很有用的方法：\n getArgs()：返回方法参数 getThis()：返回代理对象 getTarget()：返回目标对象 getSignature()：返回方法的描述 toString()：打印方法有用的描述  完整API参考javadoc\n给Advice传递参数 我们已经看过怎样绑定返回值和异常值（通过使用after returning和after throwingadvice)。那么参数值怎么绑定了，可以使用args表达式\n如果在args表达式里使用对应的advice方法的参数名代替类型名，当advice被调用时对应的参数就会被指定类型的原方法参数替换。\n举个例子，假如你的目标方法第一个参数是一个类型为Account的对象，你需要访问这个account参数在advice的方法体中，你可以像下面这样写：\n@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation() \u0026amp;\u0026amp; args(account,..)\u0026quot;)\rpublic void validateAccount(Account account) {\r// ...\r}\r args(account,..)这个pointcut表达式有两个目的\n 限制目标方法至少有一个参数，并且这个参数是Account类的实例 通过advice参数传递参数的值  传递参数的另外一个方法是在一个pointcut表达式里面申明好，advice直接引用：\n@Pointcut(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation() \u0026amp;\u0026amp; args(account,..)\u0026quot;)\rprivate void accountDataAccessOperation(Account account) {}\r@Before(\u0026quot;accountDataAccessOperation(account)\u0026quot;)\rpublic void validateAccount(Account account) {\r// ...\r}\r this、target、@within、@target、@annotation，和@args都可以用同样的方式绑定\n下面的两个例子展示了如何匹配有注解@Auditable的方法和如何提取注解的AuditCode参数\n第一个例子展示了@Auditable注解：\n@Retention(RetentionPolicy.RUNTIME)\r@Target(ElementType.METHOD)\rpublic @interface Auditable {\rAuditCode value();\r}\r 第二个例子是对应的advice：\n@Before(\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod() \u0026amp;\u0026amp; @annotation(auditable)\u0026quot;)\rpublic void audit(Auditable auditable) {\rAuditCode code = auditable.value();\r// ...\r}\r Advice参数和泛型 Spring AOP可以处理类泛型和方法泛型\n假如你有一个接口如下所示：\npublic interface Sample\u0026lt;T\u0026gt; {\rvoid sampleGenericMethod(T param);\rvoid sampleGenericCollectionMethod(Collection\u0026lt;T\u0026gt; param);\r}\r 你可以指定泛型为什么类型时才拦截方法：\n@Before(\u0026quot;execution(* ..Sample+.sampleGenericMethod(*)) \u0026amp;\u0026amp; args(param)\u0026quot;)\rpublic void beforeSampleMethod(MyType param) {\r// Advice implementation\r}\r 这个方法在泛型指向集合的时候是不生效的。所以你不能像下边那样定义pointcut：\n@Before(\u0026quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) \u0026amp;\u0026amp; args(param)\u0026quot;)\rpublic void beforeSampleMethod(Collection\u0026lt;MyType\u0026gt; param) {\r// Advice implementation\r}\r 要实现这种情况，你需要改变参数类型为Collection\u0026lt;?\u0026gt;，并且你需要手动校验集合中的每一个元素，这是不合理的，因为null值无法处理。\n确定参数名称 advice调用时的参数绑定是依赖于pointcut表达式里面的名称（用于申明advice参数名）和pointcut方法签名的名字相匹配，但是在java反射里边，参数名称是不可用的\n所以Spring AOP采用了以下策略却决定参数名称:\n 如果参数名已经被用户明确指定，那么指定的参数名会被使用。advice和pointcut注解都有一个可选属性argNames，你可以用它指定注解方法的参数名称 这些参数名称在运行时也是可用的。下面这个例子展示了如何使用argNames属性：  @Before(value=\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod() \u0026amp;\u0026amp; target(bean) \u0026amp;\u0026amp; @annotation(auditable)\u0026quot;,\rargNames=\u0026quot;bean,auditable\u0026quot;)\rpublic void audit(Object bean, Auditable auditable){\rAuditCode code = auditable.value();\r}\r 如果第一个参数是默认参数JoinPoint，ProceedingJoinPoint,或者JoinPoint.StaticPart，在配置argNames时你可以直接忽略这些默认参数\n举个例子，如果你修改上面的advice新增一个JoinPoint参数，argNames不需要涵盖它：\n@Before(value=\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod() \u0026amp;\u0026amp; target(bean) \u0026amp;\u0026amp; @annotation(auditable)\u0026quot;,\rargNames=\u0026quot;bean,auditable\u0026quot;)\rpublic void audit(JoinPoint joinPoint, Object bean, Auditable auditable){\rAuditCode code = auditable.value();\r}\r 当advice方法只有默认参数JoinPoint，PorceedingJoinPoint，和Joint.StaticPart时，可以不写argNames\n@Before(\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod()\u0026quot;)\rpublic void audit(JoinPoint jp) {\r// ... use jp\r}\r   使用argNames属性显得稍微有些笨拙，所以当argNames没有被指定时，Spring AOP将会在类的debug信息中查找，并从本地变量表中决定参数名称\n只要类编译时有debug信息(至少是-g:vars)就能得到这个信息。\n启用此标志进行编译的结果是：\n 你的代码会更容易理解（反向工程） class文件的大小会有轻微增大（一般可以忽略不计） 会移除编译器没有用到的本地变量  换句话说，使用这个标志你不会碰见任何困难\n  如果代码被编译的时候没有必须的debug信息，Spring AOP会尝试推断参数的配对关系（举个例子，如果pointcut表达式里面只有一个参数绑定，而且advice也只有一个参数，那么这个配对关系就很明显）\n如果在可用的信息里面绑定参数是不确定的，那么AmbiguousBindingException异常将会抛出\n  如果上面的所有策略都失败了，那么IllegalArgumentException异常将会抛出\n  proceed方法如果带参数 之前提过如何写一个带参数的proceed调用。这个解决方法需要确保advice的签名按顺序绑定了目标方法的每一个参数\n@Around(\u0026quot;execution(List\u0026lt;Account\u0026gt; find*(..)) \u0026amp;\u0026amp; \u0026quot; +\r\u0026quot;com.xyz.myapp.CommonPointcuts.inDataAccessLayer() \u0026amp;\u0026amp; \u0026quot; +\r\u0026quot;args(accountHolderNamePattern)\u0026quot;)\rpublic Object preProcessQueryPattern(ProceedingJoinPoint pjp,\rString accountHolderNamePattern) throws Throwable {\rString newPattern = preProcess(accountHolderNamePattern);\rreturn pjp.proceed(new Object[] {newPattern});\r}\r 无论如何都要像上面的例子一样绑定\n2.4.7 advice顺序 当多个advice同时指向一个目标方法时，Spring AOP和AspectJ遵循同样的优先级规则：\n 进入方法：优先级高的先执行（比如两个给定的beforeadvice，优先级高的先执行） 离开方法：优先级高的后执行（比如两个给定的afteradvice，优先级高的后执行）  当两个advice定义在不同的aspect类但指向同一个目标方法时，除非你在其他地方指定了，不然执行顺序是没有定义的。\n你可以直接控制执行的优先级顺序,有两个方式：\n aspect类实现org.springframework.core.Ordered接口 aspect类加注解@Order\n两个切面Ordered.getValue()(或者注解的value)，谁的值更小，睡的优先级更高   从Spring Framework 5.2.7开始，如果advice方法都定义在同一个aspect类中并且都指向同一个目标方法，那么他们的优先级是基于他们的advice类型的\n按照如下的顺序，从高到低：\n@Around,@Before,@After,@AfterReturning,@AfterThrowing\n但请注意因为Spring的AspectJAfterAdvice实现方式，任何在同一个切面类中的@AfterReturning或者AfterThrowingadvice方法执行过后都会去执行@Afteradvice方法\n当两个同样类型的advice(比如，两个@Afteradvice方法)定义在同一个切面类中时，并且都指向同一个目标方法，这种情况下顺序是无法定义的\n因为没有办法从javac已经编译过的类反射中获取源码的申明顺序\n所以当遇到这种情况时，请考虑合并这两个advice方法，或者把重复advice方法提取到另外一个切面类中\n 2.5 Introductions Introductions(在AspectJ中叫做类型间声明) 让切面类可以申明目标方法所在对象实现指定接口，而且提供一个接口的实现类去代表那些对象\n你可以创建一个introduction通过使用@DeclareParents注解。这个注解被用来申明匹配的类型有一个新的父类\n举个例子，给定接口叫做UsageTracked然后这个接口的实现类叫做DefaultUsageTracked\n下面的切面申明了所有实现service的实现类也实现了UsageTracked接口（例如通过JMX公开统计信息）：\n@Aspect\rpublic class UsageTracking {\r@DeclareParents(value=\u0026quot;com.xzy.myapp.service.*+\u0026quot;, defaultImpl=DefaultUsageTracked.class)\rpublic static UsageTracked mixin;\r@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService() \u0026amp;\u0026amp; this(usageTracked)\u0026quot;)\rpublic void recordUsage(UsageTracked usageTracked) {\rusageTracked.incrementUseCount();\r}\r}\r 2.6 切面类实例化模型 默认情况下，对application context来说每个切面类都是单例的。AspectJ将其称作单实例模型。可以使用备用的生命周期来定义Aspect\nSpring 支持AspectJ的perthis和pertarget实例化模型\n暂不支持percflow,percflowbelow，和pertypewithin\n你可以申明一个perthis切面通过制定perthis语句在注解@Aspect中：\n@Aspect(\u0026quot;perthis(com.xyz.myapp.CommonPointcuts.businessService())\u0026quot;)\rpublic class MyAspect{\rprivate int someState;\r@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;)\rpublic void recordServiceUsage(){\r// ...\r}\r}\r 在上面的例子中，perthis语句的作用就是每匹配一个service对象就创建一个切面实例。当一个service对象的方法被调用时，切面实例被第一次创建\n当service对象超出范围时，切面对象也会超出范围（暂不明白这里的超出范围指的是什么）\n在切面实例被创建之前，里面的advice方法不会被调用。只要切面实例被创建，并且service对象与一个切面关联的时候，advice才会在匹配的时候运行\npertarget实例化模型的工作方式跟perthis完全相同\n2.7 一个完整的AOP实例 当执行业务service的时候，有时候会因为并发原因失败（例如，一个因为获取悲观锁失败的操作）。如果重新尝试，很可能在下次尝试的时候成功\n当这种情况出现时，我们应该有一个明显的重试操作以避免向客户端发送PessimisticLockingFailureException。这个需求很明显跨越了多个service，很明显可以用切面来实现\n因为我们需要多次执行proceed方法，所以我们肯定需要around advice：\n@Aspect\rpublic class ConcurrentOperationExecutor implements Ordered {\rprivate static final int DEFAULT_MAX_RETRIES = 2;\rprivate int maxRetries = DEFAULT_MAX_RETRIES;\rprivate int order = 1;\rpublic void setMaxRetries(int maxRetries) {\rthis.maxRetries = maxRetries;\r}\rpublic int getOrder() {\rreturn this.order;\r}\rpublic void setOrder(int order) {\rthis.order = order;\r}\r@Around(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;)\rpublic Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\rint numAttempts = 0;\rPessimisticLockingFailureException lockFailureException;\rdo {\rnumAttempts++;\rtry {\rreturn pjp.proceed();\r}\rcatch(PessimisticLockingFailureException ex) {\rlockFailureException = ex;\r}\r} while(numAttempts \u0026lt;= this.maxRetries);\rthrow lockFailureException;\r}\r}\r 注意上面的切面类实现了Ordered接口，所以我们设置切面类的优先级是高于事务的（我们想每次尝试都是一个新事务）\nmaxRetries和order属性都由Spring配置\n主要的操作都发生在doConcurrentOperationaround advice。注意，在当前情况，我们应用了重试逻辑在每个businessService()。如果运行抛出PessimisticLockingFailureException异常，就会进行重试操作，除非重新操作次数已经耗尽。\n对应的Spring配置如下：\n\u0026lt;aop:aspectj-autoproxy/\u0026gt;\r\u0026lt;bean id=\u0026quot;concurrentOperationExecutor\u0026quot; class=\u0026quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;maxRetries\u0026quot; value=\u0026quot;3\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;order\u0026quot; value=\u0026quot;100\u0026quot;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r 提炼aspect让他只有在幂等操作的时候才重试（幂等：函数多次运行结果与一次运行结果相同），我们可以定义Idempotent注解：\nimport java.lang.annotation.ElementType;\rimport java.lang.annotation.Retention;\rimport java.lang.annotation.RetentionPolicy;\rimport java.lang.annotation.Target;\r@Target(ElementType.METHOD)\r@Retention(RetentionPolicy.RUNTIME)\rpublic @interface Idempotent{}\r 现在可以使用Idempotent注解去标注需要重试的service 方法，同时我们的pointcut表达式也需要修改：\n@Around(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService() \u0026amp;\u0026amp; \u0026quot; +\r\u0026quot;@annotation(com.xyz.myapp.service.Idempotent)\u0026quot;)\rpublic Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\r// ...\r}\r 3. 基于架构的AOP支持（xml配置形式的） xml配置形式的AOP跟基于AspectJ的形，只是方式不一样，用的pointcut表达式都是一样的，这里不细讲，详细参考文末的官方文档\n 详情参考 Spring官方文档\n ","id":131,"section":"posts","summary":"1.切面编程核心概念 切面编程Aspect-oriented Programming (AOP) AOP只是一个概念，跟Spring是独立关系 最典型的AOP实现框架Aspect","tags":["spring"],"title":"Spring切面编程","uri":"https://www.mingaccount.com/2017/06/spring-aop/","year":"2017"},{"content":"LocalVariableTableParameterNameDiscoverer discoverer = new LocalVariableTableParameterNameDiscoverer();\rdiscoverer.getParameterNames(method);\r 详情参考API文档\n","id":132,"section":"posts","summary":"LocalVariableTableParameterNameDiscoverer discoverer = new LocalVariableTableParameterNameDiscoverer(); discoverer.getParameterNames(method); 详情参考API文档","tags":["java"],"title":"根据Method获取所有参数名","uri":"https://www.mingaccount.com/2017/06/method-get-all-argnames/","year":"2017"},{"content":"Java, Java Script, HTML, JSON, CSV and XML org.apache.commons.lang3.StringEscapeUtils\n//使用示例\rStringEscapeUtils.escapeCsv(\u0026quot;\u0026quot;);\rSqtringEscapeUtils.escapeXml(\u0026quot;\u0026quot;);\r  api文档\n Regexp  正则表达式转义所有特殊符号\n 其他 com.google.common.escape.Escapers\nEscaper build = Escapers.builder().addEscape('$', \u0026quot; \u0026quot;).build();\rString str = build.escape(\u0026quot;$$$$\u0026quot;);\r  api文档\n ","id":133,"section":"posts","summary":"Java, Java Script, HTML, JSON, CSV and XML org.apache.commons.lang3.StringEscapeUtils //使用示例 StringEscapeUtils.escapeCsv(\u0026quot;\u0026quot;); SqtringEscapeUtils.escapeXml(\u0026quot;\u0026quot;); api文档 Regexp 正则表达式转义所有特殊符号 其他 com.google.common.escape.Escapers Escaper build = Escapers.builder().addEscape('$', \u0026quot; \u0026quot;).build(); String str = build.escape(\u0026quot;$$$$\u0026quot;); api文档","tags":["java"],"title":"JavaString 特殊符号处理工具类","uri":"https://www.mingaccount.com/2017/05/java-string-special-symbol-handler/","year":"2017"},{"content":"正则表达式的特殊符号包括\n\\ $ ( ) * + . [ ] ? ^ { } | -\n实现代码(java)\npublic class RegexUtils {\rprivate static final String[] SPECIAL_SYMBOLS =\rnew String[]{\u0026quot;\\\\\u0026quot;, \u0026quot;$\u0026quot;, \u0026quot;(\u0026quot;, \u0026quot;)\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;[\u0026quot;, \u0026quot;]\u0026quot;, \u0026quot;?\u0026quot;, \u0026quot;^\u0026quot;, \u0026quot;{\u0026quot;, \u0026quot;}\u0026quot;, \u0026quot;|\u0026quot;, \u0026quot;-\u0026quot;};\r/**\r* 转义目标正则表达式中的所有特殊字符\r* @param regex\r* @return\r*/\rpublic static String escapeSpecialSymbols(String regex) {\rfor (String specSymbol : SPECIAL_SYMBOLS) {\rString escapeSymbol = \u0026quot;\\\\\u0026quot; + specSymbol;\rregex = regex.replace(specSymbol, escapeSymbol);\r}\rreturn regex;\r}\r}\r ","id":134,"section":"posts","summary":"正则表达式的特殊符号包括 \\ $ ( ) * + . [ ] ? ^ { } | - 实现代码(java) public class RegexUtils { private static final String[] SPECIAL_SYMBOLS = new String[]{\u0026quot;\\\\\u0026quot;, \u0026quot;$\u0026quot;, \u0026quot;(\u0026quot;, \u0026quot;)\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;[\u0026quot;, \u0026quot;]\u0026quot;, \u0026quot;?\u0026quot;, \u0026quot;^\u0026quot;, \u0026quot;{\u0026quot;, \u0026quot;}\u0026quot;, \u0026quot;|\u0026quot;, \u0026quot;-\u0026quot;}; /** * 转义目标正","tags":["regexp"],"title":"正则表达式转义所有特殊符号","uri":"https://www.mingaccount.com/2017/05/regex-escape-all-special-symbol/","year":"2017"},{"content":"Java方法如何编译 int add12and13() {\rreturn addTwo(12, 13);\r}\r 将会编译为：\nMethod int add12and13()\r0 aload_0 // Push local variable 0 (this)\r1 bipush 12 // Push int constant 12\r3 bipush 13 // Push int constant 13\r5 invokevirtual #4 // Method Example.addtwo(II)I\r8 ireturn // Return int on top of operand stack;\r// it is the int result of addTwo()\r  引用自官方文档invoking method\n 注意第一步会默认压入一个this参数，这个this参数可以选择申明或者隐藏\n也就是说addTwo有两种声明方法，并且两种都不会影响addTwo(12,13)的调用：\npublic class Test{\rpublic int addTwo(int a,int b){\rreturn a + b;\r}\rpublic int addTwo(Test this,int a,int b){\rreturn a + b;\r}\r}\r 注意第二种写法，this必须是第一个参数并且不能修改参数名和类型\n那也就可以理解为什么一个参数的方法，可以包装为两个参数的BiFunction：\nimport java.util.function.BiFunction;\rpublic class User {\rpublic String test(String msg) {\rSystem.out.println(msg);\r}\r}\rpublic class UnitTest {\r@Test\rpublic void test1() {\r//第一个User参数，代表了默认的this\rBiFunction\u0026lt;User, String, String\u0026gt; test = User::test;\r}\r}\r ","id":135,"section":"posts","summary":"Java方法如何编译 int add12and13() { return addTwo(12, 13); } 将会编译为： Method int add12and13() 0 aload_0 // Push local variable 0 (this) 1 bipush 12 // Push int constant 12 3 bipush 13 // Push int constant 13 5 invokevirtual #4 // Method Example.addtwo(II)I 8 ireturn // Return int on top of operand stack; // it is the","tags":["java"],"title":"Java方法的默认参数","uri":"https://www.mingaccount.com/2017/05/java-method-first-default-param/","year":"2017"},{"content":" project pom.xml文件的顶级元素 modelVersion POM使用的对象模型版本。这个模型的版本几乎不更新，作为必要元素的原因是确保稳定性。 groupId 这个元素代表创建这个项目的机构或者团队的唯一标识符。作为项目的关键标识符，通常的来源是基于机构的完全限定域名。举个例子org.apache.maven.plugins，是为所有Maven plugin设计的groupId。 artifactId 这个元素代表这个项目创建的首要artifact的唯一基础名称。项目的首要artifact一般来说就是JAR文件。次要的artifact，比如说资源包也使用了artifactId作为最终名称的一部分。一个典型Maven产出的artifact会有这样的格式：-.（举个例子，myapp-1.0.jar） version 这个元素代表项目生成的artifact的版本。Maven在版本管理问题上走了很长的路，你会经常在版本中看见SNAPSHOT申明符，他代表项目还在一个开发状态。 name 这个元素代表项目的展示名称。经常被用于Maven生成的文档中。 url 这个元素代表项目的网址是可以被访问到的。经常被用于Maven生成的文档中。 properties 这个元素包含的值，可通过申明的占位符在整个POM中访问。 dependencies 依赖列表，他是POM的基石。 build 申明项目目录结构和管理插件。   更多POM元素和说明，参考POM Reference\n ","id":136,"section":"posts","summary":"project pom.xml文件的顶级元素 modelVersion POM使用的对象模型版本。这个模型的版本几乎不更新，作为必要元素的原因是确保稳定性。 groupId 这个元素代表创建这个项","tags":["maven"],"title":"pom元素说明","uri":"https://www.mingaccount.com/2017/05/pom-tag/","year":"2017"},{"content":"表名  mysql 每一个表至少对应一个服务器文件，而且名字对应，因此表名的大小写敏感跟系统有关系，windows不区分，linux区分 oracle 所有不在双引号里的内容都会被转为大写，想要区分大小写，就用双引号括起来  字段名  mysql 不区分大小写 oracle 跟表名一样，默认会被转为大写，想要区分，需要双引号   mysql可以通过修改lower_case_table_names属性来忽略表名的大小写区分，参考Mysql表名忽略大小写\n 但有个问题需要注意，mysql的大小写忽略，会把所有字符转为小写，而oracle的，像前边所说的会把所有字符转为大写\n","id":137,"section":"posts","summary":"表名 mysql 每一个表至少对应一个服务器文件，而且名字对应，因此表名的大小写敏感跟系统有关系，windows不区分，linux区分 oracle 所有不在双引号里","tags":["mysql","oracle"],"title":"关于mysql和oracle的大小写敏感","uri":"https://www.mingaccount.com/2017/05/mysql-oracle-case-sensitive/","year":"2017"},{"content":"默认情况下mysql的对比条件是大小写不敏感的（latin1_general_ci)，所有不敏感的collate都以_ci结尾。\n要让对比条件大小写敏感，需要将collate设置为以_cs或者_bin结尾（比如utf8_unicode_cs和utf8_bin）\n检查当前的collate 你可以检测你的服务，数据库和连接的collate，通过：\nmysql\u0026gt; show variables like '%collation%';\r+----------------------+-------------------+\r| Variable_name | Value |\r+----------------------+-------------------+\r| collation_connection | utf8_general_ci |\r| collation_database | latin1_swedish_ci |\r| collation_server | latin1_swedish_ci |\r+----------------------+-------------------+\r 你也可以检测表的collate，通过:\nmysql\u0026gt; SELECT table_schema, table_name, table_collation FROM information_schema.tables WHERE table_name = `mytable`;\r+----------------------+------------+-------------------+\r| table_schema | table_name | table_collation |\r+----------------------+------------+-------------------+\r| myschema | mytable | latin1_swedish_ci |\r 改变 collate 你可以改变数据库，表，或者列的collate为大小写敏感：\n-- Change database collation\rALTER DATABASE `databasename` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;\r-- or change table collation\rALTER TABLE `table` CONVERT TO CHARACTER SET utf8 COLLATE utf8_bin;\r-- or change column collation\rALTER TABLE `table` CHANGE `Value` `Value` VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_bin;\r ","id":138,"section":"posts","summary":"默认情况下mysql的对比条件是大小写不敏感的（latin1_general_ci)，所有不敏感的collate都以_ci结尾。 要让对比条件","tags":["mysql"],"title":"Mysql条件对比大小写敏感","uri":"https://www.mingaccount.com/2017/05/mysql-compare-sensitive/","year":"2017"},{"content":"@SpringBootApplication(scanBasePackages=\u0026quot;com.*.*\u0026quot;)\r@EnableScheduling\r@EnableTransactionManagement\r@MapperScan(\u0026quot;com.*.**.*mapper\u0026quot;)\r@EnableConfigurationProperties({CustomConfiguration.class})\rpublic class Application {}\r  SpringBootApplication Spring注解的扫描路径 EnableScheduling 开启Spring的定时任务 EnableTransactionManagement 开始Spring的事务管理 MapperScan 扫描MyBatis Mapper类的路径 EnableConfigurationProperties 自定义配置文件映射类  ","id":139,"section":"posts","summary":"@SpringBootApplication(scanBasePackages=\u0026quot;com.*.*\u0026quot;) @EnableScheduling @EnableTransactionManagement @MapperScan(\u0026quot;com.*.**.*mapper\u0026quot;) @EnableConfigurationProperties({CustomConfiguration.class}) public class Application {} SpringBootApplication Spring注解的扫描路径 EnableScheduling 开启Spring的定时任务 EnableTransactionManagement 开始Spring的事务管理 MapperScan 扫描MyBatis Mapper类的路","tags":["spring"],"title":"SpringBoot入口类常用注解","uri":"https://www.mingaccount.com/2017/05/spring-boot-entry-anno/","year":"2017"},{"content":"通过修改springboot application.properties\nspring.jackson.date-format=yyyy-MM-dd HH:mm:ss\rspring.jackson.time-zone=GMT+8\r ","id":140,"section":"posts","summary":"通过修改springboot application.properties spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8","tags":["jackson","spring"],"title":"Springboot Jackson全局日期格式处理","uri":"https://www.mingaccount.com/2017/04/jackson-global-date-format/","year":"2017"},{"content":"Jackson简介 Spring在@RequestBody和@ResponseBody中对对象的反序列化和序列化，都是借助Jackson来实现的，如果想改变Spring序列化或者反序列化的规则，可以通过调整Spring内部ObjectMapperbean的属性来实现：\n@Configuration\rpublic class JacksonConfig{\r@Bean\rpublic ObjectMapper getObjectMapper(){\rObjectMapper objectMapper = new ObjectMapper();\r//该例子将实体类的Date类型跟指定格式的日期字符串对应\robjectMapper.setDateFormat(new SimpleDateFormat(\u0026quot;yyyy-MM-dd HH:mm:ss\u0026quot;));\rreturn objectMapper; }\r}\r Jackson ObjectMapper的一般使用\npublic void test(){\rUser user = new User();\r...\rObjectMapper mapper = new ObjectMapper();\r//序列化\rString json = mapper.writeValueAsString(user);\r//解析Json为树形结构\rJsonNode node = mapper.readTree(json);\rString name = node.get(\u0026quot;name\u0026quot;).toText();\r//解析Json为指定类的对象\rUser user1 = mapper.readValue(json,User.class);\r}\r 更多使用情景可以参考Jackson-docs\nJackson的扩展注解 @JsonProperty 作用在类的属性上，为其添加一个别名，会影响序列化的属性名称\npublic class User implements Serializable{\r@JsonProperty(\u0026quot;sName\u0026quot;)\rprivate String name;\r}\r {\u0026quot;sName\u0026quot;:\u0026quot;赵四\u0026quot;}\r @JsonIgnore 作用在类的属性上，序列化时忽略某个属性\npublic class User implements Serializable{\r@JsonIgnore\rprivate String name; }\r @JsonIgnoreProperties 作用在类上，批量忽略类属性\n@JsonIgnoreProperties({\u0026quot;age\u0026quot;,\u0026quot;sex\u0026quot;})\rpublic class User\r 注意，如果属性有别名，那么就写别名，比如要忽略之前的属性name，因为他有别名，所以应该在@JsonIgnoreProperteis中填写他的别名sName\n@JsonFormat 作用在属性上，格式化属性\n一般用来格式化日期\npublic class User implements Serializable{\r@JsonFormat(pattern=\u0026quot;yyyy-MM-dd HH:mm:ss\u0026quot;)\rprivate Date date;\r}\r @JsonNaming 作用在类或者属性上，改变序列化属性的命名规则\n@JsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class)\rpublic class User implements Serializable{\rprivate String userName;\r}\r 上面的SnakeCaseStrategy规则，会将属性userName转为Json属性user-name\n@JsonSerialize 作用在类上，代表指定自己的序列化规则类\n@JsonSerialize(UserSerializer.class)\rpublic class User implements Serializable{}\r 下面要实现自定义序列化规则，需要继承抽象类JsonSerializer\npublic class UserSerializer extends JsonSerializer\u0026lt;User\u0026gt;{\r@Override\rpublic void serialize(User user, JsonGenerator generator, SerializerProvider provider)\rthrows IOException, JsonProcessingException {\rgenerator.writeStartObject();\rgenerator.writeStringField(\u0026quot;public-info\u0026quot;, user.getPublicInfo());\rgenerator.writeEndObject();\r}\r}\r @JsonDeserialize 作用在类上，代表指定自己的反序列化规则类\n@JsonDeserialize(UserDeserializer.class)\rpublic class User implements Serializable{}\r 下面要实现自定义反序列化规则，需要继承抽象类JsonDeserializer\npbulic class UserDeserializer extends JsonDeserializer\u0026lt;User\u0026gt;{\r@Override\rpublic User deserialize(JsonParser parser, DeserializationContext context)\rthrows IOException, JsonProcessingException {\rJsonNode node = parser.getCodec().readTree(parser);\rString publicInfo = node.get(\u0026quot;public-info\u0026quot;).asText();\rUser user = new User();\ruser.setPublicInfo(publicInfo);\rreturn user;\r}\r}\r @JsonView 作用在类的属性上和返回User的方法上，比如返回该对象的controller方法，@JsonView可以让两个方法虽然返回的同一个实例，但是展示的字段却不相同\npublic class User implements Serializable{\r@JsonView(AllField.class)\rprivate String id;\r@JsonView(JustName.class)\rprivate String name;\r@JsonView(AllField.class)\rprivate String sex;\rpublic interface JustName{}\rpublic interface AllField extends JustName{}\r}\r 用不同接口代表不同的view，使用继承的方式，可以避免一些重复的声明\n下面是调用方法的申明：\n@GetMapping(\u0026quot;get/name\u0026quot;)\r@ResponseBody\r@JsonView(User.JustName.class)\rpublic User getUserName(){}\r@GetMapping(\u0026quot;get/all\u0026quot;)\r@ResponseBody\r@JsonView(User.AllField.class)\rpublic User getAllUserField(){}\r 假设上面两个方法的方法体完全相同，因为JsonView的原因，第一个方法只会返回{\u0026quot;name\u0026quot;:\u0026quot;赵四\u0026quot;}，而第二个方法则会返回四哥的所有信息\n 更多jackson注解参考jackson annotation\n Jackson泛型 String json = \u0026quot;[{\\\u0026quot;name\\\u0026quot;:\\\u0026quot;赵四\\\u0026quot;}]\u0026quot;\rList\u0026lt;User\u0026gt; users = objectMapper.readValue(json,List.class);\rUser user = users.get(0);\r 上面的代码会在第三行的时候抛出异常：linkedHashMap cannot cast to User\n因为objectMapper反序列化的时候并没有提供List的泛型，jackson内部并不知道list子元素是什么类型，所以默认转为了LinkedHashMap\njackson提供了泛型处理：\nJavaType type = TypeFactory.defaultInstance.constructParametricType(List.class, User.class);\rList\u0026lt;User\u0026gt; list = mapper.readValue(json, type);\r ","id":141,"section":"posts","summary":"Jackson简介 Spring在@RequestBody和@ResponseBody中对对象的反序列化和序列化，都是借助Jackson来实现","tags":["jackson","spring"],"title":"Jackson使用解析","uri":"https://www.mingaccount.com/2017/04/jackson/","year":"2017"},{"content":"1.新建banner.txt在resources目录下 _/_/_/ _/ _/ _/_/_/ _/ _/ _/_/ _/ _/ _/ _/ _/_/ _/ _/ _/ _/ _/_/_/_/ _/ _/ _/ _/ _/_/_/_/ _/ _/ _/ _/ _/ _/_/ _/ _/ _/_/_/ _/ _/ _/_/_/ _/ _/ _/ _/  文本图形生成器\n2.开关控制 @SpringBootApplication\rpublic class Application {\rpublic static void main(String[] args) {\rSpringApplication springApplication = new SpringApplication(Application.class);\r//控制banner是否展示\rspringApplication.setBannerMode(Banner.Mode.OFF);\rspringApplication.run(args);\r}\r}\r ","id":142,"section":"posts","summary":"1.新建banner.txt在resources目录下 _/_/_/ _/ _/ _/_/_/ _/ _/ _/_/ _/ _/ _/ _/ _/_/ _/ _/ _/ _/ _/_/_/_/ _/ _/ _/ _/ _/_/_/_/ _/ _/ _/ _/ _/ _/_/ _/ _/ _/_/_/ _/ _/ _/_/_/ _/ _/ _/ _/ 文本图形生","tags":["spring"],"title":"修改SpringBoot日志打印时候的标志","uri":"https://www.mingaccount.com/2017/04/modify-spring-boot-banner/","year":"2017"},{"content":"参考Spring官网配置参数\n完整列出了所有application配置文件中可用的参数\n","id":143,"section":"posts","summary":"参考Spring官网配置参数 完整列出了所有application配置文件中可用的参数","tags":["spring"],"title":"Spring Application配置文件通用参数","uri":"https://www.mingaccount.com/2017/04/spring-properties-common-key/","year":"2017"},{"content":"新建指定配置类TestConfiguration\n该类需要的注解：\n@Configuration\r@ConfigurationProperties(prefix=\u0026quot;test\u0026quot;)\r@PropertySource(\u0026quot;classpath:test.properties\u0026quot;)\r 同时启动类上需要增加注解：\n@EnableConfigurationProperties({TestConfiguration.class})\r ","id":144,"section":"posts","summary":"新建指定配置类TestConfiguration 该类需要的注解： @Configuration @ConfigurationProperties(prefix=\u0026quot;test\u0026quot;) @PropertySource(\u0026quot;classpath:test.properties\u0026quot;) 同时启动类上需要增加注解： @EnableConfigurationProperties({TestConfiguration.class})","tags":["spring"],"title":"Spring自定义配置文件并映射到指定类中","uri":"https://www.mingaccount.com/2017/01/spring-boot-external-properties/","year":"2017"},{"content":"概览 try-with-resources表达式可以自动关闭申明在表达式中的资源，但前提是这些资源类要实现java.lang.AutoCloseable或者java.io.Closeable。\n下面的例子使用BufferedReader的实例读取了文件的第一行：\nstatic String readFirstLineFromFile(String path)throws IOException{\rtry(BufferedReader br=\rnew BufferedReader(new FileReader(path))){\rreturn br.readLine();\r}\r}\r 因为BufferedReader在try-with-resources表达式中，并且他实现了AutoCloseable，意味着不管程序运行结果如何，他都会自动关闭。\n但在java7之前，你只有通过finally来完成资源的关闭：\nstatic String readFirstLineFromFileWithFinallyBlock(String path)\rthrows IOException {\rBufferedReader br = new BufferedReader(new FileReader(path));\rtry {\rreturn br.readLine();\r} finally {\rif (br != null) br.close();\r}\r}\r 虽然能够达到try-with-resources表达式同样的目的，但是如果try的代码块和finally都同时抛出异常，那么finally的异常就会覆盖掉try的异常。\n但在之前的readFirstLineFromFile方法例子中，使用try-with-resources表达式时，如果try-with-resources表达式和try的代码块同时抛出异常，最终抛出的会是try代码块的。\n你有可能同时在try-with-resources表达式中申明多个资源，下面就是一个例子，他解析zip包中的所有文件名，并将他们写入到一个文件中。\npublic static void writeToFileZipFileContents(String zipFileName,\rString outputFileName)\rthrows java.io.IOException {\rjava.nio.charset.Charset charset =\rjava.nio.charset.StandardCharsets.US_ASCII;\rjava.nio.file.Path outputFilePath =\rjava.nio.file.Paths.get(outputFileName);\r// Open zip file and create output file with // try-with-resources statement\rtry (\rjava.util.zip.ZipFile zf =\rnew java.util.zip.ZipFile(zipFileName);\rjava.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)\r) {\r// Enumerate each entry\rfor (java.util.Enumeration entries =\rzf.entries(); entries.hasMoreElements();) {\r// Get the entry name and write it to the output file\rString newLine = System.getProperty(\u0026quot;line.separator\u0026quot;);\rString zipEntryName =\r((java.util.zip.ZipEntry)entries.nextElement()).getName() +\rnewLine;\rwriter.write(zipEntryName, 0, zipEntryName.length());\r}\r}\r}\r 在这个例子中，同时申明了两个资源ZipFile和BufferedWriter，他们通过分号分隔。一旦代码块执行完毕，他们会按照BufferedWriter，ZipFile的顺序进行关闭。注意，资源创建的顺序和他们被关闭的顺序是相反的。\n下面的例子使用try-with-resources去关闭一个java.sql.Statement资源：\npublic static void viewTable(Connection con) throws SQLException {\rString query = \u0026quot;select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES\u0026quot;;\rtry (Statement stmt = con.createStatement()) {\rResultSet rs = stmt.executeQuery(query);\rwhile (rs.next()) {\rString coffeeName = rs.getString(\u0026quot;COF_NAME\u0026quot;);\rint supplierID = rs.getInt(\u0026quot;SUP_ID\u0026quot;); float price = rs.getFloat(\u0026quot;PRICE\u0026quot;);\rint sales = rs.getInt(\u0026quot;SALES\u0026quot;);\rint total = rs.getInt(\u0026quot;TOTAL\u0026quot;);\rSystem.out.println(coffeeName + \u0026quot;, \u0026quot; + supplierID + \u0026quot;, \u0026quot; + price + \u0026quot;, \u0026quot; + sales + \u0026quot;, \u0026quot; + total);\r}\r} catch (SQLException e) {\rJDBCTutorialUtilities.printSQLException(e);\r}\r}\r 注意： try-with-resources表达式也能像一般try表达式一样申明catch和finally，只不过他们都会在try-with-resources资源关闭之后才会进行\n被压制的异常 在方法writeToFileZipFileContents中，try-with-resources表达式申明了两个资源，在尝试关闭这两个资源的时候可能会抛出两个异常。但如果try的代码块本身也有异常抛出，那么try-with-resources表达式产生的异常就会被压制，想查看这些被压制的异常，可以通过代码块异常的throwable.getSuppressed方法来获取。\n实现Closeable和AutoCloseable的类 参考AutoCloseable 和Closeable 分别查看他们的实现类。Closeable继承了AutoCloseable。当Closeable中的close方法出错时抛出的是IOException，但是AutoCloseable的close方法抛出的却是Exception。因此AutoCloseable的实现可以根据具体情况调整抛出的异常。\n","id":145,"section":"posts","summary":"概览 try-with-resources表达式可以自动关闭申明在表达式中的资源，但前提是这些资源类要实现java.lang.AutoClos","tags":["java"],"title":"java7特性try-with-resources","uri":"https://www.mingaccount.com/2016/08/try-with-resources/","year":"2016"},{"content":" 测试数据     random     24   24uixcvkjklwer     查询sql1  SELECT random FROM table WHERE random = 24\r 该sql会把两条记录都查出来\n 查询sql2  SELECT random FROM table WHERE random = '24'\r 该sql只会匹配第一条记录\n 总结\n条件列为字符串的时候，保证用来判断的常量也是字符类型  ","id":146,"section":"posts","summary":"测试数据 random 24 24uixcvkjklwer 查询sql1 SELECT random FROM table WHERE random = 24 该sql会把两条记录都查出来 查询sql2 SELECT random FROM table WHERE random = '24' 该sql只会匹配第一条记录 总结 条件列为字符","tags":["mysql"],"title":"Mysql Where条件判断 字符串和数字 是否相等时存在的问题","uri":"https://www.mingaccount.com/2016/07/mysql-compare-string-and-number/","year":"2016"},{"content":"现在可以通过lombok注解@Builder一步实现\n 1.调用效果 public class Test{\rpublic static void main(String[] args){\rStudent student = Student.builder().name(\u0026quot;小明\u0026quot;).age(15).sex(\u0026quot;男\u0026quot;).build();\r}\r}\r 2.实现原理 public class Student {\rprivate String name;\rprivate Integer age;\rprivate String sex;\rpublic static Builder builder() {\rreturn new Builder();\r}\rpublic Student(Builder builder) {\rthis.name = builder.name;\rthis.age = builder.age;\rthis.sex = builder.sex;\r}\rpublic static class Builder{\rprivate String name ;\rprivate Integer age ;\rprivate String sex;\rpublic Builder name(String name) {\rthis.name = name;\rreturn this;\r}\rpublic Builder age(Integer age) {\rthis.age = age;\rreturn this;\r}\rpublic Builder sex(String sex) {\rthis.sex = sex;\rreturn this;\r}\rpublic Student build() {\rreturn new Student(this);\r}\r}\r}\r 3.静态内部类  静态内部类无需依赖外部类，可以独立存在 多个外部类可以共享一个静态内部类 普通内部类不能申明静态的方法和变量，但是静态内部类无限制  ","id":147,"section":"posts","summary":"现在可以通过lombok注解@Builder一步实现 1.调用效果 public class Test{ public static void main(String[] args){ Student student = Student.builder().name(\u0026quo","tags":["java","design pattern"],"title":"实体类通过建造者模式创建","uri":"https://www.mingaccount.com/2016/06/pojo-builder/","year":"2016"},{"content":"示例代码 public void insert(User user){\rmapper.insert(user);\rString id = user.getId();\r}\r id会赋值到传进来的user对象中\nxml \u0026lt;insert keyProperty=\u0026quot;id\u0026quot; keyColumn=\u0026quot;id\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot;\u0026gt;\rINSERT INTO ...\r\u0026lt;/insert\u0026gt;\r keyProperty代表实体类中主键对应的成员变量名称\nkeyColumn代表表主键字段对应的名称\nuserGeneratedKeys代表使用的是自增id\n","id":148,"section":"posts","summary":"示例代码 public void insert(User user){ mapper.insert(user); String id = user.getId(); } id会赋值到传进来的user对象中 xml \u0026lt;insert keyProperty=\u0026quot;id\u0026quot; keyColumn=\u0026quot;id\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot;\u0026gt; INSERT INTO ... \u0026lt;/insert\u0026gt; keyProperty代表实体类中主键对应的成员变量名称 ke","tags":["mybatis"],"title":"Mybatis insert完成后获取自增主键","uri":"https://www.mingaccount.com/2016/05/mybatis-get-auto-increment-id/","year":"2016"},{"content":"org.junit.Assert  assertEquals 判断对象是否相等，equals方法判断 assertSame 判断对象是否相等，==判断 assertTrue 判断条件是否为真 assertFalse 判断条件是否为假 assertNotNull 判断对象是否不为null assertArrayEquals 判断数组是否相等  org.skyscreamer.jsonassert.JSONAssert JSONAssert可对json进行断言\n 判断两个JSON对象 assertEquals(\u0026hellip;boolean strict) 字段顺序不影响结果。当strict为false时，一个json是另外一个json的子集也能通过(比如{\u0026ldquo;id\u0026rdquo;:1}和{\u0026ldquo;id\u0026rdquo;:1,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;赵四\u0026rdquo;}) 判断两个JSON数组 assertEquals(\u0026hellip;boolean strict) 所有子元素必须全匹配，strict为false时，可以忽略数组顺序  AssertJ AssertJ是一个强大的链式结构的断言，一段代码可以进行多个断言。下面是一个官方实例：\n// entry point for all assertThat methods and utility methods (e.g. entry)\rimport static org.assertj.core.api.Assertions.*;\r// basic assertions\rassertThat(frodo.getName()).isEqualTo(\u0026quot;Frodo\u0026quot;);\rassertThat(frodo).isNotEqualTo(sauron);\r// chaining string specific assertions\rassertThat(frodo.getName()).startsWith(\u0026quot;Fro\u0026quot;)\r.endsWith(\u0026quot;do\u0026quot;)\r.isEqualToIgnoringCase(\u0026quot;frodo\u0026quot;);\r// collection specific assertions (there are plenty more)\r// in the examples below fellowshipOfTheRing is a List\u0026lt;TolkienCharacter\u0026gt;\rassertThat(fellowshipOfTheRing).hasSize(9)\r.contains(frodo, sam)\r.doesNotContain(sauron);\r// as() is used to describe the test and will be shown before the error message\rassertThat(frodo.getAge()).as(\u0026quot;check %s's age\u0026quot;, frodo.getName()).isEqualTo(33);\r// exception assertion, standard style ...\rassertThatThrownBy(() -\u0026gt; { throw new Exception(\u0026quot;boom!\u0026quot;); }).hasMessage(\u0026quot;boom!\u0026quot;);\r// ... or BDD style\rThrowable thrown = catchThrowable(() -\u0026gt; { throw new Exception(\u0026quot;boom!\u0026quot;); });\rassertThat(thrown).hasMessageContaining(\u0026quot;boom\u0026quot;);\r// using the 'extracting' feature to check fellowshipOfTheRing character's names\rassertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName)\r.doesNotContain(\u0026quot;Sauron\u0026quot;, \u0026quot;Elrond\u0026quot;);\r// extracting multiple values at once grouped in tuples\rassertThat(fellowshipOfTheRing).extracting(\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;, \u0026quot;race.name\u0026quot;)\r.contains(tuple(\u0026quot;Boromir\u0026quot;, 37, \u0026quot;Man\u0026quot;),\rtuple(\u0026quot;Sam\u0026quot;, 38, \u0026quot;Hobbit\u0026quot;),\rtuple(\u0026quot;Legolas\u0026quot;, 1000, \u0026quot;Elf\u0026quot;));\r// filtering a collection before asserting\rassertThat(fellowshipOfTheRing).filteredOn(character -\u0026gt; character.getName().contains(\u0026quot;o\u0026quot;))\r.containsOnly(aragorn, frodo, legolas, boromir);\r// combining filtering and extraction (yes we can)\rassertThat(fellowshipOfTheRing).filteredOn(character -\u0026gt; character.getName().contains(\u0026quot;o\u0026quot;))\r.containsOnly(aragorn, frodo, legolas, boromir)\r.extracting(character -\u0026gt; character.getRace().getName())\r.contains(\u0026quot;Hobbit\u0026quot;, \u0026quot;Elf\u0026quot;, \u0026quot;Man\u0026quot;);\r// and many more assertions: iterable, stream, array, map, dates, path, file, numbers, predicate, optional ...\r AssertJ的语法比较简单，通过ide提示基本都能找到目标断言，更多可以参考AssertJ官方文档 和 AssertJ java doc\n","id":149,"section":"posts","summary":"org.junit.Assert assertEquals 判断对象是否相等，equals方法判断 assertSame 判断对象是否相等，==判断 assertTrue 判断条件是否为真 assertFalse 判断条件是否为假 assertNotNull 判断对象是否不为null assertArrayEquals 判断数","tags":["unit-test"],"title":"Assert常用方法","uri":"https://www.mingaccount.com/2016/05/assert-common-method/","year":"2016"},{"content":"示例sql SELECT * FROM table WHERE field LIKE '%_%'\r 目的是获取中间有下划线的field，但是这样的sql无法获取到期望的结果\n问题原因 like语句中除了百分号是通配符，下划线也是通配符。只是百分号代表一个或者多个字符，下划线代表一个字符（比如hello，可以通过__llo匹配）。如果要把百分号或者下划线作为匹配内容，那么需要在前面加上斜杠：\\：\nSELECT * FROM table WHERE field LIKE '%\\_%'\r ","id":150,"section":"posts","summary":"示例sql SELECT * FROM table WHERE field LIKE '%_%' 目的是获取中间有下划线的field，但是这样的sql无法获取到期望的结果 问题原因 like语句中除了百分号是通配符，","tags":["mysql"],"title":"Mysql Like语句匹配下划线时无法得到正确数据","uri":"https://www.mingaccount.com/2016/05/mysql-like-underline/","year":"2016"},{"content":" wiki List of HTTP header fields\n ","id":151,"section":"posts","summary":"wiki List of HTTP header fields","tags":["protocol"],"title":"所有HTTP头字段(header fields)","uri":"https://www.mingaccount.com/2016/05/http-heads/","year":"2016"},{"content":" 常见状态码   所有状态码iana all HTTP status code\n常用状态码及说明wiki List of HTTP status code\n    状态码 状态码英文名称 中文描述     100 Continue 继续。客户端应继续其请求   101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议   200 OK 请求成功。一般用于GET与POST请求   201 Created 已创建。成功请求并创建了新的资源   202 Accepted 已接受。已经接受请求，但未处理完成   203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档   205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域   206 Partial Content 部分内容。服务器成功处理了部分GET请求   300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择   301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替   302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   303 See Other 查看其它地址。与301类似。使用GET和POST请求查看   304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源   305 Use Proxy 使用代理。所请求的资源必须通过代理访问   306 Unused 已经被废弃的HTTP状态码   307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向   400 Bad Request 客户端请求的语法错误，服务器无法理解   401 Unauthorized 请求要求用户的身份认证   402 Payment Required 保留，将来使用   403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求   404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\u0026quot;您所请求的资源无法找到\u0026quot;的个性页面   405 Method Not Allowed 客户端请求中的方法被禁止   406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求   407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权   408 Request Time-out 服务器等待客户端发送的请求时间过长，超时   409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突   410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置   411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息   412 Precondition Failed 客户端请求信息的先决条件错误   413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息   414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理   415 Unsupported Media Type 服务器无法处理请求附带的媒体格式   416 Requested range not satisfiable 客户端请求的范围无效   417 Expectation Failed 服务器无法满足Expect的请求头信息   500 Internal Server Error 服务器内部错误，无法完成请求   501 Not Implemented 服务器不支持请求的功能，无法完成请求   502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应   503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中   504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求   505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理    ","id":152,"section":"posts","summary":"常见状态码 所有状态码iana all HTTP status code 常用状态码及说明wiki List of HTTP status code 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议","tags":["protocol"],"title":"所有HTTP状态码(status code)","uri":"https://www.mingaccount.com/2016/05/status-code/","year":"2016"},{"content":" 所有的Content-type   完整列表iana media type\n  常用的Content-type   常用列表及说明runoob content type ** application\n application/java-archive\rapplication/EDI-X12 application/EDIFACT application/javascript application/octet-stream application/ogg application/pdf application/xhtml+xml application/x-shockwave-flash application/json application/ld+json application/xml application/zip application/x-www-form-urlencoded  ** audio\naudio/mpeg audio/x-ms-wma audio/vnd.rn-realaudio audio/x-wav  ** image\nimage/gif image/jpeg image/png image/tiff image/vnd.microsoft.icon image/x-icon image/vnd.djvu image/svg+xml  ** multipart\nmultipart/mixed multipart/alternative multipart/related (using by MHTML (HTML mail).) multipart/form-data  ** text\ntext/css text/csv text/html text/javascript (obsolete) text/plain text/xml  ** video\nvideo/mpeg video/mp4 video/quicktime video/x-ms-wmv video/x-msvideo video/x-flv video/webm  ** vnd\napplication/vnd.android.package-archive\rapplication/vnd.oasis.opendocument.text application/vnd.oasis.opendocument.spreadsheet application/vnd.oasis.opendocument.presentation application/vnd.oasis.opendocument.graphics application/vnd.ms-excel application/vnd.openxmlformats-officedocument.spreadsheetml.sheet application/vnd.ms-powerpoint application/vnd.openxmlformats-officedocument.presentationml.presentation application/msword application/vnd.openxmlformats-officedocument.wordprocessingml.document application/vnd.mozilla.xul+xml  ","id":153,"section":"posts","summary":"所有的Content-type 完整列表iana media type 常用的Content-type 常用列表及说明runoob content type ** application application/java-archive application/EDI-X12 application/EDIFACT application/javascript application/octet-stream application/ogg application/pdf application/xhtml+xml application/x-shockwave-flash application/json application/ld+json application/xml application/zip","tags":["protocol"],"title":"所有Content-type(content type)","uri":"https://www.mingaccount.com/2016/05/content-type/","year":"2016"},{"content":"注释中如果要指向一个类或者其成员，直接写名字容易出错，且ide无法跳转。可以使用{@link}来引用\n /**\r* {@link String#toString()} }\r* 在类后面追加#号，可以指向类的成员方法或者变量\r**/\rpublic class Test{\r}\r ","id":154,"section":"posts","summary":"注释中如果要指向一个类或者其成员，直接写名字容易出错，且ide无法跳转。可以使用{@link}来引用 /** * {@link String#toString()} } * 在类后面追加#号，可以指向类","tags":["java"],"title":"Java注释引用类和其成员","uri":"https://www.mingaccount.com/2016/04/java-comment-refere-class/","year":"2016"},{"content":"他们之间的区别就是是否能够同时修改列名和列的定义。\nCHANGE 你可以修改列名和列定义\nALTER TABLE t1 CHANGE a b BIGINT NOT NULL\r MODIFY 可以修改列定义，但是不能修改列名\nALTER TABLE t1 MODIFY b INT NOT NULL\r RENAME COLUMN 可以修改列名，但是不能修改列定义\nALTER TABLE t1 RENAME COLUMN b TO a\r  详情参考doc\n ","id":155,"section":"posts","summary":"他们之间的区别就是是否能够同时修改列名和列的定义。 CHANGE 你可以修改列名和列定义 ALTER TABLE t1 CHANGE a b BIGINT NOT NULL MODIFY 可以修改列定义，但是不能修改列名 ALTER TABLE t1 MODIFY b INT NOT","tags":["mysql"],"title":"Mysql modify和change的区别","uri":"https://www.mingaccount.com/2016/03/mysql-modify-and-change/","year":"2016"},{"content":"标准申明 /**\r* Describes the Request-For-Enhancement(RFE) that led\r* to the presence of the annotated API element.\r*/\rpublic @interface RequestForEnhancement {\rint id();\rString synopsis();\rString engineer() default \u0026quot;[unassigned]\u0026quot;; String date(); default \u0026quot;[unimplemented]\u0026quot;; }\r RequestForEnhancement注解包含的成员参数，需要通过方法来申明。如果有默认值，可以通过default来指定。\n成员方法的返回类型是有限制的，只能是：\n 原始类型 String Class enums 注解\n要么是上面五种类型，要么就是这五种类型的数组，其他的都不支持。  唯一参数 /**\r* Associates a copyright notice with the annotated API element.\r*/\rpublic @interface Copyright {\rString value();\r}\r 如果注解只有一个参数，那么参数对应的方法名称应该是value。并且在调用该注解时，可以忽略参数名称和等于符号：\n@Copyright(\u0026quot;2002 Yoyodyne Propulsion Systems\u0026quot;)\rpublic class OscillationOverthruster { ... }\r @Target 用来指定注解修饰的目标类型，比如在方法或者在类上等等。\n@Retention 该注解用来指定所修饰的注解要保留多长时间。\n注解@Retention只有一个成员RetentionPolicy枚举。 RetentionPolicy枚举有三个常量（按照顺序，保留时间递增）：\n SOURCE CLASS RUNTIME  SOURCE 代表这个注解是对编译器可见的，但是在.class文件和运行时不可用。编译器常用这类注解来检测异常和屏蔽警告。编译器在使用完这类注解后，会直接丢弃。\nCLASS 代表这个注解会记录到.class文件中。但是虚拟机不需要在运行时保留它。这是默认策略。\nRUNTIME 代表这个注解会记录到.class文件中，并且虚拟机在运行时也会保留它。这意味着可以通过反射读取。\n annotation\nRetentionPolicy\n ","id":156,"section":"posts","summary":"标准申明 /** * Describes the Request-For-Enhancement(RFE) that led * to the presence of the annotated API element. */ public @interface RequestForEnhancement { int id(); String synopsis(); String engineer() default \u0026quot;[unassigned]\u0026quot;; String date(); default \u0026quot;[unimplemented]\u0026quot;; } RequestForEnhancement注解包含的成员参数，需","tags":["java"],"title":"Java注解说明","uri":"https://www.mingaccount.com/2016/03/annotation/","year":"2016"},{"content":"public class Test{\r/**\r** 一种是直接指定初始值\r**/\rfinal String msg = \u0026quot;\u0026quot;;\r/**\r** 另一种是不指定初始值，在构造方法里面指定\r** 但不允许无参构造的存在，并且每一个构造方法都要对该变量赋值\r**/\rfinal String msg1;\rpublic Test(String msg1){\rthis.msg1 = msg1; }\r}\r ","id":157,"section":"posts","summary":"public class Test{ /** ** 一种是直接指定初始值 **/ final String msg = \u0026quot;\u0026quot;; /** ** 另一种是不指定初始值，在构造方法里面指定 ** 但不允许无参构造的存在，并且每一个构造方法都要对该变","tags":["java"],"title":"Java final成员变量初始化","uri":"https://www.mingaccount.com/2016/01/java-final-constructor/","year":"2016"},{"content":"1.Oracle 12c R1 (12.1)支持limit语句 从Oracle 12c R1 (12.1)版本开始，oracle开始支持limit语句，但是跟熟悉的limit(1, 10)语句还是有区别的\noracle的语句更复杂，但是有更多选项能做更多的事。参考oracle limit完整的语法 (关于oracle内部是如何实现limit的可以参考这个回答)\n那么一个oracle limit语句到底应该怎么写了，比如要取21-30行的数据：\nSELECT * FROM sometable\rORDER BY name\rOFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;\r 上面是一个简单直接的例子，下面是引用自官方说明的更多实例:\n1.1 初始化 DROP TABLE rownum_order_test;\rCREATE TABLE rownum_order_test (\rval NUMBER\r);\rINSERT ALL\rINTO rownum_order_test\rINTO rownum_order_test\rSELECT level\rFROM dual\rCONNECT BY level \u0026lt;= 10;\rCOMMIT;\r 表rownum_order_test里的内容：\nSELECT val\rFROM rownum_order_test\rORDER BY val;\rVAL\r----------\r1\r1\r2\r2\r3\r3\r4\r4\r5\r5\r6\r6\r7\r7\r8\r8\r9\r9\r10\r10\r20 rows selected.\r 1.2 Top-N 查询 SELECT val\rFROM rownum_order_test\rORDER BY val DESC FETCH FIRST 10 ROWS ONLY;\rVAL\r----------\r10\r10\r9\r9\r8\r5 rows selected.\r 1.3 WITH TIES 使用WITH TIES语句，在最后一行有重复值存在时，将会把最后一行的重复值都返回。在这个例子中第五行的值是8，但是根据排序，有两个行数值都为8的，所以这两个都保留\nSELECT val\rFROM rownum_order_test\rORDER BY val DESC\rFETCH FIRST 5 ROWS WITH TIES;\rVAL\r----------\r10\r10\r9\r9\r8\r8\r6 rows selected.\r 1.4 前百分比数据量限制 SELECT val\rFROM rownum_order_test\rORDER BY val\rFETCH FIRST 20 PERCENT ROWS ONLY;\rVAL\r----------\r1\r1\r2\r2\r4 rows selected.\r 1.5 分页 ELECT val\rFROM rownum_order_test\rORDER BY val\rOFFSET 4 ROWS FETCH NEXT 4 ROWS ONLY;\rVAL\r----------\r3\r3\r4\r4\r4 rows selected.\r 代表从OFFSET+1开始取4行\n1.6 offset和百分比结合 SELECT val\rFROM rownum_order_test\rORDER BY val\rOFFSET 4 ROWS FETCH NEXT 20 PERCENT ROWS ONLY;\rVAL\r----------\r3\r3\r4\r4\r4 rows selected.\r 2.旧版本不支持limit语句 旧版本的oracle不支持limit语句，需要通过子查询来实现，原因可参考On ROWNUM and limiting results\n2.1 Top-N select *\rfrom ( select * from emp order by sal desc ) where ROWNUM \u0026lt;= 5;\r 2.2 区间 select * from ( select a.*, ROWNUM rnum from ( \u0026lt;your_query_goes_here, with order by\u0026gt; ) a where ROWNUM \u0026lt;= :MAX_ROW_TO_FETCH )\rwhere rnum \u0026gt;= :MIN_ROW_TO_FETCH;\r 2.3 原因 oracle分页的写法显得特别臃肿和多余，但是对于旧版本来说没得选择，这个写法规避了很多排序的问题并且高效\n首先要明白一个概念，ROWNUM并不是跟行绑定的，他是sql执行完from where后，并在排序和聚合前，每得到一个结果就分配一个ROWNUM\n所以像下面这种写法肯定得不到任何结果\nSELECT * FROM t\rWHERE ROWNUM \u0026gt; 1\r 当from获取到第一行，因为还没有经过where判断，所以没有分配ROWNUM，只能读取到ROWNUM的默认值1，然而这个where条件肯定不能成立，也就是说ROWNUM没有分配到第一行（分配逻辑包含自增），永远到不了2，该查询肯定没有结果\n2.3.1 为什么要用子查询 当使用排序时，因为ROWNUM的分配是在排序之前的，所以是先得到10条数据然后排序，而不是先排序后取10条\nSELECT *\rFROM t WHERE ROWNUM \u0026lt;= 10\rORDER BY col DESC  需要封装一个子查询后再限制ROWNUM\nSELECT * FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC )\rWHERE ROWNUM \u0026lt;= 10\r 2.3.2 对Top-N的优化 使用子查询ROWNUM的方式，另外一个原因是oracle对他进行了优化\n如果直接进行查询，再对结果进行筛选，像下面的例子\nSELECT *\rFROM t\rORDER BY col DESC  当表的数据有百万甚至千万行的时候，这个表的所有数据都要放到内存中进行排序，如果用于排序的内存满了，还需要暂存到磁盘上。 大量io和磁盘读写，耗费时间，并且占用资源，仅仅只是为了获取10行数据\n使用子查询ROWNUM的方式，如下\nSELECT * FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC )\rWHERE ROWNUM \u0026lt;= 10\r ORACLE对他进行了优化，像上面的例子，当查询一开始，会将最开始的10个col值保存到内存中排序，然后获取第11个跟内存中的第10个进行比较\n如果在区间外，那么直接忽略这个值。如果在区间内，那么删除原本第10个值，追加第11个，重新进行排序\n按照这个逻辑，遍历时只需要对内存中的10个值进行排序，节省大量资源和时间\n2.3.3 分页注意事项 与top-n的随机性不一样，分页需要同样条件下每次的查询结果都是一致的，但如果排序列有大量的重复值，一致性无法保证\nSELECT *\rFROM (\rSELECT a.*,ROWNUM rn FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC ) a\rWHERE ROWNUM \u0026lt;= 10\r)\rHWERE rn \u0026gt;=6\r 上面的例子中如果col列有大量重复值，每次查询的结果都会不一样\n解决方案是在order by语句中追加ROWID，因为ROWID在表中是唯一的\nSELECT *\rFROM (\rSELECT a.*,ROWNUM rn FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC ,ROWID\r) a\rWHERE ROWNUM \u0026lt;= 10\r)\rHWERE rn \u0026gt;=6\r ","id":158,"section":"posts","summary":"1.Oracle 12c R1 (12.1)支持limit语句 从Oracle 12c R1 (12.1)版本开始，oracle开始支持limit语句，但是跟熟悉的limit(1,","tags":["oracle"],"title":"Oracle limit 问题","uri":"https://www.mingaccount.com/2016/01/oracle-limit/","year":"2016"},{"content":"项目经历  1. 交互式探索项目  2015/12 - 2016/12 交互式探索项目\n项目简介   数据挖掘项目，覆盖一个从未加工数据到意向图表的完整流程  技术栈   Struts2 + Spring + iBatis Oracle、Mysql、Gbase  工作内容   基于AOP的敏感操作日志，例如登录，数据导出，数据源创建和删除，和数据脱敏等操作 系统漏洞处理，诸如文件上传漏洞，sql注入漏洞，struts2漏洞 省市地区特有功能开发，多版本维护，svn完整迁移到git 多数据源配置，按业务分库分表 现场功能维护，基于java assist和java agent的零侵入日志打印、数据统计、和参数调整等等。  问题难点   代码老，维护人员更换频繁，注释不完整  个人简介 我阅读的书籍：《大话设计模式》、《深入分析Java Web技术内幕》、《设计模式》、《重构》等书籍 我的技术博客：https://www.cnblogs.com/wanshiming/ 项目经验： 工作经历： 教育背景： 专业技能： 1.熟悉设计模式，反射机制，了解java新特性，有良好的面对对象编程思想。 2.熟悉spring框架，并了解其运行机制。 3.mvc架构熟悉，并掌握spring mvc，了解strust2 4.orm框架熟悉ibatis ，并明白其运行机制，了解jpa 5.spring boot\n工作经历\t2015.12-2018.9 北京东方国信科技股份有限公司\tJAVA程序开发 \t客户细分项目\tJava7，SpringMVC+Spring+iBatis，MySql，Jenkins+Docker，ANT，GIT \t探索式数据分析应用平台（EVAP）\tJava7，Struts2+Spring+iBatis，Oracle，ANT，SVN \tBitwd交互项目（EVAP项目重构）\tJava8，Spring Boot+JPA，MySql，Jenkins+Docker，MAVEN，GIT\n项目经验\n\t静态化后端和前端JSP开发 1）由于客户细分项目需要集成到一个大型平台当中，各个项目原本的用户信息不同，因此用户部门信息统一从Nginx缓存获取，并剔除前台页面的用户信息。 2）项目将公共数据集缓存在Nginx中，各项目处理公共数据，直接读取缓存，加快页面响应速度。\n\t数据库读写分离和列式储存 1）由于用户增删改业务字段频繁，并且主要业务查询的目标数据量大，因此利用数据库的主从热备功能进行了读写分离。 2）随着用户业务信息的不断扩展，SQL越来越复杂，响应变慢，所以继续提取了业务主要查询信息到列式数据库。\n\t去数据库依赖，由于客户细分项目部署在多个省市的服务器，数据库服务器地址不同，根据现场情况，数据库产品也不同，独立的数据库连接模块、规范化的SQL以及抽象工厂架构的SQL模块，大大的提高了开发效率。\n\t完整规范的接口文档撰写，因为是多个部门的协作开发，完整规范的接口说明文档就尤其重要。\n\tQuartz定时并发导出excel功能模块开发，excel生成基于poi开源组件。\n\t项目重构准备，有效代码通过门面模式集中整合，提取封装为jar包。\n\t项目重构经验，自学设计模式相关知识，了解Java8新特性，使用函数式编程，基于Spring Boot + JPA框架完成开发。\n","id":159,"section":"posts","summary":"项目经历 1. 交互式探索项目 2015/12 - 2016/12 交互式探索项目 项目简介 数据挖掘项目，覆盖一个从未加工数据到意向图表的完整流程 技术栈 Struts2 + Spring + iBatis Oracle、My","tags":null,"title":"","uri":"https://www.mingaccount.com/1/01/resume/","year":"0001"}],"tags":[{"title":"db2","uri":"https://www.mingaccount.com/tags/db2/"},{"title":"design pattern","uri":"https://www.mingaccount.com/tags/design-pattern/"},{"title":"druid","uri":"https://www.mingaccount.com/tags/druid/"},{"title":"ehcache","uri":"https://www.mingaccount.com/tags/ehcache/"},{"title":"git","uri":"https://www.mingaccount.com/tags/git/"},{"title":"gradle","uri":"https://www.mingaccount.com/tags/gradle/"},{"title":"h2","uri":"https://www.mingaccount.com/tags/h2/"},{"title":"hadoop","uri":"https://www.mingaccount.com/tags/hadoop/"},{"title":"hive","uri":"https://www.mingaccount.com/tags/hive/"},{"title":"jackson","uri":"https://www.mingaccount.com/tags/jackson/"},{"title":"java","uri":"https://www.mingaccount.com/tags/java/"},{"title":"jenkins","uri":"https://www.mingaccount.com/tags/jenkins/"},{"title":"jooq","uri":"https://www.mingaccount.com/tags/jooq/"},{"title":"junit4","uri":"https://www.mingaccount.com/tags/junit4/"},{"title":"junit5","uri":"https://www.mingaccount.com/tags/junit5/"},{"title":"linux","uri":"https://www.mingaccount.com/tags/linux/"},{"title":"lombok","uri":"https://www.mingaccount.com/tags/lombok/"},{"title":"markdown","uri":"https://www.mingaccount.com/tags/markdown/"},{"title":"maven","uri":"https://www.mingaccount.com/tags/maven/"},{"title":"mockmvc","uri":"https://www.mingaccount.com/tags/mockmvc/"},{"title":"mybatis","uri":"https://www.mingaccount.com/tags/mybatis/"},{"title":"mysql","uri":"https://www.mingaccount.com/tags/mysql/"},{"title":"nexus","uri":"https://www.mingaccount.com/tags/nexus/"},{"title":"npm","uri":"https://www.mingaccount.com/tags/npm/"},{"title":"oracle","uri":"https://www.mingaccount.com/tags/oracle/"},{"title":"postgresql","uri":"https://www.mingaccount.com/tags/postgresql/"},{"title":"protocol","uri":"https://www.mingaccount.com/tags/protocol/"},{"title":"python","uri":"https://www.mingaccount.com/tags/python/"},{"title":"redis","uri":"https://www.mingaccount.com/tags/redis/"},{"title":"regexp","uri":"https://www.mingaccount.com/tags/regexp/"},{"title":"scala","uri":"https://www.mingaccount.com/tags/scala/"},{"title":"spark","uri":"https://www.mingaccount.com/tags/spark/"},{"title":"spring","uri":"https://www.mingaccount.com/tags/spring/"},{"title":"testng","uri":"https://www.mingaccount.com/tags/testng/"},{"title":"unit-test","uri":"https://www.mingaccount.com/tags/unit-test/"},{"title":"website build","uri":"https://www.mingaccount.com/tags/website-build/"},{"title":"windows","uri":"https://www.mingaccount.com/tags/windows/"}]}