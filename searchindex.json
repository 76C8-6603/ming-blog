{"categories":[],"posts":[{"content":"WSL ubuntu20.04官方问题，为了稳定推荐18.04\n参考官方说明\n","id":0,"section":"posts","summary":"WSL ubuntu20.04官方问题，为了稳定推荐18.04 参考官方说明","tags":["windows"],"title":"WIN10 UBUNTU 异常：sleep: cannot read realtime clock: Invalid argument","uri":"http://www.mingaccount.com/2020/08/win10/","year":"2020"},{"content":"当提取字段为Date类型时，extract只能读取年月日，提取时分秒会报错\n要提取年月日，需要将Date类型转为timestamp\n","id":1,"section":"posts","summary":"当提取字段为Date类型时，extract只能读取年月日，提取时分秒会报错 要提取年月日，需要将Date类型转为timestamp","tags":["java"],"title":"Oracle extract函数提取时分秒的问题","uri":"http://www.mingaccount.com/2020/07/oracleextract%E5%87%BD%E6%95%B0%E6%8F%90%E5%8F%96%E6%97%B6%E5%88%86%E7%A7%92%E7%9A%84%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"Setting中有个选项setRenderSchema(true)，但是这种只适用于表是由JOOQ代码生成器生成的表对象。\n如果是自己声明的表对象（DSL.table()），想要让JOOQ在渲染时自己加上schema，稍微麻烦一点。\n这里假设需要加上的默认schema为：liuneng\nSettings settings = new Settings()\r.withRenderMapping(new RenderMapping()\r.withSchemata(new MappedSchema().withInput(\u0026quot;\u0026quot;).withOutput(\u0026quot;liuneng\u0026quot;)));\r 这样设置后,JOOQ在渲染表名的时候会把未设置schema的表，统一加上liuneng，但是还有一个前提，你的表必须要按照以下方式声明：\nDSL.table(name(\u0026quot;my_table\u0026quot;))\r ","id":2,"section":"posts","summary":"Setting中有个选项setRenderSchema(true)，但是这种只适用于表是由JOOQ代码生成器生成的表对象。 如果是自己声明的表","tags":["jooq"],"title":"JOOQ默认schema","uri":"http://www.mingaccount.com/2020/07/jooq%E9%BB%98%E8%AE%A4schema/","year":"2020"},{"content":"需提前设置BreakAfterAcquireFailure为true，不然连接重试次数限制无效 还需要设置FailFast为true，不然原始线程会一直阻塞\ndataSource.setBreakAfterAcquireFailure(true);\rdataSource.setFailFast(true);\rdataSource.setConnectionErrorRetryAttempts(3);\r ","id":3,"section":"posts","summary":"需提前设置BreakAfterAcquireFailure为true，不然连接重试次数限制无效 还需要设置FailFast为true，不然原始","tags":["druid"],"title":"Druid数据库连接失败，无限尝试问题","uri":"http://www.mingaccount.com/2020/06/druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E6%97%A0%E9%99%90%E5%B0%9D%E8%AF%95%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"原因是hive版本太老，不能识别integer，只能识别int\n官方说明\n生效版本是0.8.0\n","id":4,"section":"posts","summary":"原因是hive版本太老，不能识别integer，只能识别int 官方说明 生效版本是0.8.0","tags":["hive"],"title":"hive cast( as integer)报错 in primitive type specification","uri":"http://www.mingaccount.com/2020/05/hivecast%E6%8A%A5%E9%94%99/","year":"2020"},{"content":"用spark写csv的时候碰见一个问题，join后未匹配的单元应该是null，但是spark写出来全部都为\u0026rdquo;\u0026rdquo;\nF23338994668,F23338994669,F23338995220\r12,1,1\r1,7,\u0026quot;\u0026quot;\r13,1,1\r6,1,1\r16,1,1\r 在之后hive加载的时候，由于该列是数字类型，空字符无法匹配数字字段类型，导致有空串的整行都展示为null\nF23338994668,F23338994669,F23338995220\r12,1,1\r,,,\r13,1,1\r6,1,1\r16,1,1\r 追踪代码发现在未写入之前，sql没有问题，也没有执行na().fill()操作，但在write过后，null就变成了\u0026rdquo;\u0026rdquo;\n解决办法，在sparkDF.write之前追加配置.config(\u0026ldquo;emptyValue\u0026rdquo;,\u0026quot;\u0026quot;)即可\n","id":5,"section":"posts","summary":"用spark写csv的时候碰见一个问题，join后未匹配的单元应该是null，但是spark写出来全部都为\u0026rdquo;\u0026rdquo; F23338994668,F23338994669,F23338995220 12,1,1 1,7,\u0026quot;\u0026quot;","tags":["spark"],"title":"spark dataset写csv的时候将null值写为空字符串","uri":"http://www.mingaccount.com/2020/05/spark%E5%86%99csv%E6%8A%8Anull%E5%80%BC%E5%86%99%E4%B8%BA%E7%A9%BA%E4%B8%B2/","year":"2020"},{"content":"spark decimal列进行计算时，可能丢失精度\n在默认情况下[spark.sql.decimalOperations.allowPrecisionLoss]配置为true，会导致精度丢失的列展示为null\n一般情况下，修改spark配置即可解决：\nspark.sql.decimalOperations.allowPrecisionLoss=false\r 参考官方说明\n但是在如下例子中还会出现结果列为null的情况：\nIF(column1 IS NULL,0,column1) - IF(column2 IS NULL,0,column2)\r 去掉IF判断，就能正常获取结果\n","id":6,"section":"posts","summary":"spark decimal列进行计算时，可能丢失精度 在默认情况下[spark.sql.decimalOperations.allowPrecision","tags":["spark"],"title":"spark精度丢失，导致列查询为null的解决办法","uri":"http://www.mingaccount.com/2020/04/spark%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/","year":"2020"},{"content":"实现方式是自定义触发器\ndrop trigger if exists trigger_name;\rdelimiter |\rCREATE TRIGGER trigger_name BEFORE INSERT ON table_name\rFOR EACH ROW BEGIN\rdeclare original_column_name varchar(255);\rdeclare column_name_counter int;\rset original_column_name = new.column_name;\rset column_name_counter = 1;\rwhile exists (select true from pc_volumes where name = new.column_name) do\rset new.column_name = concat(original_column_name, '-', column_name_counter);\rset column_name_counter = column_name_counter + 1;\rend while;\rEND;\r|\rdelimiter ;\r ","id":7,"section":"posts","summary":"实现方式是自定义触发器 drop trigger if exists trigger_name; delimiter | CREATE TRIGGER trigger_name BEFORE INSERT ON table_name FOR EACH ROW BEGIN declare original_column_name varchar(255); declare column_name_counter int; set original_column_name = new.column_name; set column_name_counter = 1; while exists (select true from pc_volumes where name = new.column_name) do set new.column_name = concat(original_column_name, '-', column_name_counter); set column_name_counter = column_name_counter + 1; end while; END; |","tags":["mysql"],"title":"Mysql插入重复值追加后缀","uri":"http://www.mingaccount.com/2020/04/mysql%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E5%80%BC%E8%BF%BD%E5%8A%A0%E5%90%8E%E7%BC%80/","year":"2020"},{"content":"一、打开sbt安装路径找到conf\\sbtconfig.txt，在文件末尾添加仓库文件地址 -Dsbt.repository.config=%SBT_HOME/sbt/conf/repository.properties\r 二、在对应目录创建repository.properties，并添加如下内容 [repositories]\rlocal\raliyun-nexus: http://maven.aliyun.com/nexus/content/groups/public/ ibiblio-maven: http://maven.ibiblio.org/maven2/\rtypesafe-ivy: https://dl.bintray.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]\ruk-repository: http://uk.maven.org/maven2/\rjboss-repository: http://repository.jboss.org/nexus/content/groups/public/\rtypesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly\rsonatype-oss-releases\rmaven-central\rsonatype-oss-snapshots\r 三、同时在~/.sbt(windows在“用户/.sbt”)下创建文件repositories，并添加上面的内容 ","id":8,"section":"posts","summary":"一、打开sbt安装路径找到conf\\sbtconfig.txt，在文件末尾添加仓库文件地址 -Dsbt.repository.config=%SBT_HOME/sbt/conf/repository.properties 二、在对应目录创建repository.prop","tags":["scala"],"title":"SBT仓库镜像配置","uri":"http://www.mingaccount.com/2020/02/sbt%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/","year":"2020"},{"content":"这里主要参照NameCheap，其他域名服务商大同小异 host:\n@代表在浏览器输入yourdomain.tld想跳转到的地址\nwww代表在浏览器输入www.yourdomain.tld想跳转到的地址\n跳转到指定IP    type host target     A Record @ 11.22.33.44   A Record www 11.22.33.44    跳转到指定域名    type host target     CNAME Record @ [name].github.io   CNAME Record www [name].github.io    NameCheap的详细说明\n","id":9,"section":"posts","summary":"这里主要参照NameCheap，其他域名服务商大同小异 host: @代表在浏览器输入yourdomain.tld想跳转到的地址 www代表在浏览器输入w","tags":["website build"],"title":"怎么给自己的域名指定IP","uri":"http://www.mingaccount.com/2020/02/%E6%80%8E%E4%B9%88%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%AE%9Aip/","year":"2020"},{"content":"select\ra.date\r, a.measure\r, case\rwhen b.measure is null\ror b.measure=0\rthen null\relse concat( cast( cast((if(a.measure is null, 0, a.measure)-if(b.measure is null,0,b.measure))*100/b.measure as decimal(10,2))　as string)　,'%')\rend as ratio_column\rfrom\rtest_table a\rleft join\rtest_table b\ron\r(\rto_date(from_unixtime(unix_timestamp(concat(a.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')) = add_months(to_date(from_unixtime(unix_timestamp(concat(b.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')),+1)\rand 1 = 1\r)\r 提醒： 　1. 第一个join条件的\u0026rsquo;yyyyMM\u0026rsquo;可以根据字段date的具体格式改变，\u0026lsquo;yyyy-MM-dd HH:mm:ss\u0026rsquo;不需要改变\n　2. 该同环比没有任何分组和汇总，所以一旦date字段有重复值，很容易出现笛卡尔积，解决方案是确保join条件能够确定一条数据在表中的唯一性\n","id":10,"section":"posts","summary":"select a.date , a.measure , case when b.measure is null or b.measure=0 then null else concat( cast( cast((if(a.measure is null, 0, a.measure)-if(b.measure is null,0,b.measure))*100/b.measure as decimal(10,2)) as string) ,'%') end as ratio_column from test_table a left join test_table b on ( to_date(from_unixtime(unix_timestamp(concat(a.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')) = add_months(to_date(from_unixtime(unix_timestamp(concat(b.date,''),'yyyyMM'),'yyyy-MM-dd HH:mm:ss')),+1) and 1 = 1 ) 提醒： 1. 第一个join条件的\u0026rsqu","tags":["hive"],"title":"Hive同环比实现","uri":"http://www.mingaccount.com/2020/02/hive%E5%90%8C%E7%8E%AF%E6%AF%94%E5%AE%9E%E7%8E%B0/","year":"2020"},{"content":"hive的日期格式可由String类型保存，只能识别两种格式yyyy-MM-dd和yyyy-MM-dd HH:mm:ss。\n只要将日期转为这两种格式hive就能识别为日期。也就是不管to_date、to_char都是将日期格式化为字符串。\nunix_timestamp(日期字符串,日期格式) 返回日期时间戳\nfrom_unixtime(日期时间戳,日期格式) 返回日期字符串\nto_date，to_char都用的一个公式，唯一不同的是to_date的目标日期格式是写死的\n1.to_date\nfrom_unixtime(unix_timestamp(来源日期，来源日期格式),\u0026lsquo;yyyy-MM-dd HH:mm:ss\u0026rsquo;)\n例：\nfrom_unixtime(unix_timestamp('2020/02/03 17:35:00','yyyy/MM/dd HH-mm-ss'),'yyyy-MM-dd HH:mm:ss')\r 2.to_char\nfrom_unixtime(unix_timestamp(来源日期，来源日期格式),目标日期格式)\n例：\nfrom_unixtime(unix_timestamp('2020/02/03 17:35:00','yyyy/MM/dd HH-mm-ss'),'yyyy-MM-dd HH:mm:ss')\r ","id":11,"section":"posts","summary":"hive的日期格式可由String类型保存，只能识别两种格式yyyy-MM-dd和yyyy-MM-dd HH:mm:ss。 只要将日期转为这两种","tags":["hive"],"title":"Hive中的to_date和to_char","uri":"http://www.mingaccount.com/2020/02/hive%E4%B8%AD%E7%9A%84to_date%E5%92%8Cto_char/","year":"2020"},{"content":"String.format(\u0026quot;(?\u0026lt;![\\\\u4E00-\\\\u9FA5aa-zA-Z0-9_])%s(?![\\\\u4E00-\\\\u9FA5a-zA-Z0-9_])\u0026quot;,\u0026quot;独立字符不与任何其他字符相连\u0026quot;)\r ","id":12,"section":"posts","summary":"String.format(\u0026quot;(?\u0026lt;![\\\\u4E00-\\\\u9FA5aa-zA-Z0-9_])%s(?![\\\\u4E00-","tags":["regexp"],"title":"像IDEA一样匹配一个WORDS","uri":"http://www.mingaccount.com/2020/01/%E5%83%8Fidea%E4%B8%80%E6%A0%B7%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AAwords/","year":"2020"},{"content":"根据版本不同，官方文档有详细说明\n使用参照文档\n查询结果对照文档\n","id":13,"section":"posts","summary":"根据版本不同，官方文档有详细说明 使用参照文档 查询结果对照文档","tags":["mysql"],"title":"Mysql Explain用法详解","uri":"http://www.mingaccount.com/2019/12/mysqlexplain%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","year":"2019"},{"content":"切记！！！！！\n没有比官网教程更详细，更靠谱的教程！！！！！\n其他的基本都是官网的翻译，但是官网的教程是实时更新的，要是不注意版本，坑根本就踩不完！！！\n附上官网部署教程：\nhttps://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html\n$\\color{#DAA520}{单节点的安装只需要关注两个点：}$\n1.linux安装的java版本，各个版本的hadoop对java版本是要求的，具体信息如下： https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions\n　2.在多次执行hdfs dfs -format后，namenode和datanode的clusterid可能对不上，在format之前需要删除tmp/hadoop-hadoop目录\n","id":14,"section":"posts","summary":"切记！！！！！ 没有比官网教程更详细，更靠谱的教程！！！！！ 其他的基本都是官网的翻译，但是官网的教程是实时更新的，要是不注意版本，坑根本就踩不","tags":["hadoop"],"title":"Hadoop安装踩坑","uri":"http://www.mingaccount.com/2019/12/hadoop%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91/","year":"2019"},{"content":"首先确保安装SSH server：\nsudo apt-get install openssh-server\r 启动SSH server:\nsudo service ssh start\r#检查ssh是否正常启动\rssh localhost\r 安装后，可以使用如下命令登陆本机：\nssh localhost\r 此时会有SSH首次登陆提示，输入 yes 。然后按提示输入密码 hadoop，这样就登陆到本机了。\n但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆。\n有以下两种实现方法：\n　一、首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：\n# 退出刚才的 ssh localhost\rexit\r# 若没有该目录，请先执行一次ssh localhost\rcd ~/.ssh/\r# 会有提示，都按回车就可\rssh-keygen -t rsa\r# 加入授权\rcat ./id_rsa.pub \u0026gt;\u0026gt; ./authorized_keys  　二、　#1\rssh localhost\r #2\rssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa\rcat ~/.ssh/id_dsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys\r #3\rssh localhost\r #4 要保证：~/.ssh需要是700权限 authorized_keys需要是644权限\rchmod 700 ~/.ssh\rchmod 644 ~/.ssh/authorized_keys\r #5 此时进入到~/.ssh目录下，会看到多了一个文件know_hosts文件\r #6 退出exit，重新打开shell\r #7.最后ssh localhost验证一下\r 　","id":15,"section":"posts","summary":"首先确保安装SSH server： sudo apt-get install openssh-server 启动SSH server: sudo service ssh start #检查ssh是否正常启动 ssh localhost 安装后，可以使用如下命令登陆本机： ssh localhost 此时会有SSH","tags":["hadoop"],"title":"Hadoop ssh localhost 无密码登录","uri":"http://www.mingaccount.com/2019/12/hadoopsshlocalhost%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/","year":"2019"},{"content":"作者：孤独烟\n链接：https://zhuanlan.zhihu.com/p/73260510\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nOK，具体有下面这些问题\n1.为什么一定要设一个主键？\n2.你们主键是用自增还是UUID?\n3.主键为什么不推荐有业务含义?\n4.表示枚举的字段为什么不用enum类型？\n5.货币字段用什么类型? 6.时间字段用什么类型?\n7.为什么不直接存储图片、音频、视频等大容量内容?\n8.字段为什么要定义为NOT NULL?\n其实上面这些问题，我最早想法是，每个问题都可以啰嗦出一篇文章。后来由于良心发现，烟哥就决定用一篇文章将这些问题都讲明白。 当然，我给的回答可能并非标准答案，毕竟是自己的一些工作总结。各位读者有更好的回答，也欢迎交流！\n这里我要说一下，我用mysql只用过innodb存储引擎，其他的引擎真没用过。因此我的回答，都是基于innodb存储引擎中的。\n正文 问题1:为什么一定要设一个主键？ 回答:因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，在有些情况下，就能显式的用上主键索引，提高查询效率！\n问题2:主键是用自增还是UUID? 回答:肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。\n上面那句话看不懂没事，大白话一句就是:用自增插入性能好！\n另外，附一个测试表给你们，表名带uuid的就是用uuid作为主键。大家看一下就知道性能差距了:\n如上图所示，当主键是UUID的时候，插入时间更长，而且占用空间更大！\nps：这个问题，你要是能把UUID讲出合理的理由也行。\n问题3:主键为什么不推荐有业务含义? 回答:有如下两个原因\n 因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。 带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。  问题4:表示枚举的字段为什么不用enum类型？ 回答:在工作中表示枚举的字段，一般用tinyint类型。\n那为什么不用enum类型呢？下面两个原因\n(1)ENUM类型的ORDER BY操作效率低，需要额外操作\n(2)如果枚举值是数值，有陷阱 举个例子，表结构如下\nCREATE TABLE test (foobar ENUM('0', '1', '2'));\r 此时，你执行语句\nmysql\u0026gt; INSERT INTO test VALUES (1);\r 查询出的结果为\n就产生了一个坑爹的结果。 插入语句应该像下面这么写，插入的才是1\nmysql\u0026gt; INSERT INTO test VALUES (`1`);\r 问题5:货币字段用什么类型? 回答:如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。\n千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。 打个比方，你建一个列如下\nCREATE TABLE `t` (\r`price` float(10,2) DEFAULT NULL,\r) ENGINE=InnoDB DEFAULT CHARSET=utf8\r 然后insert给price列一个数据为1234567.23，你会发现显示出来的数据变为1234567.25，精度失准！\n问题6:时间字段用什么类型? 回答:此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！\n(1)varchar，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为2013111的数据，请问这是代表2013年1月11日，还是2013年11月1日？ 其次，做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！\n(2)timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。 但是它有一个优势，timestamp类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区\nSET TIME_ZONE = \u0026ldquo;america/new_york\u0026rdquo;; 你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！\n(3)datetime，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！\n(4)bigint，也是8个字节，自己维护一个时间戳，表示范围比timestamp大多了，就是要自己维护，不大方便。\n问题7:为什么不直接存储图片、音频、视频等大容量内容? 回答:我们在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是text和blob类型。但是，我们在生产中，基本不用这两个类型！\n主要原因有如下两点\n(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢\n(2)binlog内容太多。因为你数据内容比较大，就会造成binlog内容比较多。大家也知道，主从同步是靠binlog进行同步，binlog太大了，就会导致主从同步效率问题！\n因此，不推荐使用text和blob类型！\n问题8:字段为什么要定义为NOT NULL? 回答:OK，这问题从两个角度来答\n(1)索引性能不好\nMysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。 —— 出自《高性能mysql第二版》\r (2)查询会出现一些不可预料的结果 这里举一个例子，大家就懂了。假设，表结构如下\ncreate table table_2 (\r`id` INT (11) NOT NULL,\rname varchar(20)\r)\r 表数据是这样的\n你执行语句\nselect count(name) from table_2;\r 你会发现结果为非NULL的总数\n类似的查询问题，其实有很多，不一一列举。 记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.\n","id":16,"section":"posts","summary":"作者：孤独烟 链接：https://zhuanlan.zhihu.com/p/73260510 来源：知乎 著作权归作者所有。商业转载请联系作者获","tags":["mysql"],"title":"[转]Mysql表设计注意事项","uri":"http://www.mingaccount.com/2019/10/mysql%E8%A1%A8%E8%AE%BE%E8%AE%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","year":"2019"},{"content":"转自公众号“孤独烟”\n引言 我们先来讲一个段子\n面试官：“有并发的经验没？” 应聘者：“有一点。” 面试官：“那你们为了处理并发，做了哪些优化？” 应聘者：“前后端分离啊，限流啊，分库分表啊。。” 面试官:\u0026quot;谈谈分库分表吧？\u0026quot; 应聘者：“bala。bala。bala。。” 面试官心理活动:这个仁兄讲的怎么这么像网上的博客抄的，容我再问问。\r面试官:“你们分库分表后，如何部署上线的？” 应聘者：“这！！！！！！”\r 不要惊讶，我写这篇文章前，我特意去网上看了下分库分表的文章，很神奇的是，都在讲怎么进行分库分表，却不说分完以后，怎么部署上线的。这样在面试的时候就比较尴尬了。\n你们自己摸着良心想一下，如果你真的做过分库分表，你会不知道如何部署的么？因此我们来学习一下如何部署吧。\nps:我发现一个很神奇的现象。因为很多公司用的技术比较low，那么一些求职者为了提高自己的竞争力，就会将一些高大上的技术写进自己的low项目中。然后呢，他出去面试害怕碰到从这个公司出来的人，毕竟从这个公司出来的人，一定知道自己以前公司的项目情形。因此为了圆谎，他就会说：“他们从事的是这个公司的老项目改造工作，用了很多新技术进去！”\n那么，请你好好思考一下，你们的老系统是如何平滑升级为新系统的！\n如何部署 停机部署法 大致思路就是，挂一个公告，半夜停机升级，然后半夜把服务停了，跑数据迁移程序，进行数据迁移。\n步骤如下:\n(1)出一个公告，比如“今晚00:00～6:00进行停机维护，暂停服务”\n(2)写一个迁移程序，读db-old数据库，通过中间件写入新库db-new1和db-new2，具体如下图所示\n(3)校验迁移前后一致性，没问题就切该部分业务到新库。\n顺便科普一下，这个中间件。现在流行的分库分表的中间件有两种，一种是proxy形式的，例如mycat，是需要额外部署一台服务器的。还有一种是client形式的，例如当当出的Sharding-JDBC，就是一个jar包，使用起来十分轻便。我个人偏向Sharding-JDBC，这种方式，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式。\n评价：\n大家不要觉得这种方法low，我其实一直觉得这种方法可靠性很强。而且我相信各位读者所在的公司一定不是什么很牛逼的互联网公司，如果你们的产品凌晨1点的用户活跃数还有超过1000的，你们握个爪！毕竟不是所有人都在什么电商公司的，大部分产品半夜都没啥流量。所以此方案，并非没有可取之处。\n但是此方案有一个缺点，累！不止身体累，心也累！你想想看，本来定六点结束，你五点把数据库迁移好，但是不知怎么滴，程序切新库就是有点问题。于是，眼瞅着天就要亮了，赶紧把数据库切回老库。第二个晚上继续这么干，简直是身心俱疲。\nps：这里教大家一些技巧啊，如果你真的没做过分库分表，又想吹一波，涨一下工资，建议答这个方案。因为这个方案比较low，low到没什么东西可以深挖的，所以答这个方案，比较靠谱。\n另外，如果面试官的问题是\n你们怎么进行分库分表的？ 这个问题问的很泛，所以回答这个问题建议自己主动把分表的策略，以及如何部署的方法讲出来。因为这么答，显得严谨一些。\n不过，很多面试官为了卖弄自己的技术，喜欢这么问\n分表有哪些策略啊？你们用哪种啊？ ok。。这个问题具体指向了分库分表的某个方向了，你不要主动答如何进行部署的。等面试官问你，你再答。如果面试官没问，在面试最后一个环节，面试官会让你问让几个问题。你就问\n你刚才刚好有提到分库分表的相关问题，我们当时部署的时候，先停机。然后半夜迁移数据，然后第二天将流量切到新库，这种方案太累，不知道贵公司有没有什么更好的方案？ 那么这种情况下，面试官会有两种回答。第一种，面试官硬着头皮随便扯。第二种，面试官真的做过，据实回答。记住，面试官怎么回答的不重要。重点的是，你这个问题出去，会给面试官一种错觉:\u0026ldquo;这个小伙子真的做过分库分表。\u0026rdquo;\n如果你担心进去了，真派你去做分库分表怎么办？OK，不要怕。我赌你试用期碰不到这个活。因为能进行分库分表，必定对业务非常熟。还在试用期的你，必定对业务不熟，如果领导给你这种活，我只能说他有一颗大心脏。\nok，指点到这里。面试本来就是一场斗智斗勇的过程，扯远了，回到我们的主题。\n双写部署法(一) 这个就是不停机部署法，这里我需要先引进两个概念:历史数据和增量数据。\n假设，我们是对一张叫做test_tb的表进行拆分，因为你要进行双写，系统里头和test_tb表有关的业务之前必定会加入一段双写代码，同时往老库和新库中写，然后进行部署，那么\n历史数据:在该次部署前，数据库表test_tb的有关数据，我们称之为历史数据。\n增量数据:在该次部署后，数据库表test_tb的新产生的数据，我们称之为增量数据。\n然后迁移流程如下\n(1)先计算你要迁移的那张表的max(主键)。在迁移过程中，只迁移db-old中test_tb表里，主键小等于该max(主键)的值，也就是所谓的历史数据。\n这里有特殊情况，如果你的表用的是uuid，没法求出max(主键)，那就以创建时间作为划分历史数据和增量数据的依据。如果你的表用的是uuid,又没有创建时间这个字段，我相信机智的你，一定有办法区分出历史数据和增量数据。\n(2)在代码中，与test_tb有关的业务，多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中，至于消息体如何组装，大家自行考虑。需要注意的是，只发写请求的sql，只发写请求的sql，只发写请求的sql。重要的事情说三遍！\n原因有二:\n(1)只有写请求的sql对恢复数据才有用。\n(2)系统中，绝大部分的业务需求是读请求，写请求比较少。\n注意了，在这个阶段，我们不消费消息队列里的数据。我们只发写请求，消息队列的消息堆积情况不会太严重！\n(3)系统上线。另外，写一段迁移程序，迁移db-old中test_tb表里，主键小于该max(主键)的数据，也就是所谓的历史数据。\n上面步骤(1)～步骤(3)的过程如下\n等到db-old中的历史数据迁移完毕，则开始迁移增量数据，也就是在消息队列里的数据。\n(4)将迁移程序下线，写一段订阅程序订阅消息队列中的数据\n(5)订阅程序将订阅到到数据，通过中间件写入新库\n(6)新老库一致性验证，去除代码中的双写代码，将涉及到test_tb表的读写操作，指向新库。\n上面步骤(4)～步骤(6)的过程如下\n这里大家可能会有一个问题，在步骤(1)～步骤(3),系统对历史数据进行操作，会造成不一致的问题么？\nOK，不会。这里我们对delete操作和update操作做分析，因为只有这两个操作才会造成历史数据变动，insert进去的数据都是属于增量数据。\n(1)对db-old中test_tb表的历史数据发出delete操作，数据还未删除，就被迁移程序给迁走了。此时delete操作在消息队列里还有记录，后期订阅程序订阅到该delete操作，可以进行删除。\n(2)对db-old中test_tb表的历史数据发出delete操作，数据已经删除，迁移程序迁不走该行数据。此时delete操作在消息队列里还有记录，后期订阅程序订阅到该delete操作，再执行一次delete，并不会对一致性有影响。\n对update的操作类似，不赘述。\n双写部署法(二) 上面的方法有一个硬伤，注意我有一句话\n(2)在代码中，与test_tb有关的业务，多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中，至于消息体如何组装，大家自行考虑。\n大家想一下，这么做，是不是造成了严重的代码入侵。将非业务代码嵌入业务代码，这么做，后期删代码的时候特别累。\n有没什么方法，可以避免这个问题的?\n有的，订阅binlog日志。关于binlog日志，我尽量下周写一篇《研发应该掌握的binlog知识》，这边我就介绍一下作用\n记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。binlog不会记录SELECT和SHOW这类操作，因为这类操作对据本身并没有修改。\n还记得我们在双写部署法(一)里介绍的，往消息队列里发的消息，都是写操作的消息。而binlog日志记录的也是写操作。所以订阅该日志，也能满足我们的需求。\n于是步骤如下\n(1)打开binlog日志，系统正常上线就好\n(2)还是写一个迁移程序，迁移历史数据。步骤和上面类似，不啰嗦了。\n步骤(1)~步骤(2)流程图如下\n(3)写一个订阅程序，订阅binlog(mysql中有canal。至于oracle中，大家就随缘自己写吧)。然后将订阅到的数据通过中间件，写入新库。\n(4)检验一致性，没问题就切库。\n步骤(3)~步骤(4)流程图如下\n怎么验数据一致性\n这里大概介绍一下吧，这篇的篇幅太长了，大家心里有底就行。\n(1)先验数量是否一致，因为验数量比较快。\n至于验具体的字段，有两种方法:\n(2.1)有一种方法是，只验关键性的几个字段是否一致。\n(2.2)还有一种是 ，一次取50条(不一定50条，具体自己定，我只是举例),然后像拼字符串一样，拼在一起。用md5进行加密，得到一串数值。新库一样如法炮制，也得到一串数值，比较两串数值是否一致。如果一致，继续比较下50条数据。如果发现不一致，用二分法确定不一致的数据在0-25条，还是26条-50条。以此类推，找出不一致的数据，进行记录即可。\nok，啰嗦完毕。\n","id":17,"section":"posts","summary":"转自公众号“孤独烟” 引言 我们先来讲一个段子 面试官：“有并发的经验没？” 应聘者：“有一点。” 面试官：“那你们为了处理并发，做了哪些优化？” 应聘","tags":["mysql"],"title":"[转]分库分表如何部署上线","uri":"http://www.mingaccount.com/2019/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/","year":"2019"},{"content":"转自微信公众号“孤独烟”\n简单版\n我们先明白一点，在mysql中，Int整型的范围如下\n我们以无符号整型为例，存储范围为0～4294967295，约43亿！我们先说一下，一旦自增id达到最大值，此时数据继续插入是会报一个主键冲突异常如下所示\n//Duplicate entry \u0026lsquo;4294967295\u0026rsquo; for key \u0026lsquo;PRIMARY\u0026rsquo;\n那解决方法也是很简单的，将Int类型改为BigInt类型，BigInt的范围如下\n就算你每秒10000条数据，跑100年，单表的数据也才\n10000243600365100=31536000000000\n这数字距离BigInt的上限还差的远，因此你将自增ID设为BigInt类型，你是不用考虑自增ID达到最大值这个问题！\n然而，如果你在面试中的回答如果是\n你:\u0026quot;简单啊，把自增主键的类型改为BigInt类型就好了！\u0026quot; 接下来，面试官可以问你一个更坑的问题！ 面试官:\u0026quot;你在线上怎么修改列的数据类型的？\u0026quot; 你:\u0026quot;what！我还是回等通知吧！\u0026quot;  怎么改\n目前业内在线修改表结构的方案，据我了解，一般有如下三种\n方式一:使用mysql5.6+提供的在线修改功能\n所谓的mysql自己提供的功能也就是mysql自己原生的语句，例如我们要修改原字段名称及类型。\nmysql\u0026gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;\r 那么，在mysql5.5这个版本之前，这是通过临时表拷贝的方式实现的。执行ALTER语句后，会新建一个带有新结构的临时表，将原表数据全部拷贝到临时表，然后Rename，完成创建操作。这个方式过程中，原表是可读的，不可写。\n在5.6+开始，mysql支持在线修改数据库表，在修改表的过程中，对绝大部分操作，原表可读，也可以写。\n那么，对于修改列的数据类型这种操作，原表还能写么？来来来，烟哥特意去官网找了mysql8.0版本的一张图\n如图所示，对于修改数据类型这种操作，是不支持并发的DML操作！也就是说，如果你直接使用ALTER这样的语句在线修改表数据结构，会导致这张表无法进行更新类操作(DELETE、UPDATE、DELETE)。\n因此，直接ALTER是不行滴！\n那我们只能用方式二或者方式三\n方式二:借助第三方工具 业内有一些第三方工具可以支持在线修改表结构，使用这些第三发工具，能够让你在执行ALTER操作的时候，表不会阻塞！比较出名的有两个\npt-online-schema-change，简称pt-osc\nGitHub正式宣布以开源的方式发布的工具，名为gh-ost\n以pt-osc为例，它的原理如下\n1、创建一个新的表，表结构为修改后的数据表，用于从源数据表向新表中导入数据。\n2、创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，用于数据拷贝结束后，执行这些操作，保证数据不会丢失。\n3、拷贝数据，从源数据表中拷贝数据到新表中。\n4、rename源数据表为old表，把新表rename为源表名，并将old表删除。\n5、删除触发器。\n然而这两个有意(KENG)思(B)的工具，居然。。。居然。。。唉！如果你的表里有触发器和外键，这两个工具是不行滴！\n如果真碰上了数据库里有触发器和外键，只能硬杠了，请看方式三\n方式三:改从库表结构，然后主从切换\n此法极其麻烦，需要专业水平的选手进行操作。因为我们的mysql架构一般是读写分离架构，从机是用来读的。我们直接在从库上进行表结构修改，不会阻塞从库的读操作。改完之后，进行主从切换即可。唯一需要注意的是，主从切换过程中可能会有数据丢失的情况！\n高深版\n其实答完上面的问题后，这篇文章差不多完了。但是，还记得我在开头说的么。这是一个很有意(KENG)思(B)的问题，为什么呢？\n假设啊，你的表里的自增字段为有符号的Int类型的，也就是说，你的字段范围为-2147483648到2147483648。\n一切又那么刚好，你的自增ID是从0开始的，也就是说，现在你的可以用的范围为0～2147483648。\n我们明确一点，表中真实的数据ID，肯定会出现一些意外，ID不一定是连续的。例如，有如下情形的出现\nCREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`), ) ENGINE=InnoDB;  执行下列SQL\ninsert into t values(null);\r// 插入的行是 (1)\rbegin;\rinsert into t values(null);\rrolllack;\rinsert into t values(null);\r// 插入的行是 (3)\r 因此，表中的真实id必然会出现断续的情况。\n好，那这会你的自增主键id的数据范围为0～2147483648，也就是单表21亿条数据！考虑id会出现断续，真实数据顶多18亿条吧。\n老哥，都单表18亿条了，还不分库分表？你一旦分库分表了，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。此时，我们就需要提供一 个全局唯一的ID号生成策略来支持分库分表的环境。\n因此在实际中，你根本等不到自增主键用完到情形！因此，你需要关注的文章应该是分库分表后如何部署上线\n所以，专业版回答如下\n面试官:\u0026quot;那自增主键达到最大值了，用完了怎么办？\u0026quot; 你:\u0026quot;这问题没遇到过，因为自增主键我们用int类型，一般达不到最大值，我们就分库分表了，所以不曾遇见过！\u0026quot;  ","id":18,"section":"posts","summary":"转自微信公众号“孤独烟” 简单版 我们先明白一点，在mysql中，Int整型的范围如下 我们以无符号整型为例，存储范围为0～4294967295，","tags":["mysql"],"title":"[转]自增主键用完了该怎么办","uri":"http://www.mingaccount.com/2019/10/%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%94%A8%E5%AE%8C%E4%BA%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/","year":"2019"},{"content":"\u0026ldquo;\\ufeff\u0026quot;是UTF-8 BOM编码的文件头，代表该文件按照什么字节顺序排序\n调用java的工具类 [UnicodeInputStream]即可解决这个问题\n//第二个参数targetEncoding为null时在getDetectedEncoding方法中会自动检测编码类型\rUnicodeInputStream unicodeInputStream = new UnicodeInputStream(inputStream, null);\rString enc = unicodeInputStream.getDetectedEncoding();\r//UnicodeInputStream内部由PushbackInputStream实现，跳过了无意义的文件头\rbufferedReader = new BufferedReader(new InputStreamReader(unicodeInputStream, enc));\r ","id":19,"section":"posts","summary":"\u0026ldquo;\\ufeff\u0026quot;是UTF-8 BOM编码的文件头，代表该文件按照什么字节顺序排序 调用java的工具类 [UnicodeIn","tags":["java"],"title":"Java读取文件内容文件头有﻿","uri":"http://www.mingaccount.com/2019/09/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/","year":"2019"},{"content":"原因是spark有两个文件头\n　[file://]代表本地\n　[hdfs://]代表hdfs路径\n如果路径没有文件头，spark会将该路径默认添加上\u0026quot;hdfs://\u0026rdquo;\n所以如果要访问本地csv文件，需要确保路径前面有\u0026quot;file://\u0026rdquo;\n//java代码，告诉spark这是本地文件\r\u0026quot;file:///\u0026quot; + url\r ","id":20,"section":"posts","summary":"原因是spark有两个文件头 [file://]代表本地 [hdfs://]代表hdfs路径 如果路径没有文件头，spark会将该路径默认添加上\u0026","tags":["spark"],"title":"SparkSession.read().csv()无法定位本地文件的问题","uri":"http://www.mingaccount.com/2019/09/sparksession.read.csv%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/","year":"2019"},{"content":"正确的调用方式为：\n@Component\rpublic class IconProperties {\r@Value(\u0026quot;${icon.url}\u0026quot;)\rprivate String url;\r}\rpublic class test{\r@Autowired\rIconProperties icon;\rpublic void test(){ String url = icon.url; }\r}\r 这里有三个需要注意的点：\n1.@Value赋值是否正确\n2.IconProperties是否有@Component，或者其他代表着该类交于Spring容器管理的注解\n3.在调用参数时通过@Autowired实例化类来调取\n","id":21,"section":"posts","summary":"正确的调用方式为： @Component public class IconProperties { @Value(\u0026quot;${icon.url}\u0026quot;) private String url; } public class test{ @Autowired IconProperties icon; public void test(){ String url = icon.url; } } 这里有三个需要注意的点： 1.@Value赋值是否正确 2.IconProp","tags":["spring"],"title":"Spring @Value注解无法正确赋值问题","uri":"http://www.mingaccount.com/2019/09/springvalue%E6%B3%A8%E8%A7%A3%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98/","year":"2019"},{"content":"基于Spring 的@Transactional注解，JOOQ可以非常简单的实现事务管理，详细参考JOOQ-Spring Transactional Management\n这里主要讨论如Spring注解不能介入的情况，或者事务范围小于方法\ncreate.transaction(configuration -\u0026gt; {\rAuthorRecord author =\rDSL.using(configuration)\r.insertInto(AUTHOR, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)\r.values(\u0026quot;George\u0026quot;, \u0026quot;Orwell\u0026quot;)\r.returning()\r.fetchOne();\rDSL.using(configuration)\r.insertInto(BOOK, BOOK.AUTHOR_ID, BOOK.TITLE)\r.values(author.getId(), \u0026quot;1984\u0026quot;)\r.values(author.getId(), \u0026quot;Animal Farm\u0026quot;)\r.execute();\r// Implicit commit executed here\r});\r 注意上面例子中的create虽然就是一个DslContext，但是你不能直接用于实现中，需要获取到他的configuration，重新构造一个\n 详细参考Jooq Transactional Management\n ","id":22,"section":"posts","summary":"基于Spring 的@Transactional注解，JOOQ可以非常简单的实现事务管理，详细参考JOOQ-Spring Transactional Management 这里主要讨论如Sp","tags":["jooq"],"title":"JOOQ事务处理","uri":"http://www.mingaccount.com/2019/08/jooq%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/","year":"2019"},{"content":"delimiter // #定义标识符为双斜杠\rdrop procedure if exists test; #如果存在test存储过程则删除\rcreate procedure test() #创建无参存储过程,名称为test\rbegin\rdeclare i int; #申明变量\rset i = 0; #变量赋值\rwhile i \u0026lt; 50 do #结束循环的条件: 当i大于10时跳出while循环\rINSERT INTO table_test\r( name\r)\rVALUES\r(\r'123'\r);\rSET i=i+1;　#循环条件不能丢\rend while; #结束while循环\rselect * from test; #查看test表数据\rend\r// #结束定义语句\rcall test(); #调用存储过程\r 以上是mysql循环语句，但我在执行的时候忘了加上SET 循环条件，导致SQL无限循环往表里插入数据\n这种情况光是关闭SQL窗口，是不管用的，SQL会在后台继续运行，需要找到对应线程，手动杀死\n#展示所有运行中的线程，线程信息里会展示对应SQL\rSHOW PROCESSLIST;\r#杀掉对应线程id\rKILL 123456;\r ","id":23,"section":"posts","summary":"delimiter // #定义标识符为双斜杠 drop procedure if exists test; #如果存在test存储过程则删除 create procedure test() #创建无参存储过程,名称为test begin declare i int; #申明变量 set i = 0; #变量赋","tags":["mysql"],"title":"Mysql循环语句，死循环解决办法","uri":"http://www.mingaccount.com/2019/08/mysql%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E6%AD%BB%E5%BE%AA%E7%8E%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","year":"2019"},{"content":"问题 最近项目小组在重新规划工程的业务缓存，其中涉及到部分代码重构，过程中发现有些工具类中的静态方法需要依赖别的对象实例（该实例已配置在xml成Spring bean，非静态可以用@Autowired加载正常使用），而我们知道，类加载后静态成员是在内存的共享区，静态方法里面的变量必然要使用静态成员变量，这就有了如下代码：\n@Component\rpublic class TestClass {\r@Autowired\rprivate static AutowiredTypeComponent component;\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 编译正常，但运行时报java.lang.NullPointerException: null异常，显然在调用testMethod()方法时，component变量还没被初始化，报NPE。\n原因 所以，在Springframework里，我们是不能@Autowired一个静态变量，使之成为一个Spring bean的。为什么？其实很简单，因为当类加载器加载静态变量时，Spring上下文尚未加载。所以类加载器不会在bean中正确注入静态类，并且会失败。\n解决方案 方式一 将@Autowired 注解到类的构造函数上。很好理解，Spring扫描到AutowiredTypeComponent的bean，然后赋给静态变量component。示例如下：\n@Component\rpublic class TestClass {\rprivate static AutowiredTypeComponent component;\r@Autowired\rpublic TestClass(AutowiredTypeComponent component) {\rTestClass.component = component;\r}\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 方式二 给静态组件加setter方法，并在这个方法上加上@Autowired。Spring能扫描到AutowiredTypeComponent的bean，然后通过setter方法注入。示例如下：\n@Component\rpublic class TestClass {\rprivate static AutowiredTypeComponent component;\r@Autowired\rpublic void setComponent(AutowiredTypeComponent component){\rTestClass.component = component;\r}\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 方式三 定义一个静态组件，定义一个非静态组件并加上@Autowired注解，再定义一个初始化组件的方法并加上@PostConstruct注解。这个注解是JavaEE引入的，作用于servlet生命周期的注解，你只需要知道，用它注解的方法在构造函数之后就会被调用。示例如下：\n@Component\rpublic class TestClass {\rprivate static AutowiredTypeComponent component;\r@Autowired\rprivate AutowiredTypeComponent autowiredComponent;\r@PostConstruct\rprivate void beforeInit() {\rcomponent = this.autowiredComponent;\r}\r// 调用静态组件的方法\rpublic static void testMethod() {\rcomponent.callTestMethod();\r}\r}\r 方式四 直接用Spring框架工具类获取bean，定义成局部变量使用。但有弊端：如果该类中有多个静态方法多次用到这个组件则每次都要这样获取，个人不推荐这种方式。示例如下：\npublic class TestClass {\r// 调用静态组件的方法\rpublic static void testMethod() {\rAutowiredTypeComponent component = SpringApplicationContextUtil.getBean(\u0026quot;component\u0026quot;);\rcomponent.callTestMethod();\r}\r}\r 原文：https://blog.csdn.net/RogueFist/article/details/79575665\n","id":24,"section":"posts","summary":"问题 最近项目小组在重新规划工程的业务缓存，其中涉及到部分代码重构，过程中发现有些工具类中的静态方法需要依赖别的对象实例（该实例已配置在xml","tags":["spring"],"title":"[转]Spring中使用@Autowired注解静态实例对象","uri":"http://www.mingaccount.com/2019/07/spring%E4%B8%AD%E4%BD%BF%E7%94%A8autowired%E6%B3%A8%E8%A7%A3%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1/","year":"2019"},{"content":"1.数据库url后追加\n\u0026amp;serverTimezone=Asia/Shanghai\r 2.修改数据库默认时区\nshow variables like \u0026quot;%time_zone%\u0026quot;;#查询当前时区\rset global time_zone = '+8:00'; #修改mysql全局时区为北京时间，即我们所在的东8区\rset time_zone = '+8:00'; #修改当前会话时区\rflush privileges; #立即生效\r ","id":25,"section":"posts","summary":"1.数据库url后追加 \u0026amp;serverTimezone=Asia/Shanghai 2.修改数据库默认时区 show variables like \u0026quot;%time_zone%\u0026quot;;#查询当前时区 set global time_zone = '+8:00'; #修改mysql","tags":["mysql"],"title":"Mysql 日期TIMESTAMP类型插入，与系统时间有差异","uri":"http://www.mingaccount.com/2019/07/mysql%E6%97%A5%E6%9C%9Ftimestamp%E7%B1%BB%E5%9E%8B%E6%8F%92%E5%85%A5%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%B7%AE%E5%BC%82/","year":"2019"},{"content":"public class EncryptUtils {\rprivate static final String SECRET_KEY_1 = \u0026quot;YIORGA4dBYp6y7u8\u0026quot;;\rprivate static final String SECRET_KEY_2 = \u0026quot;C6B8r5y7u7Uh37Sy\u0026quot;;\rprivate IvParameterSpec ivParameterSpec;\rprivate SecretKeySpec secretKeySpec;\rprivate Cipher cipher;\rpublic EncryptUtils() throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException {\rivParameterSpec = new IvParameterSpec(SECRET_KEY_1.getBytes(\u0026quot;UTF-8\u0026quot;));\rsecretKeySpec = new SecretKeySpec(SECRET_KEY_2.getBytes(\u0026quot;UTF-8\u0026quot;), \u0026quot;AES\u0026quot;);\rcipher = Cipher.getInstance(\u0026quot;AES/CBC/PKCS5PADDING\u0026quot;);\r}\r/**\r* Encrypt the string with this internal algorithm.\r*\r* @param toBeEncrypt string object to be encrypt.\r* @return returns encrypted string.\r* @throws NoSuchPaddingException\r* @throws NoSuchAlgorithmException\r* @throws InvalidAlgorithmParameterException\r* @throws InvalidKeyException\r* @throws BadPaddingException\r* @throws IllegalBlockSizeException\r*/\rpublic String encrypt(String toBeEncrypt) throws NoSuchPaddingException, NoSuchAlgorithmException,\rInvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\rcipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\rbyte[] encrypted = cipher.doFinal(toBeEncrypt.getBytes());\rreturn Base64.encodeBase64String(encrypted);\r}\r/**\r* Decrypt this string with the internal algorithm. The passed argument should be encrypted using\r* {@link #encrypt(String) encrypt} method of this class.\r*\r* @param encrypted encrypted string that was encrypted using {@link #encrypt(String) encrypt} method.\r* @return decrypted string.\r* @throws InvalidAlgorithmParameterException\r* @throws InvalidKeyException\r* @throws BadPaddingException\r* @throws IllegalBlockSizeException\r*/\rpublic String decrypt(String encrypted) throws InvalidAlgorithmParameterException, InvalidKeyException,\rBadPaddingException, IllegalBlockSizeException {\rcipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);\rbyte[] decryptedBytes = cipher.doFinal(Base64.decodeBase64(encrypted));\rreturn new String(decryptedBytes);\r}\r}\r ","id":26,"section":"posts","summary":"public class EncryptUtils { private static final String SECRET_KEY_1 = \u0026quot;YIORGA4dBYp6y7u8\u0026quot;; private static final String SECRET_KEY_2 = \u0026quot;C6B8r5y7u7Uh37Sy\u0026quot;; private IvParameterSpec ivParameterSpec; private SecretKeySpec secretKeySpec; private Cipher cipher; public EncryptUtils() throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException { ivParameterSpec = new IvParameterSpec(SECRET_KEY_1.getBytes(\u0026quot;UTF-8\u0026quot;)); secretKeySpec = new SecretKeySpec(SECRET_KEY_2.getBytes(\u0026quot;UTF-8\u0026quot;), \u0026quot;AES\u0026quot;); cipher = Cipher.getInstance(\u0026quot;AES/CBC/PKCS5PADDING\u0026quot;); } /** * Encrypt the string with this internal algorithm. * * @param toBeEncrypt string object to be encrypt. * @return returns encrypted string.","tags":["java"],"title":"Java加密类Cipher的使用","uri":"http://www.mingaccount.com/2019/07/java%E5%8A%A0%E5%AF%86%E7%B1%BBcipher%E7%9A%84%E4%BD%BF%E7%94%A8/","year":"2019"},{"content":"多个where条件，每个条件对应的更新值不同，需要mysql批量更新\nUPDATE test_table\rSET\rtest_target = test_id CASE\rWHEN \u0026quot;123\u0026quot; THEN \u0026quot;456\u0026quot;\rWHEN \u0026quot;789\u0026quot; THEN \u0026quot;101\u0026quot;\rEND\rWHERE\rtest_id in ['123','789']\r 但是在程序中，直接写常量的情况太少，大多数都需要变量遍历\n下面是mybatis的应用：\nUPDATE\rtable\rSET\rtarget = CASE id\r\u0026lt;foreach collection=\u0026quot;items\u0026quot; item=\u0026quot;item\u0026quot; close=\u0026quot; END\u0026quot; \u0026gt;\rWHEN #{item.id} THEN #{item.target}\r\u0026lt;/foreach\u0026gt;\rWHERE\rapply_id IN\r\u0026lt;foreach collection=\u0026quot;items\u0026quot; item=\u0026quot;item\u0026quot; open=\u0026quot;(\u0026quot; close=\u0026quot;)\u0026quot; separator=\u0026quot;,\u0026quot; \u0026gt;\r#{item.id}\r\u0026lt;/foreach\u0026gt;\r ","id":27,"section":"posts","summary":"多个where条件，每个条件对应的更新值不同，需要mysql批量更新 UPDATE test_table SET test_target = test_id CASE WHEN \u0026quot;123\u0026quot; THEN \u0026quot;456\u0026quot; WHEN \u0026quot;789\u0026quot; THEN \u0026quot;101\u0026quot; END WHERE test_id in ['123','789'] 但是在程序中，直接写常量的情况太","tags":["mysql"],"title":"Mysql批量更新","uri":"http://www.mingaccount.com/2019/07/mysql%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/","year":"2019"},{"content":"配置有@ConfigurationProperties 注解的类，有如下提示 spring boot configuration annotation processor not found in classpath\npom追加配置如下依赖即可\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt;\r\u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt;\r\u0026lt;/dependency\u0026gt;\r ","id":28,"section":"posts","summary":"配置有@ConfigurationProperties 注解的类，有如下提示 spring boot configuration annotation processor not found in classpath pom追加配置如下依赖即可 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;","tags":["spring"],"title":"spring boot configuration annotation processor not found in classpath","uri":"http://www.mingaccount.com/2019/07/springbootconfigurationexception/","year":"2019"},{"content":"配置复杂，比较臃肿，推荐使用idea的插件easyCode\npom.xml配置：\n\u0026lt;!-- mybatis自动生成 start --\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;!--配置文件的位置--\u0026gt;\r\u0026lt;configurationFile\u0026gt;src/main/resources/generatorConfig.xml\u0026lt;/configurationFile\u0026gt;\r\u0026lt;verbose\u0026gt;true\u0026lt;/verbose\u0026gt;\r\u0026lt;overwrite\u0026gt;true\u0026lt;/overwrite\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;Generate MyBatis Artifacts\u0026lt;/id\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;generate\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis-generator-core\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;!-- mybatis自动生成 end --\u0026gt;\r 配置文件generatorConfig.xml：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE generatorConfiguration\rPUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot;\r\u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt;\r\u0026lt;generatorConfiguration\u0026gt;\r\u0026lt;classPathEntry location=\u0026quot;/Program Files/IBM/SQLLIB/java/db2java.zip\u0026quot; /\u0026gt;\r\u0026lt;context id=\u0026quot;DB2Tables\u0026quot; targetRuntime=\u0026quot;MyBatis3\u0026quot;\u0026gt;\r\u0026lt;!--optional,旨在创建class时，对注释进行控制--\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;property name=\u0026quot;suppressDate\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026gt; \u0026lt;property name=\u0026quot;suppressAllComments\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/commentGenerator\u0026gt;\r\u0026lt;jdbcConnection driverClass=\u0026quot;COM.ibm.db2.jdbc.app.DB2Driver\u0026quot;\rconnectionURL=\u0026quot;jdbc:db2:TEST\u0026quot;\ruserId=\u0026quot;db2admin\u0026quot;\rpassword=\u0026quot;db2admin\u0026quot;\u0026gt;\r\u0026lt;/jdbcConnection\u0026gt;\r\u0026lt;javaTypeResolver \u0026gt;\r\u0026lt;property name=\u0026quot;forceBigDecimals\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt;\r\u0026lt;/javaTypeResolver\u0026gt;\r\u0026lt;javaModelGenerator targetPackage=\u0026quot;test.model\u0026quot; targetProject=\u0026quot;\\MBGTestProject\\src\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;enableSubPackages\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;property name=\u0026quot;trimStrings\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;/javaModelGenerator\u0026gt;\r\u0026lt;sqlMapGenerator targetPackage=\u0026quot;test.xml\u0026quot; targetProject=\u0026quot;\\MBGTestProject\\src\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;enableSubPackages\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;/sqlMapGenerator\u0026gt;\r\u0026lt;javaClientGenerator type=\u0026quot;XMLMAPPER\u0026quot; targetPackage=\u0026quot;test.dao\u0026quot; targetProject=\u0026quot;\\MBGTestProject\\src\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;enableSubPackages\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;/javaClientGenerator\u0026gt;\r\u0026lt;table schema=\u0026quot;DB2ADMIN\u0026quot; tableName=\u0026quot;ALLTYPES\u0026quot; domainObjectName=\u0026quot;Customer\u0026quot; \u0026gt;\r\u0026lt;property name=\u0026quot;useActualColumnNames\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;generatedKey column=\u0026quot;ID\u0026quot; sqlStatement=\u0026quot;DB2\u0026quot; identity=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;columnOverride column=\u0026quot;DATE_FIELD\u0026quot; property=\u0026quot;startDate\u0026quot; /\u0026gt;\r\u0026lt;ignoreColumn column=\u0026quot;FRED\u0026quot; /\u0026gt;\r\u0026lt;columnOverride column=\u0026quot;LONG_VARCHAR_FIELD\u0026quot; jdbcType=\u0026quot;VARCHAR\u0026quot; /\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;/context\u0026gt;\r\u0026lt;/generatorConfiguration\u0026gt;\r 配置文件的注意事项： 这个文件指定得事DB2的驱动，也可以配置其他驱动的路径。\n \u0026ldquo;Java Type Resolver\u0026quot;的属性force bigDecimal为false - 这意味着整形（Short,Integer,Long,etc.)在可能的情况下将会被替换。这个属性是为了更好地处理数据库的DECIMAL和NUMERIC类型的列。 \u0026ldquo;javaModelGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026quot;为true。这意味着生成的PO类将会被放到\u0026quot;test.model.db2admin\u0026quot;这个目录下（因为表是在DB2ADMIN这个schema下）。如果\u0026quot;enableSubPackage\u0026quot;属性为false，这个包就会变为\u0026quot;test.model\u0026rdquo;。同样在\u0026quot;javaModelGenerator\u0026quot;属性下的\u0026quot;trimStrings\u0026quot;意味着在设置po的任何字符串属性时会调用trim方法，这在数据库返回列信息中有空字符串时会有用到。 \u0026ldquo;sqlMapGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026rdquo;，跟\u0026quot;javaModelGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026quot;原理相同。 \u0026ldquo;javaClientGenerator的属性\u0026quot;enableSubPackages\u0026rdquo;，跟\u0026quot;javaModelGenerator\u0026quot;的属性\u0026quot;enableSubPackages\u0026quot;原理相同。DAO的生成器会生成mapper接口，它为MyBatis引用了一个XML的配置。 这个文件只指定了一个表将被内省，但也可以指定多个。关于指定表的注意事项如下：  生成的PO的名称将基于Customer(CustomerKey,Customer,CustoerMapper,etc.)-而不是基于表名。 \u0026ldquo;useActualColumnNames\u0026quot;属性。如果这个属性设为false（或者未被指定），MBG将会取列的驼峰命名。无论何总情况PO的列明都会被属性覆盖。 列有一个\u0026quot;generatedKey\u0026rdquo;，它是一个标识列，而且\u0026quot;sqlStatement\u0026quot;是DB2。MBG会在生成语句时生成一个元素，以便新生成的key能够被返回（使用DB2特定的SQL)。 \u0026ldquo;columnOverrid\u0026quot;属性中的\u0026quot;date_field\u0026quot;将映射到属性\u0026quot;startDate\u0026rdquo;。这回覆盖默认的\u0026quot;useActualColumnNames\u0026quot;属性所设定的规则。 \u0026ldquo;ignoredColumn\u0026quot;属性中的\u0026quot;FRED\u0026quot;字段将被忽略，没有SQL会列出这个字段，也没有Java属性将被生成。 \u0026ldquo;LONG_VARCHAR_FIELD\u0026quot;将被当作一个\u0026quot;VARCHAR\u0026quot;处理，忽略掉它实际的数据类型。    （原文）Important notes about this file follow:  The file specifies that the legacy DB2 CLI driver will be used to connect to the database, and also specifies where the driver can be found. The Java Type Resolver should not force the use of BigDecimal fields - this means that integral types (Short, Integer, Long, etc.) will be substituted if possible. This feature is an attempt to make database DECIMAL and NUMERIC columns easier to deal with. The Java model generator should use sub-packages. This means that the generated model objects will be placed in a package called test.model.db2admin in this case (because the table is in the DB2ADMIN schema). If the enableSubPackages attribute was set to false, then the package would be test.model. The Java model generator should also trim strings. This means that the setters for any String properties will call the trim function - this is useful if your database might return blank characters at the end of character columns. The SQL Map generator should use sub-packages. This means that the generated XML files will be placed in a package called test.xml.db2admin in this case (because the table is in the DB2ADMIN schema). If the enableSubPackages attribute was set to false, then the package would be test.xml. The DAO generator should use sub-packages. This means that the generated DAO classes will be placed in a package called test.dao.db2admin in this case (because the table is in the DB2ADMIN schema). If the enableSubPackages attribute was set to false, then the package would be test.dao. The DAO generator should generate mapper interfaces that reference an XML configuration for MyBatis. The file specifies only one table will be introspected, but many more could be specified. Important notes about the specified table include: The generated objects will be based on the name Customer (CustomerKey, Customer, CustomerMapper, etc.) - rather than on the table name. Actual column names will be used as properties. If this property were set to false (or not specified), then MBG would attempt to camel case the column names. In either case, the name can be overridden by the element The column has a generated key, it is an identity column, and the database type is DB2. This will cause MBG to generate the proper element in the generated statement so that the newly generated key can be returned (using DB2 specific SQL). The column DATE_FIELD will be mapped to a property called startDate. This will override the default property which would be DATE_FIELD in this case, or dateFieldif the useActualColumnNames property was set to false. The column FRED will be ignored. No SQL will list the field, and no Java property will be generated. The column LONG_VARCHAR_FIELD will be treated as a VARCHAR field, regardless of the actual data type.  ","id":29,"section":"posts","summary":"配置复杂，比较臃肿，推荐使用idea的插件easyCode pom.xml配置： \u0026lt;!-- mybatis自动生成 start --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--配置文件的","tags":["mybatis"],"title":"Mybatis Generator配置","uri":"http://www.mingaccount.com/2019/07/mybatisgenerator%E9%85%8D%E7%BD%AE/","year":"2019"},{"content":"问题是由mysql的编码问题造成，因为建表的时候没有指定utf-8作为字符集 建议重新建表，或者直接调整对应字段的字符集\n1.修改mysql编码的 　查看mysql的字符集：\nshow variables where Variable_name like '%char%';\r 　修改mysql的字符集：　mysql\u0026gt; set character_set_client=utf8;\rmysql\u0026gt; set character_set_connection=utf8;\rmysql\u0026gt; set character_set_database=utf8;\rmysql\u0026gt; set character_set_results=utf8;\rmysql\u0026gt; set character_set_server=utf8;\rmysql\u0026gt; set character_set_system=utf8;\rmysql\u0026gt; set collation_connection=utf8;\rmysql\u0026gt; set collation_database=utf8;\rmysql\u0026gt; set collation_server=utf8;\r 2.修改数据库的编码 　查看数据库的字符集：\nshow create database enterprises;\r 　修改数据库的字符集：\nalter database enterprises character set utf8\r 3.修改表的编码 　查看表的字符集：\n#位于建表语句的末尾\rshow create table employees;\r 　修改表的字符集：\nalter table employees character set utf8\r 　修改字段的字符集：\nalter table employees change name name char(10) character set utf-8;\r ","id":30,"section":"posts","summary":"问题是由mysql的编码问题造成，因为建表的时候没有指定utf-8作为字符集 建议重新建表，或者直接调整对应字段的字符集 1.修改mysql编码","tags":["mysql"],"title":"mySql 插入中文异常 Incorrect string value: '***' for column","uri":"http://www.mingaccount.com/2019/07/mysql_%E6%8F%92%E5%85%A5%E4%B8%AD%E6%96%87%E5%BC%82%E5%B8%B8/","year":"2019"},{"content":"val 精简变量修饰，类似Scala，但是默认追加了final修饰符 val list = new ArrayList\u0026lt;String\u0026gt;();\r//等同于\rfinal ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();\r var 精简变量修饰，类似Scala，修饰变量 val list = new ArrayList\u0026lt;String\u0026gt;();\r//等同于\rArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();\r NonNull 修饰方法或者构造方法的参数，以及成员变量 public NonNullExample(@NonNull Person person) {\rsuper(\u0026quot;Hello\u0026quot;);\rthis.name = person.getName();\r}\r//等同于\rpublic NonNullExample(@NonNull Person person) {\rsuper(\u0026quot;Hello\u0026quot;);\rif (person == null) {\rthrow new NullPointerException(\u0026quot;person is marked @NonNull but is null\u0026quot;);\r}\rthis.name = person.getName();\r}\r Cleanup 修饰局部变量，用于关闭资源 默认触发修饰变量的close方法，但是如果目标对象没有close方法，可以直接指定关闭方法的名称 但是要求关闭方法不能有参数\n@Cleanup(\u0026quot;dispose\u0026quot;) org.eclipse.swt.widgets.CoolBar bar = new CoolBar(parent, 0);\r import lombok.Cleanup;\rimport java.io.*;\rpublic class CleanupExample {\rpublic static void main(String[] args) throws IOException {\r@Cleanup InputStream in = new FileInputStream(args[0]);\r@Cleanup OutputStream out = new FileOutputStream(args[1]);\rbyte[] b = new byte[10000];\rwhile (true) {\rint r = in.read(b);\rif (r == -1) break;\rout.write(b, 0, r);\r}\r}\r}\r 等同于\n import java.io.*;\rpublic class CleanupExample {\rpublic static void main(String[] args) throws IOException {\rInputStream in = new FileInputStream(args[0]);\rtry {\rOutputStream out = new FileOutputStream(args[1]);\rtry {\rbyte[] b = new byte[10000];\rwhile (true) {\rint r = in.read(b);\rif (r == -1) break;\rout.write(b, 0, r);\r}\r} finally {\rif (out != null) {\rout.close();\r}\r}\r} finally {\rif (in != null) {\rin.close();\r}\r}\r}\r}\r Getter/Setter 修饰成员变量或者类，已生成GetSet方法  当修饰类时，将生成类中所有的非静态成员变量的Get/Set类 Getter/Setter都有AccessLevel参数，可设置生成的方法的修饰符(PUBLIC, PROTECTED, PACKAGE, and PRIVATE) 如果类被注解修饰，但是某个成员变量不想生成方法，可以设置AccessLevel参数值为NONE  import lombok.AccessLevel;\rimport lombok.Getter;\rimport lombok.Setter;\rpublic class GetterSetterExample {\r/**\r* Age of the person. Water is wet.\r* * @param age New value for this person's age. Sky is blue.\r* @return The current value of this person's age. Circles are round.\r*/\r@Getter @Setter private int age = 10;\r/**\r* Name of the person.\r* -- SETTER --\r* Changes the name of this person.\r* * @param name The new value.\r*/\r@Setter(AccessLevel.PROTECTED) private String name;\r@Override public String toString() {\rreturn String.format(\u0026quot;%s (age: %d)\u0026quot;, name, age);\r}\r}\r 等同于\n public class GetterSetterExample {\r/**\r* Age of the person. Water is wet.\r*/\rprivate int age = 10;\r/**\r* Name of the person.\r*/\rprivate String name;\r@Override public String toString() {\rreturn String.format(\u0026quot;%s (age: %d)\u0026quot;, name, age);\r}\r/**\r* Age of the person. Water is wet.\r*\r* @return The current value of this person's age. Circles are round.\r*/\rpublic int getAge() {\rreturn age;\r}\r/**\r* Age of the person. Water is wet.\r*\r* @param age New value for this person's age. Sky is blue.\r*/\rpublic void setAge(int age) {\rthis.age = age;\r}\r/**\r* Changes the name of this person.\r*\r* @param name The new value.\r*/\rprotected void setName(String name) {\rthis.name = name;\r}\r}\r ToString 修饰类和方法，重写toString方法  默认格式类名(字段值1，字段值2) 可通过设置includeFieldNames=true，在字段值前面加上字段名: 默认所有非静态字段都会被打印，可以通过注解@ToString.Exclude来排除字段 如果只展示目标字段，可以在类的注解上追加参数onlyExplicitlyIncluded=true，然后在字段上加注解ToString.Include 如果需要打印父类的字段，可以设置参数callSuper=true 打印方法的输出，在方法上追加注解ToString.Include，注意必须是非静态方法，并且没有参数  import lombok.ToString;\r@ToString\rpublic class ToStringExample {\rprivate static final int STATIC_VAR = 10;\rprivate String name;\rprivate Shape shape = new Square(5, 10);\rprivate String[] tags;\r@ToString.Exclude private int id;\rpublic String getName() {\rreturn this.name;\r}\r@ToString(callSuper=true, includeFieldNames=true)\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r}\r}\r 等同于\n import java.util.Arrays;\rpublic class ToStringExample {\rprivate static final int STATIC_VAR = 10;\rprivate String name;\rprivate Shape shape = new Square(5, 10);\rprivate String[] tags;\rprivate int id;\rpublic String getName() {\rreturn this.name;\r}\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r@Override public String toString() {\rreturn \u0026quot;Square(super=\u0026quot; + super.toString() + \u0026quot;, width=\u0026quot; + this.width + \u0026quot;, height=\u0026quot; + this.height + \u0026quot;)\u0026quot;;\r}\r}\r@Override public String toString() {\rreturn \u0026quot;ToStringExample(\u0026quot; + this.getName() + \u0026quot;, \u0026quot; + this.shape + \u0026quot;, \u0026quot; + Arrays.deepToString(this.tags) + \u0026quot;)\u0026quot;;\r}\r}\r EqualsAndHashCode 生成equals和hashCode方法  默认使用非静态和非transient修饰的字段 排除指定字段：注解@EqualsAndHashCode.Exclude 只选择指定字段：类注解@EqualsAndHashCode(onlyExplicitlyIncluded = true)，和字段注解@EqualsAndHashCode.Include 如果包含非Object父类，设置属性callSuper=true  import lombok.EqualsAndHashCode;\r@EqualsAndHashCode\rpublic class EqualsAndHashCodeExample {\rprivate transient int transientVar = 10;\rprivate String name;\rprivate double score;\r@EqualsAndHashCode.Exclude private Shape shape = new Square(5, 10);\rprivate String[] tags;\r@EqualsAndHashCode.Exclude private int id;\rpublic String getName() {\rreturn this.name;\r}\r@EqualsAndHashCode(callSuper=true)\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r}\r}\r 等同于\n import java.util.Arrays;\rpublic class EqualsAndHashCodeExample {\rprivate transient int transientVar = 10;\rprivate String name;\rprivate double score;\rprivate Shape shape = new Square(5, 10);\rprivate String[] tags;\rprivate int id;\rpublic String getName() {\rreturn this.name;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof EqualsAndHashCodeExample)) return false;\rEqualsAndHashCodeExample other = (EqualsAndHashCodeExample) o;\rif (!other.canEqual((Object)this)) return false;\rif (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;\rif (Double.compare(this.score, other.score) != 0) return false;\rif (!Arrays.deepEquals(this.tags, other.tags)) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal long temp1 = Double.doubleToLongBits(this.score);\rresult = (result*PRIME) + (this.name == null ? 43 : this.name.hashCode());\rresult = (result*PRIME) + (int)(temp1 ^ (temp1 \u0026gt;\u0026gt;\u0026gt; 32));\rresult = (result*PRIME) + Arrays.deepHashCode(this.tags);\rreturn result;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof EqualsAndHashCodeExample;\r}\rpublic static class Square extends Shape {\rprivate final int width, height;\rpublic Square(int width, int height) {\rthis.width = width;\rthis.height = height;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof Square)) return false;\rSquare other = (Square) o;\rif (!other.canEqual((Object)this)) return false;\rif (!super.equals(o)) return false;\rif (this.width != other.width) return false;\rif (this.height != other.height) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rresult = (result*PRIME) + super.hashCode();\rresult = (result*PRIME) + this.width;\rresult = (result*PRIME) + this.height;\rreturn result;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof Square;\r}\r}\r}\r @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor 生成构造函数  NoArgsConstructor 注意有参数被final修饰的情况，需要加上参数(force = true) RequiredArgsConstructor 只对两类变量有效，一种是final修饰的并且没有初始化的变量，另外一类是NonNull注解修饰并且没有初始化的变量 AllArgsConstructor 生成一个包括所有参数的构造方法，并且有NonNull注解的会进行非空检查 @RequiredArgsConstructor(staticName=\u0026quot;of\u0026quot;) 生成一个私有的构造方法，并提供一个静态方法of包装私有构造方法 以上注解只对非static字段生效  import lombok.AccessLevel;\rimport lombok.RequiredArgsConstructor;\rimport lombok.AllArgsConstructor;\rimport lombok.NonNull;\r@RequiredArgsConstructor(staticName = \u0026quot;of\u0026quot;)\r@AllArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class ConstructorExample\u0026lt;T\u0026gt; {\rprivate int x, y;\r@NonNull private T description;\r@NoArgsConstructor\rpublic static class NoArgsExample {\r@NonNull private String field;\r}\r}\r 等同于\n public class ConstructorExample\u0026lt;T\u0026gt; {\rprivate int x, y;\r@NonNull private T description;\rprivate ConstructorExample(T description) {\rif (description == null) throw new NullPointerException(\u0026quot;description\u0026quot;);\rthis.description = description;\r}\rpublic static \u0026lt;T\u0026gt; ConstructorExample\u0026lt;T\u0026gt; of(T description) {\rreturn new ConstructorExample\u0026lt;T\u0026gt;(description);\r}\r@java.beans.ConstructorProperties({\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;description\u0026quot;})\rprotected ConstructorExample(int x, int y, T description) {\rif (description == null) throw new NullPointerException(\u0026quot;description\u0026quot;);\rthis.x = x;\rthis.y = y;\rthis.description = description;\r}\rpublic static class NoArgsExample {\r@NonNull private String field;\rpublic NoArgsExample() {\r}\r}\r}\r Data 大集合  相当于一个快捷方式，包括之前的toString,EqualsAndHashCode,所有字段的Getter,非final字段的Setter，和RequiredArgsConstructor Data无法像单个注解一样添加自定义属性，但是可以再次追加单个注解，以覆盖Data对应的方法 如果有任何同名的方法存在，Data不会再生成对应的方法 如果有任意一个构造方法，Data注解将不会生成RequiredArgsConstructor对应的构造方法  import lombok.AccessLevel;\rimport lombok.Setter;\rimport lombok.Data;\rimport lombok.ToString;\r@Data public class DataExample {\rprivate final String name;\r@Setter(AccessLevel.PACKAGE) private int age;\rprivate double score;\rprivate String[] tags;\r@ToString(includeFieldNames=true)\r@Data(staticConstructor=\u0026quot;of\u0026quot;)\rpublic static class Exercise\u0026lt;T\u0026gt; {\rprivate final String name;\rprivate final T value;\r}\r}\r 等同于\n import java.util.Arrays;\rpublic class DataExample {\rprivate final String name;\rprivate int age;\rprivate double score;\rprivate String[] tags;\rpublic DataExample(String name) {\rthis.name = name;\r}\rpublic String getName() {\rreturn this.name;\r}\rvoid setAge(int age) {\rthis.age = age;\r}\rpublic int getAge() {\rreturn this.age;\r}\rpublic void setScore(double score) {\rthis.score = score;\r}\rpublic double getScore() {\rreturn this.score;\r}\rpublic String[] getTags() {\rreturn this.tags;\r}\rpublic void setTags(String[] tags) {\rthis.tags = tags;\r}\r@Override public String toString() {\rreturn \u0026quot;DataExample(\u0026quot; + this.getName() + \u0026quot;, \u0026quot; + this.getAge() + \u0026quot;, \u0026quot; + this.getScore() + \u0026quot;, \u0026quot; + Arrays.deepToString(this.getTags()) + \u0026quot;)\u0026quot;;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof DataExample;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof DataExample)) return false;\rDataExample other = (DataExample) o;\rif (!other.canEqual((Object)this)) return false;\rif (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;\rif (this.getAge() != other.getAge()) return false;\rif (Double.compare(this.getScore(), other.getScore()) != 0) return false;\rif (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal long temp1 = Double.doubleToLongBits(this.getScore());\rresult = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());\rresult = (result*PRIME) + this.getAge();\rresult = (result*PRIME) + (int)(temp1 ^ (temp1 \u0026gt;\u0026gt;\u0026gt; 32));\rresult = (result*PRIME) + Arrays.deepHashCode(this.getTags());\rreturn result;\r}\rpublic static class Exercise\u0026lt;T\u0026gt; {\rprivate final String name;\rprivate final T value;\rprivate Exercise(String name, T value) {\rthis.name = name;\rthis.value = value;\r}\rpublic static \u0026lt;T\u0026gt; Exercise\u0026lt;T\u0026gt; of(String name, T value) {\rreturn new Exercise\u0026lt;T\u0026gt;(name, value);\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic T getValue() {\rreturn this.value;\r}\r@Override public String toString() {\rreturn \u0026quot;Exercise(name=\u0026quot; + this.getName() + \u0026quot;, value=\u0026quot; + this.getValue() + \u0026quot;)\u0026quot;;\r}\rprotected boolean canEqual(Object other) {\rreturn other instanceof Exercise;\r}\r@Override public boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof Exercise)) return false;\rExercise\u0026lt;?\u0026gt; other = (Exercise\u0026lt;?\u0026gt;) o;\rif (!other.canEqual((Object)this)) return false;\rif (this.getName() == null ? other.getValue() != null : !this.getName().equals(other.getName())) return false;\rif (this.getValue() == null ? other.getValue() != null : !this.getValue().equals(other.getValue())) return false;\rreturn true;\r}\r@Override public int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rresult = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());\rresult = (result*PRIME) + (this.getValue() == null ? 43 : this.getValue().hashCode());\rreturn result;\r}\r}\r}\r Value修饰类，生成一个final类，并且成员变量全是private final修饰  Value是个快捷方式，完整的注解：final @ToString @EqualsAndHashCode @AllArgsConstructor @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE) @Getter  在修饰类和成员变量的同时，Value会生成toString、equals、hashCode方法，还有包括所有参数的构造方法以及所有成员变量的get方法 如果有任何自定义的构造方法，Value将不会再生成一个所有参数的构造方法  import lombok.AccessLevel;\rimport lombok.experimental.NonFinal;\rimport lombok.experimental.Value;\rimport lombok.experimental.Wither;\rimport lombok.ToString;\r@Value public class ValueExample {\rString name;\r@Wither(AccessLevel.PACKAGE) @NonFinal int age;\rdouble score;\rprotected String[] tags;\r@ToString(includeFieldNames=true)\r@Value(staticConstructor=\u0026quot;of\u0026quot;)\rpublic static class Exercise\u0026lt;T\u0026gt; {\rString name;\rT value;\r}\r}\r 等同于\n import java.util.Arrays;\rpublic final class ValueExample {\rprivate final String name;\rprivate int age;\rprivate final double score;\rprotected final String[] tags;\r@java.beans.ConstructorProperties({\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;, \u0026quot;score\u0026quot;, \u0026quot;tags\u0026quot;})\rpublic ValueExample(String name, int age, double score, String[] tags) {\rthis.name = name;\rthis.age = age;\rthis.score = score;\rthis.tags = tags;\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic int getAge() {\rreturn this.age;\r}\rpublic double getScore() {\rreturn this.score;\r}\rpublic String[] getTags() {\rreturn this.tags;\r}\r@java.lang.Override\rpublic boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof ValueExample)) return false;\rfinal ValueExample other = (ValueExample)o;\rfinal Object this$name = this.getName();\rfinal Object other$name = other.getName();\rif (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;\rif (this.getAge() != other.getAge()) return false;\rif (Double.compare(this.getScore(), other.getScore()) != 0) return false;\rif (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;\rreturn true;\r}\r@java.lang.Override\rpublic int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal Object $name = this.getName();\rresult = result * PRIME + ($name == null ? 43 : $name.hashCode());\rresult = result * PRIME + this.getAge();\rfinal long $score = Double.doubleToLongBits(this.getScore());\rresult = result * PRIME + (int)($score \u0026gt;\u0026gt;\u0026gt; 32 ^ $score);\rresult = result * PRIME + Arrays.deepHashCode(this.getTags());\rreturn result;\r}\r@java.lang.Override\rpublic String toString() {\rreturn \u0026quot;ValueExample(name=\u0026quot; + getName() + \u0026quot;, age=\u0026quot; + getAge() + \u0026quot;, score=\u0026quot; + getScore() + \u0026quot;, tags=\u0026quot; + Arrays.deepToString(getTags()) + \u0026quot;)\u0026quot;;\r}\rValueExample withAge(int age) {\rreturn this.age == age ? this : new ValueExample(name, age, score, tags);\r}\rpublic static final class Exercise\u0026lt;T\u0026gt; {\rprivate final String name;\rprivate final T value;\rprivate Exercise(String name, T value) {\rthis.name = name;\rthis.value = value;\r}\rpublic static \u0026lt;T\u0026gt; Exercise\u0026lt;T\u0026gt; of(String name, T value) {\rreturn new Exercise\u0026lt;T\u0026gt;(name, value);\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic T getValue() {\rreturn this.value;\r}\r@java.lang.Override\rpublic boolean equals(Object o) {\rif (o == this) return true;\rif (!(o instanceof ValueExample.Exercise)) return false;\rfinal Exercise\u0026lt;?\u0026gt; other = (Exercise\u0026lt;?\u0026gt;)o;\rfinal Object this$name = this.getName();\rfinal Object other$name = other.getName();\rif (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;\rfinal Object this$value = this.getValue();\rfinal Object other$value = other.getValue();\rif (this$value == null ? other$value != null : !this$value.equals(other$value)) return false;\rreturn true;\r}\r@java.lang.Override\rpublic int hashCode() {\rfinal int PRIME = 59;\rint result = 1;\rfinal Object $name = this.getName();\rresult = result * PRIME + ($name == null ? 43 : $name.hashCode());\rfinal Object $value = this.getValue();\rresult = result * PRIME + ($value == null ? 43 : $value.hashCode());\rreturn result;\r}\r@java.lang.Override\rpublic String toString() {\rreturn \u0026quot;ValueExample.Exercise(name=\u0026quot; + getName() + \u0026quot;, value=\u0026quot; + getValue() + \u0026quot;)\u0026quot;;\r}\r}\r}\r Builder 构造者模式生成实体类，可修饰类，构造方法和一般方法 类似\nPerson.builder().name(\u0026quot;Adam Savage\u0026quot;).city(\u0026quot;San Francisco\u0026quot;).job(\u0026quot;Mythbusters\u0026quot;).job(\u0026quot;Unchained Reaction\u0026quot;).build();\r  当一个方法被Builder注解修饰（以下简称target)，会有七个要素生成  一个内部静态类叫做 FooBuilder ，有着和静态方法一样的类型参数(以下简称builder) 在builder里，target方法的每一个参数都对应了一个私有的非静态非final的成员变量 在builder里，包含一个package范围的私有无参的空构造方法 在builder里，每一个target的参数都对应了一个类似setter的方法，但是这个setter方法跟target方法的参数名一样，并且返回了builder自身，以形成链式结构 在builder里，包含一个build方法，用对应的参数调用target方法，最终生成target方法的返回值 在builder里，包含一个合理的toString实现 在target方法所在的类，会包含一个builder方法，他会创建类builder的实例   以上的7个要素如果在检测到有同名的要素时会自动跳过（只对比名称） 当Builder作用于类时，请确保该类没有任何显性的构造函数。如果有任意显性构造函数，请直接将Builder作用于构造函数上 当Builder和Value同时作用于一个类时，Builder想要生成的Package范围的构造函数会覆盖Value想要生成的private范围的构造函数 如果参数的值需要从某个字段或者方法获取，可以在字段或者参数上添加注解@Builder.ObtainVia(method = \u0026quot;\u0026quot;) Builder可配置的方面包括  静态内部类的名称(默认是type + \u0026ldquo;Builder\u0026rdquo;) build方法的名称 builder方法的名称 是否需要toBuilder()方法 生成元素的访问范围 如果你的构造链方法需要一个前缀，比如Person.builder().setName   关于以上配置项，下面是个实例\n@Builder(builderClassName = \u0026quot;HelloWorldBuilder\u0026quot;, buildMethodName = \u0026quot;execute\u0026quot;, builderMethodName = \u0026quot;helloWorld\u0026quot;, toBuilder = true, access = AccessLevel.PRIVATE, setterPrefix = \u0026quot;set\u0026quot;) 当Builder注解作用于类，某些成员变量不需要set的时候，可以设置成员变量默认值\n成员变量上用注解@Builder.Default实现\n@Builder.Default private final long created = System.currentTimeMillis(); @Singular 注解作用于参数或者成员变量时，会吧对应参数当做集合。  不会生成setter而会生成两个adder方法，一个新增单个，一个新增整个集合 还会生成一个clear方法，一旦build方法被调用，生成的集合不能再被修改 可指定新增单个的方法名@Singular(\u0026quot;axis\u0026quot;) List\u0026lt;Line\u0026gt; axes; 如果追加的集合为null会抛出异常，可设置忽略空集合@Singular(ignoreNullCollections = true)    import lombok.Builder;\rimport lombok.Singular;\rimport java.util.Set;\r@Builder\rpublic class BuilderExample {\r@Builder.Default private long created = System.currentTimeMillis();\rprivate String name;\rprivate int age;\r@Singular private Set\u0026lt;String\u0026gt; occupations;\r}\r 等同于\n import java.util.Set;\rpublic class BuilderExample {\rprivate long created;\rprivate String name;\rprivate int age;\rprivate Set\u0026lt;String\u0026gt; occupations;\rBuilderExample(String name, int age, Set\u0026lt;String\u0026gt; occupations) {\rthis.name = name;\rthis.age = age;\rthis.occupations = occupations;\r}\rprivate static long $default$created() {\rreturn System.currentTimeMillis();\r}\rpublic static BuilderExampleBuilder builder() {\rreturn new BuilderExampleBuilder();\r}\rpublic static class BuilderExampleBuilder {\rprivate long created;\rprivate boolean created$set;\rprivate String name;\rprivate int age;\rprivate java.util.ArrayList\u0026lt;String\u0026gt; occupations;\rBuilderExampleBuilder() {\r}\rpublic BuilderExampleBuilder created(long created) {\rthis.created = created;\rthis.created$set = true;\rreturn this;\r}\rpublic BuilderExampleBuilder name(String name) {\rthis.name = name;\rreturn this;\r}\rpublic BuilderExampleBuilder age(int age) {\rthis.age = age;\rreturn this;\r}\rpublic BuilderExampleBuilder occupation(String occupation) {\rif (this.occupations == null) {\rthis.occupations = new java.util.ArrayList\u0026lt;String\u0026gt;();\r}\rthis.occupations.add(occupation);\rreturn this;\r}\rpublic BuilderExampleBuilder occupations(Collection\u0026lt;? extends String\u0026gt; occupations) {\rif (this.occupations == null) {\rthis.occupations = new java.util.ArrayList\u0026lt;String\u0026gt;();\r}\rthis.occupations.addAll(occupations);\rreturn this;\r}\rpublic BuilderExampleBuilder clearOccupations() {\rif (this.occupations != null) {\rthis.occupations.clear();\r}\rreturn this;\r}\rpublic BuilderExample build() {\r// complicated switch statement to produce a compact properly sized immutable set omitted.\rSet\u0026lt;String\u0026gt; occupations = ...;\rreturn new BuilderExample(created$set ? created : BuilderExample.$default$created(), name, age, occupations);\r}\r@java.lang.Override\rpublic String toString() {\rreturn \u0026quot;BuilderExample.BuilderExampleBuilder(created = \u0026quot; + this.created + \u0026quot;, name = \u0026quot; + this.name + \u0026quot;, age = \u0026quot; + this.age + \u0026quot;, occupations = \u0026quot; + this.occupations + \u0026quot;)\u0026quot;;\r}\r}\r}\r SneakyThrows checked Exception不用再try catch 不推荐\nSynchronized 用户成员方法或者静态方法 关键字synchronized锁的是this，但是该注解锁的是不同的对象\nimport lombok.Synchronized;\rpublic class SynchronizedExample {\rprivate final Object readLock = new Object();\r@Synchronized\rpublic static void hello() {\rSystem.out.println(\u0026quot;world\u0026quot;);\r}\r@Synchronized\rpublic int answerToLife() {\rreturn 42;\r}\r@Synchronized(\u0026quot;readLock\u0026quot;)\rpublic void foo() {\rSystem.out.println(\u0026quot;bar\u0026quot;);\r}\r}\r 等同于\n public class SynchronizedExample {\rprivate static final Object $LOCK = new Object[0];\rprivate final Object $lock = new Object[0];\rprivate final Object readLock = new Object();\rpublic static void hello() {\rsynchronized($LOCK) {\rSystem.out.println(\u0026quot;world\u0026quot;);\r}\r}\rpublic int answerToLife() {\rsynchronized($lock) {\rreturn 42;\r}\r}\rpublic void foo() {\rsynchronized(readLock) {\rSystem.out.println(\u0026quot;bar\u0026quot;);\r}\r}\r}\r With用于成员变量或者类上，表示可修改类中的任何或者指定字段，即使该字段是final 其实就是clone了一个当前类，并修改对应成员变量的值\nimport lombok.AccessLevel;\rimport lombok.NonNull;\rimport lombok.With;\rpublic class WithExample {\r@With(AccessLevel.PROTECTED) @NonNull private final String name;\r@With private final int age;\rpublic WithExample(String name, int age) {\rif (name == null) throw new NullPointerException();\rthis.name = name;\rthis.age = age;\r}\r}\r import lombok.NonNull;\rpublic class WithExample {\rprivate @NonNull final String name;\rprivate final int age;\rpublic WithExample(String name, int age) {\rif (name == null) throw new NullPointerException();\rthis.name = name;\rthis.age = age;\r}\rprotected WithExample withName(@NonNull String name) {\rif (name == null) throw new java.lang.NullPointerException(\u0026quot;name\u0026quot;);\rreturn this.name == name ? this : new WithExample(name, age);\r}\rpublic WithExample withAge(int age) {\rreturn this.age == age ? this : new WithExample(name, age);\r}\r}\r Getter(lazy=true) 修饰private final 成员变量，获取一次，并缓存，之后都取缓存 当一个成员变量的计算需要消耗大量资源，可以将它设置为private final，并加上该注解\n这个注解会在第一次计算后缓存结果，他要求计算方法是非线程安全的\nimport lombok.Getter;\rpublic class GetterLazyExample {\r@Getter(lazy=true) private final double[] cached = expensive();\rprivate double[] expensive() {\rdouble[] result = new double[1000000];\rfor (int i = 0; i \u0026lt; result.length; i++) {\rresult[i] = Math.asin(i);\r}\rreturn result;\r}\r}\r 等同于\n public class GetterLazyExample {\rprivate final java.util.concurrent.AtomicReference\u0026lt;java.lang.Object\u0026gt; cached = new java.util.concurrent.AtomicReference\u0026lt;java.lang.Object\u0026gt;();\rpublic double[] getCached() {\rjava.lang.Object value = this.cached.get();\rif (value == null) {\rsynchronized(this.cached) {\rvalue = this.cached.get();\rif (value == null) {\rfinal double[] actualValue = expensive();\rvalue = actualValue == null ? this.cached : actualValue;\rthis.cached.set(value);\r}\r}\r}\rreturn (double[])(value == this.cached ? null : value);\r}\rprivate double[] expensive() {\rdouble[] result = new double[1000000];\rfor (int i = 0; i \u0026lt; result.length; i++) {\rresult[i] = Math.asin(i);\r}\rreturn result;\r}\r}\r Log修饰类，增加成员变量log 多个注解，以适配多种Logger:\n @CommonsLog\nprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class); @Flogger\nprivate static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass(); @JBossLog private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class); @Log\nprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName()); @Log4j\nprivate static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class); @Log4j2\nprivate static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class); @Slf4j\nprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class); @XSlf4j\nprivate static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); @CustomLog\n可自定义log，详情参考结尾的官方链接  import lombok.extern.java.Log;\rimport lombok.extern.slf4j.Slf4j;\r@Log\rpublic class LogExample {\rpublic static void main(String... args) {\rlog.severe(\u0026quot;Something's wrong here\u0026quot;);\r}\r}\r@Slf4j\rpublic class LogExampleOther {\rpublic static void main(String... args) {\rlog.error(\u0026quot;Something else is wrong here\u0026quot;);\r}\r}\r@CommonsLog(topic=\u0026quot;CounterLog\u0026quot;)\rpublic class LogExampleCategory {\rpublic static void main(String... args) {\rlog.error(\u0026quot;Calling the 'CounterLog' with a message\u0026quot;);\r}\r}\r 相当于\n public class LogExample {\rprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());\rpublic static void main(String... args) {\rlog.severe(\u0026quot;Something's wrong here\u0026quot;);\r}\r}\rpublic class LogExampleOther {\rprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);\rpublic static void main(String... args) {\rlog.error(\u0026quot;Something else is wrong here\u0026quot;);\r}\r}\rpublic class LogExampleCategory {\rprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(\u0026quot;CounterLog\u0026quot;);\rpublic static void main(String... args) {\rlog.error(\u0026quot;Calling the 'CounterLog' with a message\u0026quot;);\r}\r}\r  详细参考 lombok官方文档\n ","id":31,"section":"posts","summary":"val 精简变量修饰，类似Scala，但是默认追加了final修饰符 val list = new ArrayList\u0026lt;String\u0026gt;(); //等同于 final ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); var 精简变量修饰，类似Scala，修饰变量 val list =","tags":["lombok","java"],"title":"lombok详解","uri":"http://www.mingaccount.com/2019/07/lombok/","year":"2019"},{"content":"问题背景 项目的两个依赖，包含了同一个路径，然而因为项目原因还不能删除其中任何一个\n代码在本地和线上都能正常通过编译\n但是一执行到对应代码就会抛出如下error:\n java.lang.NoClassDefFoundError:\r 问题原因 跟踪代码后得知，报错代码引用的是pom中的第二个依赖\r引用位置低于第一个\r然而maven的逻辑是谁的\u0026lt;dependency\u0026gt;在前，就优先选择哪个依赖\r 解决方案 调整\u0026lt;dependency\u0026gt;的顺序，得以解决 ","id":32,"section":"posts","summary":"问题背景 项目的两个依赖，包含了同一个路径，然而因为项目原因还不能删除其中任何一个 代码在本地和线上都能正常通过编译 但是一执行到对应代码就会抛出","tags":["maven"],"title":"Maven jar包冲突导致NoClassDefFoundError","uri":"http://www.mingaccount.com/2019/07/mavenjar%E5%8C%85%E5%86%B2%E7%AA%81/","year":"2019"},{"content":"在协作开发时，从接口获取到的json实体部分为空，但是在调试时发现原对象没有任何问题，但是经过解析成为json后，部分属性变为：\n\u0026ldquo;$ref\u0026rdquo;:\u0026ldquo;$.*******“\n改变解析方式为Gson问题解决，经查是fastjson在解析json时，会将json中相同的内容改为引用导致\n这么做的原因是防止实体类中有自引用，解析的时候出现死循环，从而导致栈内存溢出\n可以通过设置取消fastjson的引用，但是可能出现内存溢出风险，需要自行评估\nJSONArray.toJSONString(jsonArray, SerializerFeature.DisableCircularReferenceDetect);\rJSONObject.parse(JSONArray.toJSONString(jsonArray, SerializerFeature.DisableCircularReferenceDetect));\r ","id":33,"section":"posts","summary":"在协作开发时，从接口获取到的json实体部分为空，但是在调试时发现原对象没有任何问题，但是经过解析成为json后，部分属性变为： \u0026ldquo","tags":["java"],"title":"FastJson解析结果部分属性为null的问题","uri":"http://www.mingaccount.com/2019/07/json%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%9C%E9%83%A8%E5%88%86%E5%B1%9E%E6%80%A7%E4%B8%BAnull%E7%9A%84%E9%97%AE%E9%A2%98/","year":"2019"},{"content":"spark sql也支持函数，但与通常的数据库函数有些区别，附上官方api文档，以作备忘：\nhttp://spark.apache.org/docs/latest/api/sql/index.html#acos\n","id":34,"section":"posts","summary":"spark sql也支持函数，但与通常的数据库函数有些区别，附上官方api文档，以作备忘： http://spark.apache.org/docs/latest/api/sql/index.html#acos","tags":["spark"],"title":"SparkSql函数文档","uri":"http://www.mingaccount.com/2019/07/sparksqlapi/","year":"2019"},{"content":"pom设置 \u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-install-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.5.1\u0026lt;/version\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;install-jar-lib\u0026lt;/id\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;install-file\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;!--在mvn package的时候将jar包追加到本地仓库，可修改为validate，以线上容器编译执行的mvn命令为准--\u0026gt;\r\u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;groupId\u0026gt;custom\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;custom\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;\r\u0026lt;file\u0026gt;${project.basedir}/src/main/resources/lib/custom.jar\u0026lt;/file\u0026gt;\r\u0026lt;generatePom\u0026gt;true\u0026lt;/generatePom\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r 然后像一般的包一样加上依赖即可\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;custom\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;custom\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r 可能遇到的问题  本地编译不通过   本地环境执行一下mvn package(对应pom填写的\u0026lt;phase\u0026gt;)\r 线上编译不通过   检查\u0026lt;phase\u0026gt;中的mvn语句，线上打包时是否运行\r 本地和线上环境编译都通过，但是执行到对应代码就报错，提示找不到类   确保\u0026lt;dependency\u0026gt;正确填写，如果有多个module使用，\u0026lt;plugin\u0026gt;可以只写一次，但是每个module都要填写对应\u0026lt;dependency\u0026gt;\r如果导入的本地包与现有包冲突也会出现这种问题，如果以本地包为准，需要保证本地包的\u0026lt;dependency\u0026gt;在文本顺序上要先于已有的包\r 打好包在另外一个系统上运行报错\npom加上如下依赖  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;custom\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;custom\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt;\r\u0026lt;systemPath\u0026gt;${project.basedir}/src/main/resources/lib/custom.jar\u0026lt;/systemPath\u0026gt;\r\u0026lt;/dependency\u0026gt;\r ","id":35,"section":"posts","summary":"pom设置 \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-install-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;install-jar-lib\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;install-file\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;!--在mvn package的时候将jar包追加到本地仓库，可修改为validate，以线上容器编译","tags":["maven"],"title":"Maven如何正确导入本地包，保证在线上正常运行","uri":"http://www.mingaccount.com/2019/06/maven%E5%A6%82%E6%9E%9C%E6%AD%A3%E7%A1%AE%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%8C%85/","year":"2019"},{"content":"脚本：\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh \u0026amp;\u0026amp; chmod +x bbr.sh \u0026amp;\u0026amp; ./bbr.sh\r 查看结果：\nsysctl net.ipv4.tcp_available_congestion_control\r ","id":36,"section":"posts","summary":"脚本： wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh \u0026amp;\u0026amp; chmod +x bbr.sh \u0026amp;\u0026amp; ./bbr.sh 查看结果： sysctl net.ipv4.tcp_available_congestion_control","tags":["linux"],"title":"为服务开启BBR加速","uri":"http://www.mingaccount.com/2019/05/%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AFbbr%E5%8A%A0%E9%80%9F/","year":"2019"},{"content":"","id":37,"section":"posts","summary":"","tags":["scala"],"title":"Scala基础类结构图","uri":"http://www.mingaccount.com/2019/05/scala%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE/","year":"2019"},{"content":"运算符的优先级由其第一个字符决定\n以下列出的字符按优先级从高到低的顺序排列\n (all letters) | ^ \u0026amp; \u0026lt; \u0026gt; = !   + -\n* / %\n(all other special characters)\n","id":38,"section":"posts","summary":"运算符的优先级由其第一个字符决定 以下列出的字符按优先级从高到低的顺序排列 (all letters) | ^ \u0026amp; \u0026lt; \u0026gt; = ! + - * / % (all other special characters)","tags":["scala"],"title":"Scala运算符优先顺序","uri":"http://www.mingaccount.com/2019/05/scala%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E9%A1%BA%E5%BA%8F/","year":"2019"},{"content":"判断用户上传文件的合法性仅仅通过后缀名是完全不够的，谁也不知道后缀名是否被更改，服务器保存一个不知道真实类型的文件有极大的风险。\n因此需要后台进行进一步的文件类型校验，这里有两种情况：\n　1）一般的文件类型例如：jpg、png、xlsx等等是有固定文件头的，提取出用户上传文件的文件头与固定文件头进行对比，就可以得到文件的准确类型。\n　2）文本文件：txt、csv等等。文本文件具有特殊性，文本头无明显标志。但是文本文件百分百具有业务特殊性。可以在对文本进行格式验证时，判断是否为目标类型；或者通过编码校验，看文本是否正确编码，是否有乱码存在（正确编辑的文件，不可能存在乱码），有第三方插件cpdetector可以检测当前文件的编码；最后还可以通过提供文件模板，固定文本文件的头尾等方式来进行校验。\n这里主要说明第一种情况，第二种文本情况根据业务具体环境不同，有不同的处理方式。\n文件类型枚举:\npackage com.uti.utilEnum;\rpublic enum FileTypeEnum {\rJPG(\u0026quot;ffd8ffe000104a464946\u0026quot;),\rPNG(\u0026quot;89504e470d0a1a0a0000\u0026quot;),\rGIF(\u0026quot;47494638396126026f01\u0026quot;),\rTIF(\u0026quot;49492a00227105008037\u0026quot;),\rBMP_1(\u0026quot;424d228c010000000000\u0026quot;),//16色位图(bmp)\rBMP_2(\u0026quot;424d8240090000000000\u0026quot;),//24位位图(bmp)\rBMP_3(\u0026quot;424d8e1b030000000000\u0026quot;),//256色位图(bmp)\rDWG(\u0026quot;41433130313500000000\u0026quot;),\rHTML(\u0026quot;3c21444f435459504520\u0026quot;),\rHTM(\u0026quot;3c21646f637479706520\u0026quot;),\rCSS(\u0026quot;48544d4c207b0d0a0942\u0026quot;),\rJS(\u0026quot;696b2e71623d696b2e71\u0026quot;),\rRTF(\u0026quot;7b5c727466315c616e73\u0026quot;),\rPSD(\u0026quot;38425053000100000000\u0026quot;),\rEML(\u0026quot;46726f6d3a203d3f6762\u0026quot;),\rDOC(\u0026quot;d0cf11e0a1b11ae10000\u0026quot;),\rVSD(\u0026quot;d0cf11e0a1b11ae10000\u0026quot;),\rMDB(\u0026quot;5374616E64617264204A\u0026quot;),\rPS(\u0026quot;252150532D41646F6265\u0026quot;),\rPDF(\u0026quot;255044462d312e350d0a\u0026quot;),\rRMVB(\u0026quot;2e524d46000000120001\u0026quot;),\rRM(\u0026quot;2e524d46000000120001\u0026quot;),\rFLV(\u0026quot;464c5601050000000900\u0026quot;),\rF4V(\u0026quot;464c5601050000000900\u0026quot;),\rMP4(\u0026quot;00000020667479706d70\u0026quot;),\rMP3(\u0026quot;49443303000000002176\u0026quot;),\rMPG(\u0026quot;000001ba210001000180\u0026quot;),\rWMV(\u0026quot;3026b2758e66cf11a6d9\u0026quot;),\rASF(\u0026quot;3026b2758e66cf11a6d9\u0026quot;),\rWAV(\u0026quot;52494646e27807005741\u0026quot;),\rAVI(\u0026quot;52494646d07d60074156\u0026quot;),\rMID(\u0026quot;4d546864000000060001\u0026quot;),\rZIP(\u0026quot;504b0304140000000800\u0026quot;),\rRAR(\u0026quot;526172211a0700cf9073\u0026quot;),\rINI(\u0026quot;235468697320636f6e66\u0026quot;),\rJAR(\u0026quot;504b03040a0000000000\u0026quot;),\rEXE(\u0026quot;4d5a9000030000000400\u0026quot;),\rJSP(\u0026quot;3c25402070616765206c\u0026quot;),\rMF(\u0026quot;4d616e69666573742d56\u0026quot;),\rXML(\u0026quot;3c3f786d6c2076657273\u0026quot;),\rSQL(\u0026quot;494e5345525420494e54\u0026quot;),\rJAVA(\u0026quot;7061636b616765207765\u0026quot;),\rBAT(\u0026quot;406563686f206f66660d\u0026quot;),\rGZ(\u0026quot;1f8b0800000000000000\u0026quot;),\rPROPERTIES(\u0026quot;6c6f67346a2e726f6f74\u0026quot;),\rCLASS(\u0026quot;cafebabe0000002e0041\u0026quot;),\rCHM(\u0026quot;49545346030000006000\u0026quot;),\rMXP(\u0026quot;04000000010000001300\u0026quot;),\rDOCX(\u0026quot;504b0304140006000800\u0026quot;),\rWPS(\u0026quot;d0cf11e0a1b11ae10000\u0026quot;),\rTORRENT(\u0026quot;6431303a637265617465\u0026quot;),\rMOV(\u0026quot;6D6F6F76\u0026quot;),\rWPD(\u0026quot;FF575043\u0026quot;),\rDBX(\u0026quot;CFAD12FEC5FD746F\u0026quot;),\rPST(\u0026quot;2142444E\u0026quot;),\rQDF(\u0026quot;AC9EBD8F\u0026quot;),\rPWL(\u0026quot;E3828596\u0026quot;),\rRAM(\u0026quot;2E7261FD\u0026quot;);\rprivate String value = \u0026quot;\u0026quot;;\rprivate FileTypeEnum(String value) {\rthis.value = value;\r}\rpublic String getValue() {\rreturn value;\r}\rpublic void setValue(String value) {\rthis.value = value;\r}\r}\r 具体代码:\nprivate boolean notTextFileTypeCheck(InputStream inputStream, String specifiedType) throws IOException {\rboolean fileTypeIsVaild = false;\rbyte[] buffer = new byte[10];\rinputStream.read(buffer);\r//获取当前文件的真实类型\rString curfileType = getTrueFileType(bytesToHexFileTypeString(buffer));\r//指定文件类型中是否匹配当前文件类型\rif(specifiedType.toUpperCase().equals(curfileType)){\rfileTypeIsVaild = true;\r}\rreturn fileTypeIsVaild;\r}\rprivate String getTrueFileType(String s) {\rfor (FileTypeEnum fileTypeEnum : FileTypeEnum.values()) {\rif (s.startsWith(fileTypeEnum.getValue())) {\rreturn fileTypeEnum.toString();\r}\r}\rreturn null;\r}\rprivate String bytesToHexFileTypeString(byte[] buffer) {\rStringBuilder hexFileTypeStr = new StringBuilder();\rfor (byte b : buffer) {\rString hexString = Integer.toHexString(b \u0026amp; 0xFF);\rif (hexString.length() \u0026lt; 2) {\rhexFileTypeStr.append(\u0026quot;0\u0026quot;);\r}\rhexFileTypeStr.append(hexString);\r}\rreturn hexFileTypeStr.toString();\r}\r 关于为什么要\u0026amp;0xFF，推荐一篇文章https://www.cnblogs.com/think-in-java/p/5527389.html，加上评论更好理解，还能回顾下“原码反码补码”的知识\n","id":39,"section":"posts","summary":"判断用户上传文件的合法性仅仅通过后缀名是完全不够的，谁也不知道后缀名是否被更改，服务器保存一个不知道真实类型的文件有极大的风险。 因此需要后台","tags":["java"],"title":"Java上传文件格式判断","uri":"http://www.mingaccount.com/2019/03/java%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%A4%E6%96%AD/","year":"2019"},{"content":"最大公约数： @tailrec\rdef gcd(a: Int, b: Int): Int =\rif (b == 0) a else gcd(b, a % b)\r 阶乘: def factorial(n: Int): Int = {\r@tailrec\rdef iter(x: Int, result: Int): Int =\rif (x == 0) result else iter(x - 1, result * x)\riter(n, 1)\r}\r @tailrec注解可以检测当前递归方法是否满足尾递归，不满足会报编译错误\n","id":40,"section":"posts","summary":"最大公约数： @tailrec def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) 阶乘: def factorial(n: Int): Int = { @tailrec def iter(x: Int, result: Int): Int = if (x == 0) result else iter(x - 1, result * x) iter(n, 1) } @tailrec注解可以检测","tags":["scala"],"title":"Scala实现的尾递归","uri":"http://www.mingaccount.com/2019/02/scala%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92/","year":"2019"},{"content":"markdown语法大多数符号需要加一个空格和正式内容区分开才会生效   横线  -\u0026ndash; *** ___   标题  # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题   文本  文本块，在文本行开头加一个tab缩进 文字高亮，用符号`包裹文本 文本换行，行末尾加两个空格 文字斜体*斜体* _斜体_ 文字粗体**粗体** __粗体__ 删除线 ~~删除线~~ 斜粗体 ***斜粗体*** ___斜粗体___ 斜粗体删除线 ***~~斜粗体删除线***~~ 图片，![alt](URL \u0026quot;title\u0026quot;) 外部链接 [链接名称](www.baidu.com)也可以链接本地文件 锚点 [回到顶部](#top) top代表任意标题，注意都是小写 空格 \u0026amp;nbsp;   列表  无序列表 一段文本前加符号*或者- 多级无序列表，下一级只需要在无序列表前加一个缩进 有序列表 一段文本前加数字和. 类似1. 多级有序列表，下一级只需要在有序列表前加一个缩进 复选框列表 [ ]未勾选 [x]已勾选 位于列头需要加-和空格- [ ]   块引用  \u0026gt; 引用块 块有多级引用\u0026gt;\u0026gt; 第二级引用 \u0026gt;\u0026gt;\u0026gt; 第三季引用\u0026hellip;\u0026hellip;   表格  格式:\r|表头1|表头2|\r|---|---|\r|表格单元|表格单元|\r|表格单元|表格单元|\r对齐：\r调整第二行的斜线\r:---是左对齐\r---:是右对齐\r:---:是居中\r|左对齐|居中|右对齐|\r|:---|:---:|---:|\r|表格单元|表格单元|表格单元|\r表格内容：\r表格中也可以用文本加粗，文本高亮等文本效果。同时也可以插入图片和链接\r ","id":41,"section":"posts","summary":"markdown语法大多数符号需要加一个空格和正式内容区分开才会生效 横线 -\u0026ndash; *** ___ 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标","tags":["markdown"],"title":"Markdown常用语法备忘","uri":"http://www.mingaccount.com/2019/01/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98/","year":"2019"},{"content":"1.大型网站的特点： 　相比传统企业应用系统，大型互联网应用系统有以下特点：\n 高并发、大流量：需要面对高并发用户，大流量访问。 高可用：系统需要7*24小时不间断服务。 海量数据：需要储存、管理海量数据，需要使用大量服务器。 用户分布广泛，网络情况复杂。 安全环境恶劣：黑客攻击。 需求快速变更，发布频繁。 渐进式发展：大型互联网几乎都是从小网站发展起来的，不像传统行业一开始需求就相对固定。 那么大型网站是如何做到高可用、高性能、易扩展、可伸缩且安全的网站，又是怎样演变的了？  2.大型网站架构的演化发展历程 2.1 初始化阶段的网站架构 应用程序、数据库、和用户上传的文件等所有的资源都是在一台服务器上。\n2.2 应用服务和数据服务分离 随着网站用户的增加，不断增加的访问数量，和大量的文件储存，一台服务器已经不能满足需求，这时就需要分离应用和数据。\n分离后整个网站使用三台服务器：应用服务器、文件服务器、数据库服务器。\n三台服务器对硬件的要求不同：\n 应用服务器需要处理大量业务逻辑，需要更好的cpu； 数据库服务器需要快速检索磁盘和数据缓存，因此需要更快的硬盘和更大的内存； 文件服务器需要储存大量用户上传的文件，因此需要更大的硬盘。  2.3 使用缓存改善网站性能 随着用户进一步增加，数据库压力太大导致访问延迟。而大部分数据的访问，总是集中在某些热点数据上，例如淘宝商品访问，总是集中在评价最高的商品上。\n那么我们可以将这一部分热点数据，缓存到内存中，以减少数据库的访问压力。\n网站可使用的缓存分为两种：\n 本地缓存：缓存在应用服务器上，访问速度快，但受应用服务器的内存限制。 远程缓存：缓存在专门的分布式缓存服务器上，理论上不受内存容量限制。  2.4 使用应用服务器集群改善网站的并发处理能力 使用缓存后，数据库的压力得到有效缓解，但单个应用服务器能处理的请求连接有限，在访问高峰期，应用服务器成为整个网站的瓶颈。\n单一应用服务器性能是有上限的，这种情况下，更好的方式是多个服务器的集群来分担原有服务器的访问及储存压力，从而实现系统的可伸缩性。\n应用服务器集群搭建后，通过负载均衡调度服务器，将请求分发到集中中任何一台机器上。\n2.5 数据库读写分离 网站使用缓存后，绝大部分数据都可以从缓存中获取，但在部分情况下任然需要访问数据库：\n 缓存未命中（请求未能从缓存系统中找到匹配的缓存） 缓存过期 全部写操作 虽然只有部分情况才会访问数据库，但当用户基数不断增大，数据库也会不堪重负。  这种情况下，可以通过读写分离，来减轻数据库的压力。\n目前大部分主流数据库都支持主从热备（双机热备），通过设定两台数据库的主从关系，可以将一台数据库服务器的数据同步更新到另一台服务器上，网站利用数据库的这个功能来实现读写分离。\n在写数据时访问主数据库，同时主数据库同步数据到从数据库，在读取数据时，就可以访问从数据库，同时还需要一个数据访问模块，让读写分离对应用程序透明，减少代码依赖。\n2.6 使用反向代理和CDN加速网站响应 随着网站规模的扩大，用户可能分布在全国各地，不同地方的网络环境不同，要保证响应速度，就需要加速网站的访问速度。\n主要的加速手段：\n CDN 反向代理  这两种方式都基于缓存，不同点在于：\n CDN部署在网络提供商的机房，用户在请求数据时，可以从离自己最近的网络提供商出获取数据。 反向代理部署在网站中心机房，用户在请求数据时，首先访问的时反响代理服务器，如果缓存着用户请求的资源，就直接将缓存返回给用户。  2.7 使用分布式文件系统和分布式数据库系统 数据库经过读写分离，拆分为两台服务器，但是随着网站发展任然不能满足需求，文件服务器也是一样。\n这时就需要分布式的数据库系统和文件系统。\n分布式数据库是网站数据库拆分的最后手段，只有在单表数据非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同的业务的数据库部署在不同的服务器上。\n2.8 使用NoSQL和搜索引擎 随着网站业务越来越复杂，对数据库储存和检索的需求也越来越复杂，网站需要采取一些非关系型数据库技术如NoSQL和非数据库查询技术如搜索引擎。\nNoSQL和搜索引擎，对可伸缩的分布式系统有很好的支持。面对如此多的数据源，应用服务器通过统一的数据访问模块来访问不同的数据源。\n2.9 业务拆分 大型网站面对日益复杂的业务场景，根据产品线划分，可以将一个网站拆成多个应用，每个应用都独立部署维护。\n每个应用之间的数据关联有如下几种方式：\n 通过访问同一个数据储存系统(最常用)。 通过超链接建立关系。 通过消息队列进行数据分发。  2.10 分布式服务 随着业务拆分越来越细，应用系统越来越复杂，并且由于所有应用要和所有数据库连接，在数万台服务器规模的网站中，会导致数据库连接资源不足，拒绝服务。\n应用系统中有许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些相同的业务提取出来独立部署，由这些可复用的业务连接数据库，通过分布式服务调用共用业务服务完成具体操作。\n*本文是《大型网站技术架构 核心原理与案例分析》的章节总结\n","id":42,"section":"posts","summary":"1.大型网站的特点： 相比传统企业应用系统，大型互联网应用系统有以下特点： 高并发、大流量：需要面对高并发用户，大流量访问。 高可用：系统需要7*","tags":["website build"],"title":"大型网站架构演化概论","uri":"http://www.mingaccount.com/2018/09/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96%E6%A6%82%E8%AE%BA/","year":"2018"},{"content":"Java8函数式编程的加入彻底改变了游戏规则。对Java开发者来说这是一个全新的世界，我们也需要做出相应的改变。\n在这篇文章中我们将找寻传统循环代码的可替代方案。Java8的函数式编程特性改变了编程思路，从 “我们怎样去做” 变成了 “我们想做什么” 。\n这也是传统循环的缺点。当然传统循环更加的灵活，但其灵活性并不能掩盖他的问题。\nreturn、break、continue能直接改变循环的执行流程，强迫我们不仅要理解业务逻辑，同时也要了解循环是怎样工作的。\nJava8通过引入stream指令，我们可以在集合上使用强大的函数式操作。现在我们来看看怎样将传统循环转变为更简洁，更具有可读性的代码。\n这里将会创建一个Article类，他有三个成员变量：title、author、tags：\nprivate class Article {\rprivate final String title;\rprivate final String author;\rprivate final List\u0026lt;String\u0026gt; tags;\rprivate Article(String title, String author, List\u0026lt;String\u0026gt; tags) {\rthis.title = title;\rthis.author = author;\rthis.tags = tags;\r}\rpublic String getTitle() {\rreturn title;\r}\rpublic String getAuthor() {\rreturn author;\r}\rpublic List\u0026lt;String\u0026gt; getTags() {\rreturn tags;\r}\r}\r 每个例子都会包括一个传统循环的解决方案，和Java8函数式编程的解决方案。\n在第一个例子里面，将会在Article集合中寻找tag包含\u0026quot;Java\u0026quot;的第一个对象：\n传统循环的解决方案：\npublic Article getFirstJavaArticle(){\rfor(Article article : articles){\rif(article.getTags().contains(\u0026quot;Java\u0026quot;)){\rreturn article;\r}\r}\rreturn null;\r}\r Java8的解决方案：\npublic Optional\u0026lt;String\u0026gt; getFirstJavaArticle(){\rreturn articles.stream().filter(article -\u0026gt; article.getTags.contains(\u0026quot;Java\u0026quot;)).findFirst(); }\r 首先我们使用filter操作找到所有符合条件的Article，然后调用findFirst()方法得到第一个。\n因为stream是惰性的而且filter返回了一个stream，因此方法只有在找到第一个匹配时才会去处理这个元素。\n现在让我们尝试获取所有匹配的元素。\n传统循环解决方案：\npublic List\u0026lt;Article\u0026gt; getAllJavaArticles() {\rList\u0026lt;Article\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\rfor (Article article : articles) {\rif (article.getTags().contains(\u0026quot;Java\u0026quot;)) {\rresult.add(article);\r}\r}\rreturn result;\r}\r Java8解决方案：\npublic List\u0026lt;Article\u0026gt; getAllJavaArticles() {\rreturn articles.stream().filter(article -\u0026gt; article.getTags.contains(\u0026quot;Java\u0026quot;)).collect(Collectors.toList());\r}\r 在这个例子中我们使用了 collect 方法去筛选stream，而不是自己声明一个集合，并将匹配的参数追加到集合中。\n到目前为止都不错，现在是时候来展现 stream api真正的魅力了！\n让我们基于author将articles进行分组。\n传统循环解决方案：\npublic Map\u0026lt;String,List\u0026lt;Article\u0026gt;\u0026gt; groupByAuthor(){\rMap\u0026lt;String,List\u0026lt;Article\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;();\rfor(Article article : articles){\rif(result.containsKey(article.getAuthor)){\rresult.get(article.getAuthor).add(article);\r}else{\rArrayList\u0026lt;Article\u0026gt; articles = new ArrayList\u0026lt;\u0026gt;();\rarticles.add(article);\rresult.put(article.getAuthor(), articles);\r}\r} }\r Java8解决方案：\npublic Map\u0026lt;String, List\u0026lt;Article\u0026gt;\u0026gt; groupByAuthor() {\rreturn articles.stream().collect(Collectors.groupingBy(Article::getAuthor));\r}\r 通过使用groupingBy操作和getAuthor的方法引用，我们得到了整洁并且可读性高的代码。\n现在，让我们在集合中找到Article所有的不重复的tags。\n首先时传统循环方案：\npublic Set\u0026lt;String\u0026gt; getDistinctTags(){\rSet\u0026lt;String\u0026gt; result = new HashSet\u0026lt;\u0026gt;();\rfor(Article article : articles){\rresult.addAll(article.getTags());\r}\rreturn result; }\r Java8解决方案：\npublic Set\u0026lt;String\u0026gt; getDistinctTags(){\rreturn articles.stream().flatMap(article -\u0026gt; article.getTags().stream()).collect(Collectors.toSet());\r}\r flatMap帮助我们获取结果流中的tag集合，然后用collect方法创建一个Set并返回结果。\n函数式编程拥有无限的可能，这四个例子的目的是怎样将循环替换成更可读的代码。你应该仔细查看stream API，因为相比api这文章仅仅只是皮毛而已。\n*英文链接：deadCodeRising\n*原创译文\n","id":43,"section":"posts","summary":"Java8函数式编程的加入彻底改变了游戏规则。对Java开发者来说这是一个全新的世界，我们也需要做出相应的改变。 在这篇文章中我们将找寻传统循","tags":["java"],"title":"[译]Java8：循环与函数式编程","uri":"http://www.mingaccount.com/2018/08/%E8%AF%91java8%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","year":"2018"},{"content":"Java8引入了 java.util.function 包，他包含了函数式接口，具体的描述在以下api说明文档中：\n函数式接口为lambda表达式和方法引用提供目标类型。每个函数式接口有一个单独的抽象方法，被称为函数式接口的函数方法，lambda表达式的参数和返回类型与之匹配或适应。\r 在这篇文章中，将着重介绍function包40个接口中的4个：\nPredicate 代表有一个参数的断言(boolean值的函数)\r Predicate 接口允许我们创建一个基于给定参数并返回一个boolean值的lambda表达式。让我们创建一个Predicate来测试一个Person是否为成年人。\nPredicate\u0026lt;Integer\u0026gt; isAnAdult = age -\u0026gt; age \u0026gt;= 18;\r 这里对于stream的filter方法的使用，让Predicate接口作为一个参数。所以我们实际上能够在stream中使用我们的Predicate接口。\nPredicate\u0026lt;Person\u0026gt; isAnAdult = person -\u0026gt; person.getAge() \u0026gt;= 18;\rList\u0026lt;Person\u0026gt; people = getAllPeople();\rInteger numOfAdult = people.stream().filter(isAnAdult).count();\r Consumer 代表一个接受单个参数输入而不返回任何结果的操作。不像大多数其他的函数式接口，Customer预期是通过副作用进行操作。\r Consumer\u0026lt;Ticket\u0026gt; ticketPrinter = ticket -\u0026gt; ticket.print();\r Iterable接口带来的全新forEach方法可以将Consumer作为一个参数，让我们用forEach方法将上面创建的ticketPrinter操作组合在一个Collection上：\nConsumer\u0026lt;Ticket\u0026gt; ticketPrinter = ticket -\u0026gt; ticket.print();\rCollection\u0026lt;Ticket\u0026gt; tickets = getTicketsToPrint();\rtickets.forEach(ticketPrinter);\r 现在，让我们简化一下代码，通过把Consumer直接放进forEach方法中：\nCollection\u0026lt;Ticket\u0026gt; tickets = getTicketsToPrint();\rtickets.forEach(ticket -\u0026gt; ticket.print());\r Supplier 表示结果供应\r 这是工厂的一种，他没有参数，只是返回给你一个结果。非常适合返回一个实例。\nSupplier\u0026lt;TicketHandler\u0026gt; ticketHandlerCreator = () -\u0026gt; new TicketHandler();\r 另一种方案是使用构造方法引用。\nSupplier\u0026lt;TicketHandler\u0026gt; ticketCreator = TicketHandler::new;\r Function\u0026lt;T,R\u0026gt; 表示一个方法接收一个参数然后产出一个结果\r 让我们直接看一个例子：\nFunction\u0026lt;String,Predicate\u0026lt;Ticket\u0026gt;\u0026gt; ticketFor = event -\u0026gt; ticket -\u0026gt; event.equals(ticket.getName());\rList\u0026lt;Ticket\u0026gt; tickets = getAllTickets();\rInteger soldTicketsForCoolEvent = tickets.stream().filter(ticketFor.apply(\u0026quot;CoolEvent\u0026quot;)).count();\r 我们创建了一个以event字符串作为参数的Function，他会返回一个Predicate。参数会被传给Predicate，并与event字符串作比较。然后我们在stream中使用function去计算ticket name为\u0026quot;CoolEvent\u0026quot;的数量\n*英文链接：deadCodeRising\n*原创译文\n","id":44,"section":"posts","summary":"Java8引入了 java.util.function 包，他包含了函数式接口，具体的描述在以下api说明文档中： 函数式接口为lambda表达式和方法引用提供目标类型。每个函数式","tags":["java"],"title":"[译]Java8的函数式接口","uri":"http://www.mingaccount.com/2018/08/%E8%AF%91java8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","year":"2018"},{"content":"在开发代码中，有一段需要获取resources目录下的一个配置文件（这里写作test.xml）。\n这段代码在ide中没有任何问题，但是一打成jar包发布到线上，这段代码就会报找不到对应文件的错误。\n按照一般的思路，因为resources目录下的文件经过编译后都会放在classpath根目录下，所以获取到根目录然后追加test.xml即可得到该文件路径。这是尝试获取路径失败的代码：\n//直接获取目标文件路径\rString filePath = this.getClass.getClassLoader().getResource(\u0026quot;text.xml\u0026quot;).getPath;\r//获取根目录路径1\rString rootPath = this.getClass.getClassLoader().getResource(\u0026quot;\u0026quot;).getPath;\r//获取根目录路径2\rString rootPath2 = ResourceUtils.getURL(\u0026quot;classpath:\u0026quot;).getPath();\r 通过以上代码获取到的路径在spring boot项目作为jar包运行时，得到的并不是真实的路径，而是如下的一个路径：\nworkspace/project/target/project.jar!/BOOT-INF/classes!/...\r spring提供了ClassPathResource类处理这种情况，通过ClassPathResource可以直接获取File对象，或者InputStream，这是获取成功的代码：\nResource resource = new ClassPathResource(\u0026quot;text.xml\u0026quot;);\rresource.getFile();\rresource.getInputStream();\r ","id":45,"section":"posts","summary":"在开发代码中，有一段需要获取resources目录下的一个配置文件（这里写作test.xml）。 这段代码在ide中没有任何问题，但是一打成j","tags":["spring"],"title":"Spring boot 文件路径读取异常","uri":"http://www.mingaccount.com/2018/08/springboot%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E8%AF%BB%E5%8F%96%E5%BC%82%E5%B8%B8/","year":"2018"},{"content":"文档查看和修改 cd - #查看上一次所在的目录\rcat /etc/hosts #文档查看\rls #查看当前目录下所有文件\rpwd #查看当前目录的绝对路径\rll #查看目录下文件的详细信息，包括权限属组等信息\rfind / -name web.xml #查看名字为web.xml的文件，需要等待片刻\rfind .|xargs grep -rl \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名\rfind .|xargs grep -r \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名，并展示命中行\rfind .|xargs grep -rn \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名，并展示行号\rfind .|xargs grep -rn1 \u0026quot;google.com\u0026quot; #搜索当前目录文件内容并返回文件名，并展示上下文内容\rmkdir -p #创建文件夹\rcat [目录1] \u0026gt;\u0026gt; [目录2] #把目录1的文件内容输入到目录2中 chmod a+x filename #让执行文件能被./filename调用\rmv #文件移动或者重命名\r 修改系统配置 vi /etc/hosts #HOST修改需重启\rvi /etc/resolv.conf #DNS修改即时生效\rvi /etc/sysconfig/network-scripts/ifcfg-eth0 #IP修改需重启\rcat /etc/os-release #查看当前系统版本信息\runset #删除对应的环境变量\r 网络相关 nslookup [ip/域名] #通过域名查找ip和dns，或者通过ip查找域名\rwget 域名 #通过指定域名下载文件到当前目录\rscp -r ~/data root@127.0.0.1:~/data #指定服务上传 scp -r root@127.0.0.1:~/data ~/data #指定服务下载\r 后台进程 ctrl+z #进程暂停\rctrl+c #进程终止\rfg [JobID] #将后台进程移到前台处理，不设置id，将显示最后一个暂停的进程\rbg [JobID] #将进程放到后台处理\rjobs [选项] [JobID] #该命令生效之前需执行find / -name password \u0026amp;\r#-l显示进程\r#-p仅显示任务对应的进程号\r#-r仅输出运行状态的任务 #-s仅输出停止状态的任务\r 启动重启相关 reboot\r#-d重新开机时不把数据写入记录文件/var/tmp/wtmp。具有-n效果\r#-f强制重新开机，不调用shutdow指令\r#-i重新开机之前，关闭所有网络界面\r#-n重新开机之前不检查是否有程序未结束\r#-w仅做测试，不真正重启，只会在/var/log/wtmp写入记录\r 用户权限相关 su - [用户名] #完全切换到指定用户，需要指定用户的密码\rsudo -i #暂时切换到root账户，logout命令可退出root，需要sudoers权限\rsudo passwd root #设置root密码　sudo useradd -m hadoop -s /bin/bash #添加用户\rsudo adduser hadoop sudo #给用户追加管理员权限\r 数据指标相关 top #表示1分钟，5分钟，15分钟的运行队列平均进程数\rwhile true;do ps -u your-user-name -L | wc -l;sleep 1;done #查看当前用户开启的线程数\rulimit -u #查看当前用户所能开启的线程数\r 软件安装相关 echo $JAVA_HOME #查询环境变量\rwhich java #获取java执行路径\rls -lrt /usr/bin/java #查找安装路径\rsudo tar -zxf 压缩包目录 -C 目标解压目录 #文件解压\rsudo chown -R [userName] [filePath] #更改文件及其所有子文件的所有者权限\runzip #解压zip文件\rvi /etc/apt/sources.list #编辑环境变量\rdpkg *.deb #ubuntu体系加载软件包命令\r 进程相关\njps #查看当前所有的java进程，并显示进程id\r 安全相关\nssh-keygen #生成SSH key\r ","id":46,"section":"posts","summary":"文档查看和修改 cd - #查看上一次所在的目录 cat /etc/hosts #文档查看 ls #查看当前目录下所有文件 pwd #查看当前目录的绝对路径 ll #查看目录下文件的详细信息，包括","tags":["linux"],"title":"Linux常用命令备忘","uri":"http://www.mingaccount.com/2018/08/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/","year":"2018"},{"content":"vi /etc/hosts\ni 修改模式\resc　退出修改\r:q　正常退出(文件没有修改\r:q!　不保存退出\r:wq 保存退出\rG　跳到末尾行\rdd　删除当前行\rgg　跳到第一行第一个字符\r$　跳到当前行的最后一个字符\ro　在当前行之后插入一个新行\r/搜索内容　搜索指定内容\r:122　跳转到指定行\r:%d 删除所有内容\rdG 删除当前光标以下的所有内容 ","id":47,"section":"posts","summary":"vi /etc/hosts i 修改模式 esc 退出修改 :q 正常退出(文件没有修改 :q! 不保存退出 :wq 保存退出 G 跳到末尾行 dd 删除当前行 gg 跳到第一行第一个字符 $ 跳到当前行的最后一个字","tags":["linux"],"title":"vim命令备忘","uri":"http://www.mingaccount.com/2018/08/vim%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/","year":"2018"},{"content":"开启定时任务  @Configuration\r@EnableScheduling\r@ComponentScan(basePackages=\u0026quot;com.myco.tasks\u0026quot;)\rpublic class AppConfig {\r}\r 如果需要对定时任务的生命周期有其他的操作，可以实现接口SchedulingConfigurer\n@Configuration\r@EnableScheduling\rpublic class AppConfig implements SchedulingConfigurer {\r@Override\rpublic void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\rtaskRegistrar.setScheduler(taskScheduler());\rtaskRegistrar.addTriggerTask(\rnew Runnable() {\rpublic void run() {\rmyTask().work();\r}\r},\rnew CustomTrigger()\r);\r}\r@Bean(destroyMethod=\u0026quot;shutdown\u0026quot;)\rpublic Executor taskScheduler() {\rreturn Executors.newScheduledThreadPool(42);\r}\r@Bean\rpublic MyTask myTask() {\rreturn new MyTask();\r}\r}\r  详细信息参考 @EnableScheduling注解官方API\n 配置定时任务 package com.myco.tasks;\r@Component\rpublic class MyTask {\r@Scheduled(fixedRate=1000)\rpublic void work() {\r// task execution logic\r}\r}\r 注解@Scheduled有如下参数\n cron 输入cron表达式 fixedDelay 在最后一个任务执行完后，下个任务开始执行的间隔时间 fixedRate 最后一个任务开始执行后，下个任务开始执行的间隔时间 initialDelay 第一个任务执行前的延迟时间 zone 时区   详细信息参考 @Scheduled注解官方API\n ","id":48,"section":"posts","summary":"开启定时任务 @Configuration @EnableScheduling @ComponentScan(basePackages=\u0026quot;com.myco.tasks\u0026quot;) public class AppConfig { } 如果需要对定时任务的生命周期有其他的操作，可以实现接口SchedulingConfigurer @Configuration @EnableScheduling public class AppConfig implements SchedulingConfigurer { @Override","tags":["spring"],"title":"SpringBoot定时任务","uri":"http://www.mingaccount.com/2018/08/springboot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","year":"2018"},{"content":"本篇文章着重整理什么是静态化系统架构，以及静态化架构的几种方案。\n首先先贴一个淘宝系统升级的历程(09~13)：\n 09年，系统拆分，静态文件合并，前端页面异步化和json化。 10年，去DB依赖、引入缓存、提升单机QPS、关注用户体验。 11年，优化进入深水区Velocity、BigPipe。 12年，静态化改造。 13年统一Cache、CDN化、网络协议。  一、什么是静态化架构，为什么需要它 静态化架构系统通常有几个特征：\n 一个URL标识一个唯一的页面。 页面不包含cookie等私有数据，即用户信息，时间，地点等。  当出现高并发问题，一般情况下首先想到的是优化java程序，但java程序本身是有瓶颈的，并且他也存在不擅长处理大量连接请求，每个连接消耗内存较多，Servlet容器解析HTTP较慢等问题，那要怎样跳出Java来进行优化了？\n以下是静态话化架构的处理方式：\n 首先分离页面静态内容，页面内容并不是所有都需要从后台获取，将必须后台处理的分离出去，留下不受用户信息影响的静态的页面内容。 改变静态内容缓存的位置，不再缓存到java层面，直接在Web服务器上做缓存（Nginx,Apache,Varnish）； 分离出的动态内容Json化，以便复用。获取动态内容有两种方式ESI、CSI  ESI：在Web服务器上做动态内容请求，并将动态内容插入到静态页面，用户拿到的是一个完整的页面，用户体验好，服务器压力较大。 CSI：通过JS直接发送动态内容请求，用户体验差，服务器压力小。    二、静态化架构的几种方案 首先是静态化方案需要考虑的几个问题：\n 是否一致性Hash分组？做缓存一定是和命中率紧密相关的，命中率和数据的集中度相关，而要让数据集中一致性Hash就是一个必然选择。但是一致性Hash有一个天然的缺陷就是会导致热点问题，当热点特别集中时可能会导致网络瓶颈。 是否使用ESI?ESI对性能有影响，但是他对客户端友好，前端编程也方便。 是否使用物理机？物理机可以提供更大的内存、更好的CPU资源，但是使用物理机也有一些缺点，例如会导致应用集群的相对集中，进而导致网络风险增加。另外对Java系统而言内存增加并不能带来那么大的好处。 谁来压缩、在哪里压缩也是让人比较纠结的问题，增加一层Cache，必然增加了数据的传输，那么谁来压缩就会影响到Cache的容量和网络数据的传输量就。 网卡选择？网卡选择其实是个成本问题，避免网络瓶颈可以选择万兆网卡和交换机，但是必然成本增加。  方案1.采用Nginx+Cache+Java结构的虚拟机单机部署 这种方案是最简单的静态化方案，只需要在静态化改造的基础上，在前面的架构上加一层Cach就行，他的优缺点如下：\n优点：\n 没有网络瓶颈，不需要改造网络； 机器增加，也没有网卡瓶颈； 机器数增多，故障风险减少。  缺点:\n 机器增加，缓存命中率下降； 缓存分散，失效功能难度增加； Cache和JBoss都会争抢内存；  该方案虽然比较简单，但也能够解决热点商品的访问问题，例如做大促时，商品数比较少，在有限内存中任然能够命中这些商品；另外针对一些恶意攻击也十分有效，这是的命中率能达到90%以上，但是对系统的整体性能没有很多提升。\n方案2.采用Nginx+Cache+Java结构实体机单机部署 这种方案在前面的基础上将虚拟机改成实体机，增大Cache的内存，并且采用了一致性Hash分组的方式来提升命中率，这里将Cache分成若干组，这样就可以达到命中率和访问热点的平衡。\n优点：\n 既没有网络瓶颈，也能使用大内存； 减少Varnish机器，提升命中率； 提升命中率，能减少Gzip压缩； 减少Cache失效的压力。  这是一个比较理想的方案，在正常请求下也能达到50%左右的命中率，对一些基数数据比较小的系统如天猫Detail，命中率能达到80%左右，这样的命中率比较理想。\n方案3.统一Cache层 统一Cache层是个更理想的推广方案。\n将Cache层单独拿出来统一管理可以减少运维成本，同事也方便其他静态化系统接入。\n优点：\n 可以减少多个应用接入Cache的成本，接入的应用只维护自己的Java系统就好，不用单独维护Cache，只需关心如何使用，更好地让更多流量型系统接入使用。 统一Cache易于维护，例如后面加强监控、配置的自动化，统一维护、升级比较方便。 *可以共享内存，最大化利用内存，不同系统之间的内存可以动态切换，有效应对攻击情况。 更有助于安全防护。  三、如何解决失效问题 缓存的失效同样时静态化架构需要考虑的问题，这里采用主动失效和被动失效相结合的方式。\n被动失效\n　被动失效主要处理如模板变更和一些对时效性不是太敏感的数据的失效，采用设置Cache时间长度这种自动失效的方式，同时也要开发一个后台管理界面来用于手工失效某些Cache。\n主动失效\n　主动有如下几种：\n Cache失效中心监控数据库表变化，发送Purge失效请求； 装修时间戳比较失效装修内容； Java系统发布，清空Cache; Vm模板发布，清空Cache;\n其中主要使用第一个失效中心，这个失效中心通过监控数据库关键数据对应表的变更以发送Purge失效请求给Cache层来清除缓存数据。  四、服务端静态化方案的演进：CDN化 在静态化系统过后，还可以进一步优化，将Cache层前移到CDN（Content Delivery Network 内容分布网络，它会将用户的请求自动分配到最近的服务器进行处理，并且他会缓存网站的静态内容，加速网站的响应速度），因为CDN离用户最近，效果会更好。\n但是想要CDN化，存在几个问题需要解决：\n 失效问题。由于CDN分布在全国，要在秒级时间内失效这么广泛的Cache，对CDN的失效系统要求很高。 命中率问题。Cache最重要的一个指标就是要保证高命中率，不然Cache就失去了意义。同样，如果将数据全部放到全国的CDN上，Cache分散是必然的，Cache分散导致访问的请求命中到同一个请求的Cache降低，那么命中率就成为一个问题。 发布更新问题。作为一个业务系统，每周都有日常业务需要发布，所以发布系统是否简单、快速也是一个不可回避的问题，有问题快速回滚和问题排查的简便性也是要考虑的方面。  解决失效问题\n采用级联的失效结构，主动发Purge请求给Cache软件失效的方式，这种失效由失效中心将失效请求发送给每个CDN节点上的Console机，然后Concole机发送Purge请求给每台Cache机器。\n解决命中率问题\n现阶段把Cache放到全国所有的CDN节点上，现阶段是不太可能实现的，那么是否可以选择若干个节点来实施、尝试了？\n这样的节点需要满足以下几个条件：\n 靠近访问量比较集中的地区； 离主站相对较远； 节点到主站的网络比较好且稳定； 节点容量比较大，不会占用其他CDN太多的资源； 节点不要太多；  基于上面几个因素，选择CDN的二级Cache比较合适。\n使用CDN的二级Cache作为缓存，可以达到和前面服务端静态化Cache类似的命中率，因为节点数不多，Cache不是很分散，访问量也比较集中，这样也解决了命中率的问题，同时也提供给用户最好的访问体验，是在当前环境下比较理想的CDN化方案。\n*本文是《深入分析JAVA WEB技术内幕》一书的总结和节选\n","id":49,"section":"posts","summary":"本篇文章着重整理什么是静态化系统架构，以及静态化架构的几种方案。 首先先贴一个淘宝系统升级的历程(09~13)： 09年，系统拆分，静态文件合并","tags":["website build"],"title":"大浏览量系统的静态化架构设计","uri":"http://www.mingaccount.com/2018/08/%E5%A4%A7%E6%B5%8F%E8%A7%88%E9%87%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9D%99%E6%80%81%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","year":"2018"},{"content":"最近在开发中碰见一个问题，后端代码调用接口，在请求端参数没有任何问题，但是当接口接收到参数时，其中的加号全部变为了空格。\n在查阅资料后发现是URLDecoder方法的问题，以下是URLDecoder的文档说明：\nThe following rules are applied in the conversion:\n The alphanumeric characters \u0026ldquo;a\u0026rdquo; through \u0026ldquo;z\u0026rdquo;, \u0026ldquo;A\u0026rdquo; through \u0026ldquo;Z\u0026rdquo; and \u0026ldquo;0\u0026rdquo; through \u0026ldquo;9\u0026rdquo; remain the same. The special characters \u0026ldquo;.\u0026rdquo;, \u0026ldquo;-\u0026rdquo;, \u0026ldquo;*\u0026rdquo;, and \u0026ldquo;_\u0026rdquo; remain the same. The plus sign \u0026ldquo;+\u0026rdquo; is converted into a space character \u0026quot; \u0026quot; . A sequence of the form \u0026ldquo;%xy\u0026rdquo; will be treated as representing a byte where xy is the two-digit hexadecimal representation of the 8 bits. Then, all substrings that contain one or more of these byte sequences consecutively will be replaced by the character(s) whose encoding would result in those consecutive bytes. The encoding scheme used to decode these characters may be specified, or if unspecified, the default encoding of the platform will be used  文档中很明显，URLDecoder会将加号转变为空格，其他的符号\u0026rdquo;.\u0026rdquo;, \u0026ldquo;-\u0026rdquo;, \u0026ldquo;*\u0026rdquo;, \u0026ldquo;_\u0026ldquo;将保持不变。\nSpring mvc框架在给参数赋值的时候调用了URLDecoder，那要解决这个问题，需要在请求的时候对\u0026quot;+\u0026quot;做处理：\nString plusEncode = URLEncoder.encode(\u0026quot;+\u0026quot;, \u0026quot;UTF-8\u0026quot;); param = param.replaceAll(\u0026quot;\\\\+\u0026quot;, plusEncode);  这里在请求发送前，将加号用URLEcoder进行编码，并将参数json中的所有加号替换成编码后的字符。\n","id":50,"section":"posts","summary":"最近在开发中碰见一个问题，后端代码调用接口，在请求端参数没有任何问题，但是当接口接收到参数时，其中的加号全部变为了空格。 在查阅资料后发现是U","tags":["java"],"title":"请求参数中的+号为什么会丢失,如何保证参数完整","uri":"http://www.mingaccount.com/2018/08/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84-%E5%8F%B7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%A2%E5%A4%B1/","year":"2018"},{"content":"win10右键徽标-\u0026gt;Windows Powershell(管理员)\n dispark list disk 展示所有磁盘 select disk # 确认好所选目标磁盘，#号为id clean 删除选中磁盘的所有内容 exit  ","id":51,"section":"posts","summary":"win10右键徽标-\u0026gt;Windows Powershell(管理员) dispark list disk 展示所有磁盘 select disk # 确认好所选目标磁盘，#号为id clean 删除选中磁盘","tags":["windows"],"title":"Windows删除启动盘的所有分区","uri":"http://www.mingaccount.com/2018/07/windows%E5%88%A0%E9%99%A4%E5%90%AF%E5%8A%A8%E7%9B%98%E7%9A%84%E5%90%84%E7%A7%8D%E5%88%86%E5%8C%BA/","year":"2018"},{"content":"在阅读Venkat Subramaniam的著作《Functional Programming in Java》 之后，方法模式和lambda完美结合让我印象深刻。\n这种模式经常用作数据源处理，但也适用于类似的情况。这种模式可以让你集中注意力在核心功能点上，而不用担心类里面有过多重复的代码。\n这里创建了一个事务处理作为事例。\n接口 Transaction，他有一个执行方法。\nimport java.sql.Connection;\rimport java.sql.SQLException;\rpublic interface Transaction{\rpublic void execute(Connection connection) throws SQLException;\r}\r 这个接口代表我们想在事务中执行什么操作。这是一个 SAM(Single Abstract Method) 类型，意味着我们能够使用lambda表达式去实现他。\n然后我们轮到我们的主角登场，TransactionHandler。\nimport java.sql.Connection; import java.sql.DriverManager;\rpublic class TransactionHandler {\rpublic static void runInTransaction(Transaction transaction) throws Exception {\rConnection dbConnection = createDatabaseConnection();\rdbConnection.setAutoCommit(false);\rtry {\rSystem.out.println(\u0026quot;Starting transaction\u0026quot;);\rtransaction.execute(dbConnection);\rSystem.out.println(\u0026quot;Committing transaction\u0026quot;);\rdbConnection.commit();\r} catch (Exception e) {\rSystem.out.println(e.getMessage());\rSystem.out.println(\u0026quot;Rolling back...\u0026quot;);\rdbConnection.rollback();\r} finally {\rdbConnection.close();\r}\r}\rprivate static Connection createDatabaseConnection() throws Exception {\rClass.forName(\u0026quot;com.mysql.jdbc.Driver\u0026quot;);\rreturn DriverManager.getConnection(\u0026quot;jdbc:mysql://localhost:3306/ticket_system\u0026quot;, \u0026quot;user\u0026quot;, \u0026quot;password\u0026quot;);\r}\r}\r 他包含了一个静态方法,他的职责是运行我们的事务和在异常情况下回滚.\n我创建了一个简单的票务系统去展示TransactionHandler是怎么样和lambda一起工作的.\n首先是一个成功的事务:\n@Test\rpublic void testSuccessfulPurchase() throws Exception {\rTransactionHandler.runInTransaction(connection -\u0026gt; {\rint ticketId = findAvailableTicket(connection);\rreserveTicket(ticketId, connection);\rmarkAsBought(ticketId, connection);\r});\rassertEquals(getNrOfTicketsIn(TicketState.AVAILABLE), 9);\rassertEquals(getNrOfTicketsIn(TicketState.RESERVED), 0);\rassertEquals(getNrOfTicketsIn(TicketState.BOUGHT), 1);\r}\r 控制台输出:\nStarting transaction Reserving ticket with id 1 Marking ticket with id 1 as bought Committing transaction  然后是失败的事务:\n@Test\rpublic void testFailedPurchase() throws Exception {\rTransactionHandler.runInTransaction(connection -\u0026gt; {\rint ticketId = findAvailableTicket(connection);\rreserveTicket(ticketId, connection);\rthrow new IllegalStateException(\u0026quot;Not approved credit card\u0026quot;);\r});\rassertEquals(getNrOfTicketsIn(TicketState.AVAILABLE), 10);\rassertEquals(getNrOfTicketsIn(TicketState.RESERVED), 0);\rassertEquals(getNrOfTicketsIn(TicketState.BOUGHT), 0);\r}\r 这个测试预定了一张票,然后抛出异常,触发回滚取消预约;\n控制台输出:\nStarting transaction Reserving ticket with id 1 Not approved credit card Rolling back...  lambda表达式的处理方式是简洁优雅的，而匿名内部类需要创建类并实例化他，你不觉得他有些太罗嗦了吗?\n留意我们是如何使用lambda表达式作为一个工具去测试TransactionHandler的每个方面\n你能在这里找到完整的例子 GitHub\n*英文链接：deadCodeRising\n*原创译文\n","id":52,"section":"posts","summary":"在阅读Venkat Subramaniam的著作《Functional Programming in Java》 之后，方法模式和lambda完美结合让我印象深刻。 这种模式","tags":["java"],"title":"[译]lambda表达式对 SAM （单个抽象方法类）type的处理方式","uri":"http://www.mingaccount.com/2018/06/%E8%AF%91lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9-sam/","year":"2018"},{"content":"npm config set registry https://registry.npm.taobao.org  ","id":53,"section":"posts","summary":"npm config set registry https://registry.npm.taobao.org","tags":["npm"],"title":"Npm淘宝镜像","uri":"http://www.mingaccount.com/2018/06/npm%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F/","year":"2018"},{"content":"“JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性”\n一、类对象的获取 1.通过对象获取 Object obj = new Object();\robj.getClass();\r 2.通过类名获取 Object.class;\r 3.通过类的路径名获取 Class.forName(\u0026quot;com.metadata.Student\u0026quot;);\r 二、类的实例化和构造函数 获取到的class对象可以直接通过clazz.newInstance()方法实例化，但是需要目标类有默认无参构造函数，不然会抛出异常。\n在类没有默认无参构造函数，或者需要某个具体的构造函数来实例化的情况，需要通过Constructor类的newInstance()来完成。\n1.获取公有构造函数，不包括父类 //Class\rpublic Constructor\u0026lt;?\u0026gt;[] getConstructors() public Constructor\u0026lt;T\u0026gt; getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)\r 2.获取当前类构造函数，忽略修饰符 //Class\rpublic Constructor\u0026lt;?\u0026gt;[] getDeclaredConstructors()\rpublic Constructor\u0026lt;T\u0026gt; getDeclaredConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)\r 构造函数调用\n//Constructor\rpublic T newInstance(Object... initargs)\r//忽略修饰符，强制调用\rpublic void setAccessible(boolean flag)\r 三、类成员变量的获取 1.获取公有变量，包括父类 //Class\rpublic Field[] getFields()\rpublic Field getField(String name)\r 2.获取当前类成员变量，忽略修饰符 //Class\rpublic Field[] getDeclaredFields()\rpublic Field getDeclaredField(String name)\r 成员变量赋值\n//Field\r//obj为实例对象\rpublic void set(Object obj,Object value)\r//忽略修饰符，强制调用\rpublic void setAccessible(boolean flag)\r 四、类方法的获取 1.获取公有方法，包括父类 //Class\rpublic Method[] getMethods()\rpublic Method getMethod(String name,\rClass\u0026lt;?\u0026gt;... parameterTypes)\r 2.获取当前类方法，忽略修饰符 //Class\rpublic Method[] getDeclaredMethods()\rpublic Method getDeclaredMethod(String name,\rClass\u0026lt;?\u0026gt;... parameterTypes)\r 方法调用\n//Method\r//obj为类实例化对象，如果为静态方法obj为Null\rinvoke(Object obj, Object... args)\r//忽略修饰符，强制调用\rpublic void setAccessible(boolean flag)\r ","id":54,"section":"posts","summary":"“JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性” 一、类对","tags":["java"],"title":"Java反射常用API汇总","uri":"http://www.mingaccount.com/2018/06/java%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8api%E6%B1%87%E6%80%BB/","year":"2018"},{"content":"复杂密码才能通过\nsudo mysql -u root -p\rmysql\u0026gt; select user, plugin from mysql.user;\rmysql\u0026gt; update mysql.user set authentication_string=PASSWORD('xcvds_32GDS'), plugin='mysql_native_password' where user='root';\r mysql8.0不能用上边的语句：\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY \u0026quot;svewe_123\u0026quot;;\r ","id":55,"section":"posts","summary":"复杂密码才能通过 sudo mysql -u root -p mysql\u0026gt; select user, plugin from mysql.user; mysql\u0026gt; update mysql.user set authentication_string=PASSWORD('xcvds_32GDS'), plugin='mysql_native_password' where user='root'; mysql8.0不能用上边的语句： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY \u0026quot;svewe_123\u0026quot;;","tags":["mysql"],"title":"Mysql安装后root无法登陆(Access denied for user 'root'@'localhost')","uri":"http://www.mingaccount.com/2018/06/mysql%E5%AE%89%E8%A3%85%E5%90%8Eroot%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86/","year":"2018"},{"content":"avg函数对值为null的行，会忽略不计 解决方案\navg((coalesce(column,0))\r ","id":56,"section":"posts","summary":"avg函数对值为null的行，会忽略不计 解决方案 avg((coalesce(column,0))","tags":["mysql"],"title":"avg函数忽略null值","uri":"http://www.mingaccount.com/2018/06/avg%E5%87%BD%E6%95%B0%E5%BF%BD%E7%95%A5null%E5%80%BC/","year":"2018"},{"content":"Java8引入了函数式编程，他对java是一个极大的扩展。Java从此不在是一个单纯的面向对象语言，现在他同时混合了函数式编程。这是巨大的改变，需要我们调整面对对象的编程习惯，以适应这些变化。\n但是为什么我们需要去适应这些改变？为什么我们需要花费时间精力上手函数式编程而不是直接用面对对象解决问题？\n 函数式编程的引入，帮助我们减少业务逻辑和代码的分歧。他允许我们在更高层次更自然的描述业务逻辑。让代码直接描述“你想做什么”，而不是“你想怎样去做”。 许多样板（boilerplates）可以被移除，这会让代码更清晰更简洁。 高阶函数（Higher-order functions）允许我们：　 发送方法到其他方法中。 在其他方法中创建方法。 从其他方法中返回方法。    这对Java来说是一个巨大的胜利，我们需要发送，创建并返回对象来完成这项工作。我们将能创建更健壮，更集中并且更容易重用的代码。\n 多亏lambda表达式，现在我们可以实现惰性求值（lazy evalutions）。当发送lambda表达式作为一个方法的参数，Java编译器会在lambda表达式在方法中被调用时才计算他的值。这跟一般的方法参数被直接求职是不一样的。 lambda让单元测试变得更加有趣~他允许我们创建简洁，小巧和快速的轻量级单元测试。用lambda我们能够储存测试代码。他允许我们测试各种场景对代码的影响。 探索新的模式。 等等好处。 掌握新的函数式编程对于熟悉面对对象编程的开发者来说是一个挑战，但他应该是一个非常受欢迎的挑战。经过之前的的铺垫，我所要说的是你真的应该学习一门函数式编程语言。他会让你了解到他带来的可能性和能量。我认为这将帮助你在另一个层面了解函数式编程。  因此，掌握函数式编程，加上良好的面对对象思想，能够让你的代码更加牛b！\n*英文链接：deadCodeRising\n*原创译文\n","id":57,"section":"posts","summary":"Java8引入了函数式编程，他对java是一个极大的扩展。Java从此不在是一个单纯的面向对象语言，现在他同时混合了函数式编程。这是巨大的改","tags":["java"],"title":"[译]java8新特性：函数式编程（functional programming）的优点","uri":"http://www.mingaccount.com/2018/05/%E8%AF%91java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9/","year":"2018"},{"content":"Java8 带来了许多改变，其中之一就是default修饰的接口方法。\n这些方法改变了我们已知的接口，现在我们能够在接口中定义默认实现方法。默认实现方法的不同之处在于，在接口中用default修饰抽象方法后，该方法可以拥有方法体，实现他的方法可以不重写default修饰的方法而且可以直接调用。\n如果你大量使用default方法在你的应用接口中，你将很快意识到他没有真正精简代码。\n因为你不能在接口中提炼default里重复的代码到一个新的普通方法，这与以精简代码为目的的default关键字相冲突。\n但在java9中这个问题被引入的 private interface methods 解决了。这些新定义的规则可以让你在接口中创建private修饰的方法，这样我们就可以在接口中构造更加简练的代码。\n利用Java9的 private interface methods 重构 default 方法\n代码实例：\n接口\u0026ndash;Archive\npublic interface Archive {\rList\u0026lt;Article\u0026gt; getArticles();\rdefault List\u0026lt;Article\u0026gt; filterByTitle(String title) {\rreturn getArticles().stream()\r.filter(article -\u0026gt; article.getTitle().equals(title))\r.collect(Collectors.toList());\r}\rdefault List\u0026lt;Article\u0026gt; filterByTag(String tag) {\rreturn getArticles().stream()\r.filter(article -\u0026gt; article.getTags().contains(tag))\r.collect(Collectors.toList());\r}\r}\r 正如你所看到的，Archive包含一个抽象方法- getArticles ，和两个default方法- filterByTitle 和 filterByTag 。\n现在，如果你仔细观察两个default方法，你会发现它们几乎相同。唯一的区别就是在filter方法中使用了不同的谓语而已。\n这种重复的代码又土又没有必要。理应让default代码更加简练，幸运的是Java9的 private interface method 可以帮上忙。\n下面是用 private interface methods 重写的Archive：\npublic interface NewArchive {\rList\u0026lt;Article\u0026gt; getArticles();\rdefault List\u0026lt;Article\u0026gt; filterByTitle(String title) {\rreturn filterBy(article -\u0026gt; article.getTitle().equals(title));\r}\rdefault List\u0026lt;Article\u0026gt; filterByTag(String tag) {\rreturn filterBy(article -\u0026gt; article.getTags().contains(tag));\r}\rprivate List\u0026lt;Article\u0026gt; filterBy(Predicate\u0026lt;Article\u0026gt; toFilterBy) {\rreturn getArticles().stream()\r.filter(toFilterBy)\r.collect(Collectors.toList());\r}\r}\r 这就是想要的结果，通过提取除了谓语以外的代码，我们移除了重复的内容，也让代码更具有可读性。\n*英文链接：deadCodeRising\n*原创译文\n","id":58,"section":"posts","summary":"Java8 带来了许多改变，其中之一就是default修饰的接口方法。 这些方法改变了我们已知的接口，现在我们能够在接口中定义默认实现方法。默认实现方法","tags":["java"],"title":"[译]java9新特性：在接口中用pirvate方法让default(java8接口特性)更简练","uri":"http://www.mingaccount.com/2018/05/%E8%AF%91java9%E6%96%B0%E7%89%B9%E6%80%A7default/","year":"2018"},{"content":"异常信息\nNo anonymous write access. Authentication failed for  解决方案\n提交的时候设置UserName和email  或者重新设置全局git用户名和邮箱\ngit config --global user.name \u0026quot;username\u0026quot; git config --global user.email \u0026quot;email\u0026quot;  ","id":59,"section":"posts","summary":"异常信息 No anonymous write access. Authentication failed for 解决方案 提交的时候设置UserName和email 或者重新设置全局git用户名和邮箱 git config --global user.name \u0026quot;username\u0026quot; git config --global user.email \u0026quot;email\u0026quot;","tags":["git"],"title":"Git push 异常：remote: No anonymous write access","uri":"http://www.mingaccount.com/2018/05/gitpush%E5%BC%82%E5%B8%B8/","year":"2018"},{"content":"1.在git上创建仓库，记下clone地址 2.把线上仓库拉到本地 git clone https://github.com/*/*.git  3.把要上传的本地项目文件全部放入本地仓库中 4.把所有文件提交到线上 git add . git commit -m \u0026quot;first commit\u0026quot; git push -u origin master  ","id":60,"section":"posts","summary":"1.在git上创建仓库，记下clone地址 2.把线上仓库拉到本地 git clone https://github.com/*/*.git 3.把要上传的本地项目文件全部放入本地仓库中 4.把所有文件提交到线上 git","tags":["git"],"title":"Git上传本地项目","uri":"http://www.mingaccount.com/2018/05/git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/","year":"2018"},{"content":"#查看工作区状态 git status -s #撤回上一次的commit内容 git reset --hard HEAD~ #删除所有本地未提交内容 git checkout . #下次push时保存输入密码 git config credential.helper store #更改当前项目的用户名和邮箱 git config user.name \u0026quot;\u0026quot; git config user.email \u0026quot;\u0026quot; #更改全局的用户名和邮箱 git config --global user.name \u0026quot;\u0026quot; git config --global user.email \u0026quot;\u0026quot;  ","id":61,"section":"posts","summary":"#查看工作区状态 git status -s #撤回上一次的commit内容 git reset --hard HEAD~ #删除所有本地未提交内容 git checkout . #下次push时保存输入密码 git config credential.helper store #更改当前项目","tags":["git"],"title":"Git常用命令备忘","uri":"http://www.mingaccount.com/2018/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/","year":"2018"},{"content":"Hutool封装大量java工具类\nmaven配置：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;5.4.4\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  API文档\n官方首页\n ","id":62,"section":"posts","summary":"Hutool封装大量java工具类 maven配置： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; API文档 官方首页","tags":["java"],"title":"Hutool工具包","uri":"http://www.mingaccount.com/2018/05/hutool%E5%B7%A5%E5%85%B7%E5%8C%85/","year":"2018"},{"content":"问题代码 service方法抛出了异常，但是没有rollback\n@Transactional\rpublic void batchInsert() throws CommonException{}\r 抛出的自定义异常继承于Exception\npublic class CommonException extends Exception{}\r 问题原因 @Transactional注解默认不能捕获checked异常\nchecked异常就是继承于Exception的异常，编辑器强制捕获或者抛出\runchecked异常就是继承于RuntimeException的异常，编译器不强制处理\r 解决方案  把CommonException改为继承RuntimeException 设置@Transactional(rollbackFor=CommonException.class)  发散 除了因为Exception类型原因导致的事务失败，还有可能因为以下原因：\n @Transactional修饰的方法不是public 本类中没有注解的方法调用有注解的方法 设置的引擎不支持事务  ","id":63,"section":"posts","summary":"问题代码 service方法抛出了异常，但是没有rollback @Transactional public void batchInsert() throws CommonException{} 抛出的自定义异常继承于Exception public class CommonException extends Exception{} 问题原因 @Tra","tags":["spring"],"title":"Spring @Transactional事务失效","uri":"http://www.mingaccount.com/2018/05/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/","year":"2018"},{"content":"Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：\n　（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year\n　（2）Seconds Minutes Hours DayofMonth Month DayofWeek\n　一、结构 　corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份\n二、各字段的含义    字段 允许值 允许的特殊字符     秒（Seconds） 0~59的整数 , - * / 四个字符   分（Minutes） 0~59的整数 , - * / 四个字符   小时（Hours） 0~23的整数 , - * / 四个字符   日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符   月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符   星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符   年(可选，留空)（Year） 1970~2099 , - * / 四个字符    　注意事项：\n　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：\n　（1）*：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。\n　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。\n　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次\n　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.\n　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。\n　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。\n　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。\n　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。\n　（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n三、常用表达式例子 　（1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务\n　（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业\n　（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n　（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点\n　（5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时\n　（6）0 0 12 ? * WED 表示每个星期三中午12点\n　（7）0 0 12 * * ? 每天中午12点触发\n　（8）0 15 10 ? * * 每天上午10:15触发\n　（9）0 15 10 * * ? 每天上午10:15触发\n　（10）0 15 10 * * ? * 每天上午10:15触发\n　（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发\n　（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发\n　（13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发\n　（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发\n　（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发\n　（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发\n　（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发\n　（18）0 15 10 15 * ? 每月15日上午10:15触发\n　（19）0 15 10 L * ? 每月最后一日的上午10:15触发\n　（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发\n　（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发\n　（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发\n　注：\n　（1）有些子表达式能包含一些范围或列表\n　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”\n“*”字符代表所有可能的值\n　因此，“*”在子表达式（月）里表示每个月的含义，“*”在子表达式（天（星期））表示星期的每一天\n　“/”字符用来指定数值的增量\n例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟\n在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样\n　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值\n当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”\n　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写\n但是它在两个子表达式里的含义是不同的。\n在天（月）子表达式中，“L”表示一个月的最后一天\n在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT\n　如果在“L”前有具体的内容，它就具有其他的含义了\n　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五\n注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n转自：https://www.cnblogs.com/javahr/p/8318728.html\n","id":64,"section":"posts","summary":"Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： （1） Seconds Minutes Hours DayofMonth Month DayofWeek Year","tags":["spring"],"title":"[转]quartz cron表达式详解","uri":"http://www.mingaccount.com/2018/05/quartzcron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/","year":"2018"},{"content":"需要注意在判断int和Integer是否相等时，会先将Integer拆箱，如果Integer为null，会报空指针异常。\n因此需要提前处理好Integer对象为null的情况。\n","id":65,"section":"posts","summary":"需要注意在判断int和Integer是否相等时，会先将Integer拆箱，如果Integer为null，会报空指针异常。 因此需要提前处理好I","tags":["java"],"title":"判断int和Integer类型是否相等时，空指针异常","uri":"http://www.mingaccount.com/2018/03/%E5%88%A4%E6%96%ADint%E5%92%8Cinteger%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%E6%97%B6%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/","year":"2018"},{"content":"1. ASCII码 我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态（-128~127），这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。\n上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。\nASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。\nASCII码用了1个字节，1个字节可以表示256种状态，但ASCII码只用了128种，也就是一个字节的后七位，最前面的1位都是0\n2、非ASCII编码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。\n中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。\n3.Unicode编码 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。\nUnicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。\n4. Unicode的问题 需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n它们造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。\n5.UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。\nUTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则很简单，只有二条：\n 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 对于n字节的符号（n\u0026gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。  下表总结了编码规则，字母x表示可用编码的位。\n   Unicode符号范围 UTF-8编码方式     (十六进制) （二进制）   0000 0000-0000 007F 0xxxxxxx   0000 0080-0000 07FF 110xxxxx 10xxxxxx   0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx   0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    下面，还是以汉字“严”为例，演示如何实现UTF-8编码。\n已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。\n6. Unicode与UTF-8之间的转换 通过上一节的例子，可以看到“严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。\n在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击“文件”菜单中的“另存为”命令，会跳出一个对话框，在最底部有一个“编码”的下拉条。\n里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。\n 1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。 2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。（这种情况下如果一个字符的unicode超过2个字节就存不下了，utf-8就没事） 3）Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。 4）UTF-8编码，也就是上一节谈到的编码方法。  选择完”编码方式“后，点击”保存“按钮，文件的编码方式就立刻转换好了。\n7. Little endian和Big endian （其实这就是bom） 上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字”严“为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。\n这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。\n因此，第一个字节在前，就是”大头方式“（Big endian），第二个字节在前就是”小头方式“（Little endian）。\n那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？\nUnicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格“（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。\n如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。\n8. 实例 下面，举一个实例：\n打开”记事本“程序Notepad.exe，新建一个文本文件，内容就是一个”严“字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。\n然后，用文本编辑软件UltraEdit中的”十六进制功能“，观察该文件的内部编码方式。\n 1）ANSI：文件的编码就是两个字节“D1 CF”，这正是“严”的GB2312编码，这也暗示GB2312是采用大头方式存储的。 2）Unicode：编码是四个字节“FF FE 25 4E”，其中“FF FE”表明是小头方式存储，真正的编码是4E25。 3）Unicode big endian：编码是四个字节“FE FF 4E 25”，其中“FE FF”表明是大头方式存储。 4）UTF-8：编码是六个字节“EF BB BF E4 B8 A5”，前三个字节“EF BB BF”表示这是UTF-8编码，后三个“E4B8A5”就是“严”的具体编码，它的存储顺序与编码顺序是一致的。  9、unicode编码表 Unicode目前普遍采用的是UCS-2,它用两个字节来编码一个字符,比如汉字\u0026quot;经\u0026quot;的编码是0x7ECF,注意字符编码一般用十六进制来表示,为了与十进制区分,就是32463,UCS-2用两个字节来编码字符,两个字节就是16\n位二进制,2的16次方等于65536,所以UCS-2最多能编码65536个字符。编码从0到127的字符与ASCII编码的字符一样,比如字母\u0026quot;a\u0026quot;的Unicode 编码是0x0061,十进制是97,而\u0026quot;a\u0026quot;的ASCII编码是0x61,十进制也是97,\n对于汉字的编码,事实上Unicode对汉字支持不怎么好,这也是没办法的,简体和繁体总共有六七万个汉字,而UCS-2最多能表示65536个,才六万多个,所以Unicode只能排除一些几乎不用的汉字,好在常用的简体汉字\n也不过七千多个,为了能表示所有汉字,Unicode也有UCS-4规范,就是用4个字节来编码字符,不过现在普遍采用的还是UCS-2，只用两个字节来编码\n曾经使用这种方法处理汉字传输乱码问题。传输过程中将汉字转换成UCS-2的unicode 4位16进制编码，接收后再转回来。\n10、BCD码 在一次面试中被问到BCD码上面讲的是字符编码，是指一个字符对应的一个二进制数，而BCD码是计算机在对十进制数做运算或存储时采用的二进制格式。\n即BCD代码。Binary-Coded Decimal‎，简称BCD，称BCD码或二-十进制代码，亦称二进码十进数。是一种二进制的数字编码形式，用二进制编码的十进制代码。这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。\nBCD码 - 常用BCD码\n   十进制数 8421码 5421码 2421码 余3码 余3循环码     0 0000 0000 0000 0011 0010   1 0001 0001 0001 0100 0110   2 0010 0010 0010 0101 0111   3 0011 0011 0011 0110 0101   4 0100 0100 0100 0111 0100   5 0101 1000 1011 1000 1100   6 0110 1001 1100 1001 1101   7 0111 1010 1101 1010 1111   8 1000 1011 1110 1011 1110   9 1001 1100 1111 1100 1010    bcd码效率高：\n比如十进制要以二进制的形式在计算机中存储，十进制直接转换成与之对应的BCD码比十进制通过除法取余再转换的效率来的高\n11、Base64编码（怎么使用？） （把一串二进制转换成另一种二进制串，以至于可以打印成英文、数字字符还有+、/）\n1、Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3*8 = 4*6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。\n2、在email传输中，加密是肯定的，但是base64加密的目的不是让用户发送非常安全的Email。这种加密方式主要就是“防君子不防小人”，达到一种一眼看上去看不出内容的效果。\n3、base64编码是用来解决把不可打印的内容塞进可打印内容的需求的。比如把图片存到数据库，图片数据归根到底还是一堆二进制串（总不能把这些二进制串直接存到数据库吧），用base64编码后的显示成的字符串就大大缩小的长度，可以存到数据库。\n4、满足电子邮件中不能直接使用非ASCII码字符传输数据的规定，所以使用base64进行编码后传输，因为base64的64个字符肯定有对应的ascii编码。\n5、请不要再叫base64加密，请叫base64编码\n让我们再来看一个实际的例子，加深印象！\n转换前 10101101 10111010 01110110\n转换中 101011 011011 101001 110110\n转换后 00101011 00011011 00101001 00110110\n对应码表中的值 r b p 2\n转自http://blog.csdn.net/junhuahouse/article/details/23032827\n很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。\n开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10, 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉 很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。\n后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！\n等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。\n但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣 们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……”\n因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！\n正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。\nunicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。\n这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。\nunicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。\nunicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。\nUTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。\n   Unicode符号范围 UTF-8编码方式     (十六进制) （二进制）   0000 0000-0000 007F 0xxxxxxx   0000 0080-0000 07FF 110xxxxx 10xxxxxx   0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx   0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    作者：于洋\n链接：https://www.zhihu.com/question/23374078/answer/69732605\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","id":66,"section":"posts","summary":"1. ASCII码 我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就","tags":["java"],"title":"字符编码笔记：ASCII、Unicode、UTF-8 和 Base64","uri":"http://www.mingaccount.com/2018/03/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/","year":"2018"},{"content":"一、需要一个类继承HttpServletRequestWrapper，该类继承了ServletRequestWrapper并实现了HttpServletRequest， 因此它可作为request在FilterChain中传递。\n该类需要重写getReader和getInputStream两个方法，并在返回时将读出的body数据重新写入。\n二、需要一个Filter筛选目标urlPattern，调用第一个类的同时，将第一个类写入FilterChain中代替原本的Request package com.bonc.util;\rimport javax.servlet.ReadListener;\rimport javax.servlet.ServletInputStream;\rimport javax.servlet.http.HttpServletRequest;\rimport javax.servlet.http.HttpServletRequestWrapper;\rimport java.io.*;\rpublic class BodyReaderRequestWrapper extends HttpServletRequestWrapper {\rprivate final String body;\r/**\r*\r* @param request\r*/\rpublic BodyReaderRequestWrapper(HttpServletRequest request) throws IOException{\rsuper(request);\rStringBuilder sb = new StringBuilder();\rInputStream ins = request.getInputStream();\rBufferedReader isr = null;\rtry{\rif(ins != null){\risr = new BufferedReader(new InputStreamReader(ins));\rchar[] charBuffer = new char[128];\rint readCount = 0;\rwhile((readCount = isr.read(charBuffer)) != -1){\rsb.append(charBuffer,0,readCount);\r}\r}else{\rsb.append(\u0026quot;\u0026quot;);\r}\r}catch (IOException e){\rthrow e;\r}finally {\rif(isr != null) {\risr.close();\r}\r}\rsb.toString();\rbody = sb.toString();\r}\r@Override\rpublic BufferedReader getReader() throws IOException {\rreturn new BufferedReader(new InputStreamReader(this.getInputStream()));\r}\r@Override\rpublic ServletInputStream getInputStream() throws IOException {\rfinal ByteArrayInputStream byteArrayIns = new ByteArrayInputStream(body.getBytes());\rServletInputStream servletIns = new ServletInputStream() {\r@Override\rpublic boolean isFinished() {\rreturn false;\r}\r@Override\rpublic boolean isReady() {\rreturn false;\r}\r@Override\rpublic void setReadListener(ReadListener readListener) {\r}\r@Override\rpublic int read() throws IOException {\rreturn byteArrayIns.read();\r}\r};\rreturn servletIns;\r}\r}\r package com.bonc.bitwd.filter;\rimport com.bonc.util.BodyReaderRequestWrapper;\rimport javax.servlet.*;\rimport javax.servlet.http.HttpServletRequest;\rimport javax.servlet.http.HttpServletResponse;\rimport java.io.IOException;\rpublic class BodyReaderRequestFilter implements Filter{\r@Override\rpublic void init(FilterConfig filterConfig) throws ServletException {\r}\r@Override\rpublic void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain) throws IOException, ServletException {\rHttpServletRequest request = (HttpServletRequest)req;\rHttpServletResponse response = (HttpServletResponse)res;\rBodyReaderRequestWrapper requestWrapper = new BodyReaderRequestWrapper(request);\rif(requestWrapper == null){\rfilterChain.doFilter(request,response);\r}else {\rfilterChain.doFilter(requestWrapper,response);\r}\r}\r@Override\rpublic void destroy() {\r}\r}\r ","id":67,"section":"posts","summary":"一、需要一个类继承HttpServletRequestWrapper，该类继承了ServletRequestWrapper并实现了HttpS","tags":["java"],"title":"Request的Body只能读取一次解决方法","uri":"http://www.mingaccount.com/2018/03/request%E7%9A%84body%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%8F%96%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","year":"2018"},{"content":" 交于Spring管理的类，通过注解调用  @Component\rpublic class Test{\r@Autowired\rprivate HttpServletRequest httpServletRequest;\r}\r 通过静态方法调用  HttpServletRequest httpServletRequest = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();\r ","id":68,"section":"posts","summary":"交于Spring管理的类，通过注解调用 @Component public class Test{ @Autowired private HttpServletRequest httpServletRequest; } 通过静态方法调用 HttpServletRequest httpServletRequest = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();","tags":["java"],"title":"全局获取request","uri":"http://www.mingaccount.com/2018/01/%E5%85%A8%E5%B1%80%E8%8E%B7%E5%8F%96request/","year":"2018"},{"content":"Description Below I present you two different ways to get the current Class:\n Using Thread Using getClass()  The simplest way to get the name of the class where your code is being executed in is using the getClass() method present in every java object. Like here:\nString clazz = this.getClass().getName();\r This works only if executed in an Object, namely an instanciated class. If you try to execute the code above in a static method. It won\u0026rsquo;t work. Even the keyword this is meaningless in a static method.\nAlso, the class returned by the above method may actually be a subclass of the class in which the method is defined. This is because subclasses inherit the methods of their parents; and getClass() returns the actual runtime type of the object. To get the actual class in which a method is defined, use the method below also.\nIn a static method you can instead use the following:\nString clazz = Thread.currentThread().getStackTrace()[1].getClassName();\r Which uses the static methodgetStackTrace() to get the whole stacktrace. This method returns an array, where the first element (index 0) is the getStackTrace() you called and the second element (index 1) is the method your code is in.\nA similar trick can be used to find out the name of the method currently executed:\nString method = Thread.currentThread().getStackTrace()[1].getMethodName();\r It\u0026rsquo;s exactly the same principle, just you dig out the name of the method instead of the class.\nThe code package org.wikijava.reflection; public class MethodName { public static void main(String[] args) { MethodName methodName = new MethodName(); String clazz = Thread.currentThread() .getStackTrace() [1].getClassName();\rString method = Thread.currentThread() .getStackTrace()[1].getMethodName();\rSystem.out.println(\u0026quot;class name: \u0026quot; + clazz + \u0026quot; Method Name \u0026quot; + method); methodName.anotherMethod(); } private void anotherMethod() { String clazz = this.getClass().getName(); String method = Thread.currentThread() .getStackTrace()[1].getMethodName(); System.out.println(\u0026quot;class name: \u0026quot; + clazz + \u0026quot; Method Name \u0026quot; + method); } }  ","id":69,"section":"posts","summary":"Description Below I present you two different ways to get the current Class: Using Thread Using getClass() The simplest way to get the name of the class where your code is being executed in is using the getClass() method present in every java object. Like here: String clazz = this.getClass().getName(); This works only if executed in an Object, namely an instanciated class. If you try to execute the code above","tags":["java"],"title":"Java获取当前类名和方法名","uri":"http://www.mingaccount.com/2018/01/java%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%B1%BB%E5%90%8D%E5%92%8C%E6%96%B9%E6%B3%95%E5%90%8D/","year":"2018"},{"content":" 所谓观察者模式，指的某个状态信息的改变，会影响其他一系列的操作，这时就可以将这些操作抽象化，同时创建一个类统一的管理和执行这些操作。把这些抽象出来的操作称为观察者类，而管理这些操作的类称为通知者类，通知者类维护着一个观察者类的集合，可以追加和删除观察者，同时可遍历通知所有观察者类执行操作。    观察者模式的不足：虽然观察者模式提取出了抽象类，让类与类之间不互相依赖，共同依赖于抽象接口，这符合依赖倒转原则，但他们仍然依赖着抽象接口，而且有些时候不能提取出抽象的观察者（比如引用jar包）。 java委托机制与观察者模式：委托机制的实现不再需要提取观察者抽象类，观察者和通知者互不依赖。java利用反射即可实现，代码实例如下:  事件类\npackage com.suski.delegate;\rimport java.lang.reflect.Method;\rpublic class Event {\rprivate Object object;\rprivate String methodName;\rprivate Object[] params;\rprivate Class[] paramTypes;\rpublic Event(Object object,String method,Object...args)\r{\rthis.object = object;\rthis.methodName = method;\rthis.params = args;\rcontractParamTypes(this.params);\r}\rprivate void contractParamTypes(Object[] params)\r{\rthis.paramTypes = new Class[params.length];\rfor (int i=0;i\u0026lt;params.length;i++)\r{\rthis.paramTypes[i] = params[i].getClass();\r}\r}\rpublic void invoke() throws Exception\r{\rMethod method = object.getClass().getMethod(this.methodName, this.paramTypes);//判断是否存在这个函数\rif (null == method)\r{\rreturn;\r}\rmethod.invoke(this.object, this.params);//利用反射机制调用函数\r}\r}\r 事件管理类\npackage com.suski.delegate;\rimport java.util.ArrayList;\rimport java.util.List;\rpublic class EventHandler {\rprivate List\u0026lt;Event\u0026gt; objects;\rpublic EventHandler()\r{\robjects = new ArrayList\u0026lt;Event\u0026gt;();\r}\rpublic void addEvent(Object object, String methodName, Object...args)\r{\robjects.add(new Event(object, methodName, args));\r}\rpublic void notifyX() throws Exception\r{\rfor (Event event : objects)\r{\revent.invoke();\r}\r}\r}\r 通知者抽象类\npackage com.suski.delegate;\rpublic abstract class Notifier {\rprivate EventHandler eventHandler = new EventHandler();\rpublic EventHandler getEventHandler()\r{\rreturn eventHandler;\r}\rpublic void setEventHandler(EventHandler eventHandler)\r{\rthis.eventHandler = eventHandler;\r}\rpublic abstract void addListener(Object object,String methodName, Object...args);\rpublic abstract void notifyX();\r}\r 通知者具体实现类\npackage com.suski.delegate;\rpublic class ConcreteNotifier extends Notifier{\r@Override\rpublic void addListener(Object object, String methodName, Object... args) {\rthis.getEventHandler().addEvent(object, methodName, args);\r}\r@Override\rpublic void notifyX() {\rtry {\rthis.getEventHandler().notifyX();\r} catch (Exception e) {\r// TODO: handle exception\re.printStackTrace();\r}\r}\r}\r 具体的观察者类，不再需要抽象观察者\npackage com.suski.delegate;\rimport java.util.Date;\rpublic class WatchingTVListener {\rpublic WatchingTVListener()\r{\rSystem.out.println(\u0026quot;watching TV\u0026quot;);\r}\rpublic void stopWatchingTV(Date date) {\rSystem.out.println(\u0026quot;stop watching\u0026quot; + date);\r}\r}\r package com.suski.delegate;\rimport java.util.Date;\rpublic class PlayingGameListener {\rpublic PlayingGameListener()\r{\rSystem.out.println(\u0026quot;playing\u0026quot;);\r}\rpublic void stopPlayingGame(Date date)\r{\rSystem.out.println(\u0026quot;stop playing\u0026quot; + date);\r}\r}\r 测试方法\npackage com.suski.delegate;\rimport java.util.Date;\rpublic class Test {\rpublic static void main (String[] args)\r{\rNotifier goodNotifier = new ConcreteNotifier();\rPlayingGameListener playingGameListener = new PlayingGameListener();\rWatchingTVListener watchingTVListener = new WatchingTVListener();\rgoodNotifier.addListener(playingGameListener, \u0026quot;stopPlayingGame\u0026quot;, new Date());\rgoodNotifier.addListener(watchingTVListener, \u0026quot;stopWatchingTV\u0026quot;, new Date());\rgoodNotifier.notifyX();\r}\r}\r ","id":70,"section":"posts","summary":"所谓观察者模式，指的某个状态信息的改变，会影响其他一系列的操作，这时就可以将这些操作抽象化，同时创建一个类统一的管理和执行这些操作。把这些抽","tags":["design pattern"],"title":"观察者模式和java委托","uri":"http://www.mingaccount.com/2018/01/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8Cjava%E5%A7%94%E6%89%98/","year":"2018"},{"content":"转自:http://blog.csdn.net/kaiwii/article/details/7405761\n主要功能\nClass.forName(xxx.xx.xx)返回的是一个类\nClass.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，\n也就是说JVM会执行该类的静态代码段\n下面，通过解答以下三个问题的来详细讲解下Class.forName()的用法。\n一.什么时候用Class.forName()？ 先来个热身，给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？你第一想到的肯定是new,但是注意一点：\nA a = (A)Class.forName(“pacage.A”).newInstance();\r 这和你 A a = new A()； 是一样的效果。\n现在言归正传。\n动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象时需要用到：\nString str = “用户输入的字符串” ;\rClass t = Class.forName(str);\rt.newInstance();\r 在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。那么为什么会有两种创建对象方式？这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。\nJava中工厂模式经常使用newInstance()方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。 例如：\nclass c = Class.forName(“Example”);\rfactory = (ExampleInterface)c.newInstance();\r 其中ExampleInterface是Example的接口，可以写成如下形式：\nString className = “Example”;\rclass c = Class.forName(className);\rfactory = (ExampleInterface)c.newInstance();\r 进一步可以写成如下形式：\nString className = readfromXMlConfig;//从xml 配置文件中获得字符串\rclass c = Class.forName(className);\rfactory = (ExampleInterface)c.newInstance();\r 上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。\n从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。但是使用newInstance()方法的时候，就必须保证：\n1、这个类已经加载；\n2、这个类已经连接了。\n而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。\n现在可以看出，newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。 这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。\n二.new 和Class.forName（）有什么区别？ 其实上面已经说到一些了，这里来做个总结：\n首先，newInstance( )是一个方法，而new是一个关键字；\n其次，Class下的newInstance()的使用有局限，因为它生成对象只能调用无参的构造函数，而使用 new关键字生成对象没有这个限制。 简言之：\n newInstance(): 弱类型,低效率,只能调用无参构造。 new: 强类型,相对高效,能调用任何public构造。 Class.forName(“”)返回的是类。 Class.forName(“”).newInstance()返回的是object 。  三.为什么在加载数据库驱动包的时候有用的是Class.forName( )，却没有调用newInstance( )？ 在Java开发特别是数据库开发中，经常会用到Class.forName( )这个方法。\n通过查询Java Documentation我们会发现使用Class.forName( )静态方法的目的是为了动态加载类。\n通常编码过程中，在加载完成后，一般还要调用Class下的newInstance( )静态方法来实例化对象以便操作。因此，单单使用Class.forName( )是动态加载类是没有用的，其最终目的是为了实例化对象。\n有数据库开发经验朋友会发现，为什么在我们加载数据库驱动包的时候有的却没有调用newInstance( )方法呢？\n即有的jdbc连接数据库的写法里是Class.forName(xxx.xx.xx);而有一 些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？\n刚才提到，Class.forName(“”);的作用是要求JVM查找并加载指定的类，首先要明白，java里面任何class都要装载在虚拟机上才能运行，而静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了，而且以后不会再走这段静态代码了。\n而我们前面也说了，Class.forName(xxx.xx.xx)的作用就是要求JVM查找并加载指定的类，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。\n而在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己，即任何一个JDBC Driver的 Driver类的代码都必须类似如下：\npublic class MyJDBCDriver implements Driver {\rstatic {\rDriverManager.registerDriver(new MyJDBCDriver());\r}\r}  既然在静态初始化器的中已经进行了注册，所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了。\n相关英文参考文献如下：\nwe just want to load the driver to jvm only, but not need to user the instance of driver,\nso call Class.forName(xxx.xx.xx) is enough, if you call Class.forName(xxx.xx.xx).newInstance(),\nthe result will same as calling Class.forName(xxx.xx.xx),\nbecause Class.forName(xxx.xx.xx).newInstance() will load driver first,\nand then create instance, but the instacne you will never use in usual,\nso you need not to create it.\n","id":71,"section":"posts","summary":"转自:http://blog.csdn.net/kaiwii/article/details/7405761 主要功能 Class.forNam","tags":["java"],"title":"[转]Class.forName()用法详解","uri":"http://www.mingaccount.com/2017/11/class.forname%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","year":"2017"},{"content":"原因是因为list是由Arrays.asList生成的 根据Arrays源码，asList方法生成的ArrayList，并不是java.util.ArrayList，而是Arrays的一个内部类\npublic static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) {\rreturn new ArrayList\u0026lt;\u0026gt;(a);\r}\r 该内部类直接继承了AbstractList，并且并未实现addAll方法\nprivate static class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt;\rimplements RandomAccess, java.io.Serializable\r 然而默认的AbstractList的addAll方法直接抛出了异常，并未有任何实现\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) {\rboolean modified = false;\rfor (E e : c)\rif (add(e))\rmodified = true;\rreturn modified;\r}\rpublic boolean add(E e) {\rthrow new UnsupportedOperationException();\r}\r ","id":72,"section":"posts","summary":"原因是因为list是由Arrays.asList生成的 根据Arrays源码，asList方法生成的ArrayList，并不是java.uti","tags":["java"],"title":"List addAll产生异常java.lang.UnsupportedOperationException","uri":"http://www.mingaccount.com/2017/11/list_add_all%E5%BC%82%E5%B8%B8/","year":"2017"},{"content":"*该博客转自 http://blog.csdn.net/danchu/article/details/54986442\n语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。\nJava作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。一般来说Java中的语法糖主要有以下几种：\n 泛型与类型擦除 自动装箱与拆箱，变长参数、 增强for循环 内部类与枚举类  泛型与类型擦除 Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。\n在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。\n/**\r* 在源代码中存在泛型\r*/\rpublic static void main(String[] args) {\rMap\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;String,String\u0026gt;();\rmap.put(\u0026quot;hello\u0026quot;,\u0026quot;你好\u0026quot;);\rString hello = map.get(\u0026quot;hello\u0026quot;);\rSystem.out.println(hello);\r}\r 当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换\npublic static void main(String[] args) {\rHashMap map = new HashMap(); //类型擦除\rmap.put(\u0026quot;hello\u0026quot;, \u0026quot;你好\u0026quot;);\rString hello = (String)map.get(\u0026quot;hello\u0026quot;);//强制转换\rSystem.out.println(hello);\r}\r 自动装箱与拆箱 Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。\r 我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。\n下面代码演示了自动装箱和拆箱功能\npublic static void main(String[] args) {\rInteger a = 1;\rint b = 2;\rint c = a + b;\rSystem.out.println(c);\r}\r 经过编译后，代码如下\npublic static void main(String[] args) {\rInteger a = Integer.valueOf(1); // 自动装箱\rbyte b = 2;\rint c = a.intValue() + b;//自动拆箱\rSystem.out.println(c);\r}\r 变长参数 所谓变长参数，就是方法可以接受长度不定确定的参数\n变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。\npublic class Varargs {\rpublic static void print(String... args) {\rfor(String str : args){\rSystem.out.println(str);\r}\r}\rpublic static void main(String[] args) {\rprint(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;);\r}\r}\r 编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的\npublic class Varargs {\rpublic Varargs() {\r}\rpublic static void print(String... args) {\rString[] var1 = args;\rint var2 = args.length;\r//增强for循环的数组实现方式\rfor(int var3 = 0; var3 \u0026lt; var2; ++var3) {\rString str = var1[var3];\rSystem.out.println(str);\r}\r}\rpublic static void main(String[] args) {\r//变长参数转换为数组\rprint(new String[]{\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;});\r}\r}\r 增强for循环 增强for循环与普通for循环相比，功能更强并且代码更简洁\r 增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。\npublic static void main(String[] args) {\rString[] params = new String[]{\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;};\r//增强for循环对象为数组\rfor(String str : params){\rSystem.out.println(str);\r}\rList\u0026lt;String\u0026gt; lists = Arrays.asList(\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;);\r//增强for循环对象实现Iterable接口\rfor(String str : lists){\rSystem.out.println(str);\r}\r}\r 编译后的class文件为\npublic static void main(String[] args) {\rString[] params = new String[]{\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;};\rString[] lists = params;\rint var3 = params.length;\r//数组形式的增强for退化为普通for\rfor(int str = 0; str \u0026lt; var3; ++str) {\rString str1 = lists[str];\rSystem.out.println(str1);\r}\rList var6 = Arrays.asList(new String[]{\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;});\rIterator var7 = var6.iterator();\r//实现Iterable接口的增强for使用iterator接口进行遍历\rwhile(var7.hasNext()) {\rString var8 = (String)var7.next();\rSystem.out.println(var8);\r}\r}\r 内部类 内部类就是定义在一个类内部的类\r Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。\npublic class Outer {\rclass Inner{\r}\r}\r 使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：\nclass Outer$Inner {\rOuter$Inner(Outer var1) {\rthis.this$0 = var1;\r}\r}\r 内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了\n枚举类型 枚举类型就是一些具有相同特性的类常量\r java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。\npublic enum Fruit {\rAPPLE,ORINGE\r}\r 使用jad对编译后的class文件进行反编译后得到：\n//继承java.lang.Enum并声明为final\rpublic final class Fruit extends Enum\r{\rpublic static Fruit[] values()\r{\rreturn (Fruit[])$VALUES.clone();\r}\rpublic static Fruit valueOf(String s)\r{\rreturn (Fruit)Enum.valueOf(Fruit, s);\r}\rprivate Fruit(String s, int i)\r{\rsuper(s, i);\r}\r//枚举类型常量\rpublic static final Fruit APPLE;\rpublic static final Fruit ORANGE;\rprivate static final Fruit $VALUES[];//使用数组进行维护\rstatic\r{\rAPPLE = new Fruit(\u0026quot;APPLE\u0026quot;, 0);\rORANGE = new Fruit(\u0026quot;ORANGE\u0026quot;, 1);\r$VALUES = (new Fruit[] {\rAPPLE, ORANGE\r});\r}\r}\r ","id":73,"section":"posts","summary":"*该博客转自 http://blog.csdn.net/danchu/article/details/54986442 语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，","tags":["java"],"title":"[转]谈谈Java中的语法糖","uri":"http://www.mingaccount.com/2017/10/%E8%BD%AC%E8%B0%88%E8%B0%88java%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/","year":"2017"},{"content":"一、常见的编码格式 1.ASCII 　基础编码，英文和西欧字符。\n　用一个字节的低7位表示，一共128个。\n　0~13是控制字符如换行、回车、删除等，32~126是打印字符，键盘输入。\n2.IOS-8859-1 　ASCII的扩展。\n　用一个字节表示，一共256个。\n3.GB2312 　中文编码字符集。\n　用两个字节表示，A1~A9是符号区，一共682个；B0~F7是汉字区，一共6763个。\n　编码需要查询对应码表，效率略低。\n4.GBK 　GB2312的扩展，能够兼容GB2312。\n　用两个字节表示，一共23940个码位，表示21003个汉字。\n　编码需要查询对应码表，效率略低。\n5.UTF-16 　UTF-16具体定义了Unicode字符在计算机的存取方法。\n　用两个字节表示Unicode的转化格式。\n　定长的展示方法，每两个字节表示一个字符，转化效率高，内存和硬盘多用此编码(JAVA内存存储格式UTF-16)。\n　采用顺序编码，不能对单个字符的编码进行校验，如果损坏，后面的码值都会受影响。\n6.UTF-8 　UTF-8具体定义了Unicode字符在计算机的存取方法。\n　用1-6个字节组成一个字符，汉字采用三个字节表示。\n　变长的展示方法，每个编码区域有不同的字码长度。\n　网络传输中很大一部分字符用一个字节就可以展示，UTF-16规范化的全部转为了两个字节，对于这些字符UTF-8只需要一个字节。\n　UTF-8如果中间一个码值损坏，后面的码值并不受影响。\n　相对于UTF-16，UTF-8有传输中资源占用小，数据更安全的优势，更适合网络传输，但UTF-16的编码规则相对简单，编码效率更高，适合本地内存和磁盘。\n二、常见JAVA编码API 1.I/O　 InputStreamReader isr = new InputStreamReader(inputStream,\u0026quot;utf-8\u0026quot;);\rCharset StreamDecoder\rOutputStreamWriter osw = new OutputStreamWriter(outputStream,\u0026quot;utf-8\u0026quot;);\rCharset StreamEncoder\r 2.内存操作 字符与字节的转换：　//String\rString s = \u0026quot;中文字符\u0026quot;;\rbyte[] b = s.getBytes(\u0026quot;UTF-8\u0026quot;);\rString s1 = new String(b,\u0026quot;UTF-8\u0026quot;);\r//Charset\rCharset charset = Charset.forName(\u0026quot;UTF-8\u0026quot;);\rByteBuffer byteBuffer = charset.encode(string);\rCharBuffer charBuffer = charset.decode(byteBuffer);\r//char和byte的软转换，将一个16bit的char拆分成两个8bit的byte来显示，实际值并没有被转换。\rByteBuffer heapByteBuffer = ByteBuffer.allocate(1024);\rByteBuffer byteBuffer = heapByteBuffer.putChar(c);\r 三、Java Web中涉及的编解码 1.URL编解码 PathInfo中文问题：\n配置tomcat的server.xml：\nQueryString是通过HTTP中的Header传到后台的，他的解码字符集默认是ISO-8859-1，\n也可以通过Header的ContentType中的Charset来定义。\n如何确定后端调取了ContentType中的字符集，需要在server.xml中配置（这个配置只针对QueryString有效）：\n2.HTTP Header的编解码 针对Header中的其他参数，比如Cookie,redirectPath等。\n尽量不要传递非ASCII字符，如果必须，在传递之前用下面的API进行编码再传递：\norg.apache.catalina.util.URLEncoder\n3.POST表单的编解码 客户端获取参数为乱码后的解决思路：\n　1.将POST改为get，查看浏览器端是否有问题。\n　2.后端request.geCharacterEncdoing返回结果是否是预期编码。\n//在第一次使用request.getParameter之前使用\nrequest.setCharacterEncoding(charset);\n4.HTTP BODY的编解码 主要阐述从后台到前台的编解码：\n//对返回前台的数据进行编码，前台会首先根据这个值进行解码 response.setCharacterEncoding(charset)  \u0026lt;!-- 如果后台没有设置，会根据页面中的charset来解码，如果页面也有设置则用默认编码来解码 --\u0026gt;\r\u0026lt;meta HTTP-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html;charset=UTF-8\u0026quot;/\u0026gt;\r\u0026lt;!-- JDBC读写数据时要和数据的内置编码保持一致 --\u0026gt;\rurl=\u0026quot;jdbc:mysql://localhost:3306/DB?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026quot;\r 四、JS的编码问题 1.外部引入js文件 \u0026lt;!-- 浏览器会按照charset的设置来解析这个js文件，如果没有设置则默认按照当前页面的的编码设置来解析js文件 --\u0026gt;\r\u0026lt;script src=\u0026quot;de/mo/demo.js\u0026quot; charset=\u0026quot;gbk\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r 2.js的URL编码 //对url根据UTF-8进行编码和解码，除了一些特殊字符\u0026quot;!\u0026quot;\u0026quot;#\u0026quot;\u0026quot;$\u0026quot;\u0026quot;\u0026amp;\u0026quot;\u0026quot;'\u0026quot;\u0026quot;(\u0026quot;\u0026quot;)\u0026quot;\u0026quot;*\u0026quot;\u0026quot;+\u0026quot;\u0026quot;,\u0026quot;\u0026quot;-\u0026quot;\u0026quot;.\u0026quot;\u0026quot;/\u0026quot;\u0026quot;:\u0026quot;\u0026quot;;\u0026quot;\u0026quot;=\u0026quot;\u0026quot;?\u0026quot;\u0026quot;@\u0026quot;\u0026quot;_\u0026quot;\u0026quot;~\u0026quot;\u0026quot;0-9\u0026quot;\u0026quot;a-z\u0026quot;\u0026quot;A-Z\u0026quot;\r//编码结果在每个码值前加一个\u0026quot;%\u0026quot;\rencodeURI(\u0026quot;http://localhost:8080/examples/servlets/servlet/来吧昆特牌吧孙子?inviter=杰洛特\u0026quot;);\rdecodeURI(\u0026quot;**编码内容**\u0026quot;);\r//对url根据UTF-8进行编码和解码，相对于encodeURI，它更加的彻底。排除的特殊字符为\u0026quot;!\u0026quot;\u0026quot;'\u0026quot;\u0026quot;(\u0026quot;\u0026quot;)\u0026quot;\u0026quot;*\u0026quot;\u0026quot;-\u0026quot;\u0026quot;.\u0026quot;\u0026quot;_\u0026quot;\u0026quot;~\u0026quot;\u0026quot;0-9\u0026quot;\u0026quot;a-z\u0026quot;\u0026quot;A-Z\u0026quot;\r//编码结果在每个码值前加一个\u0026quot;%\u0026quot;\r//它排除的字符比encodeURI更少，通常用于将URL作为参数的URL的编码，如示例如果不将参数URL中的\u0026amp;进行编码会影响到整个URL的完整性\r\u0026quot;http://localhost/servlet?ref=\u0026quot; + encodeURIComponent(\u0026quot;http://localhost:8080/examples/servlets/servlet/来吧昆特牌吧孙子?inviter=杰洛特\u0026amp;inviter=叶奈法\u0026quot;);\rdecodeURIComponent(\u0026quot;**编码内容**\u0026quot;);\r 3.后端接收时解码 后端处理URL编解码靠的是 java.net.URLEncoder和java.net.URLDecoder这两个类。\n后端对的对URL的编码同样也有排除的特殊字符，与前端的encodeURIComponent相对应。\n//后端直接获取传过来的URL参数会自动解码\r//如果没有提前设置request.setCharacterEncoding()很容易出现编码不同而导致的乱码\rrequest.getParameter();\r//另一种方式是通过前台js对URL进行两次编码，后台不管通过什么进行第一次解码，都能得到正确的UTF-8编码，前台代码如下\rencodeURIComponent(encodeURIComponent(url));\r//第一次编码的结果（例如：%E2%A7）的百分号，会在第二次编码后将%变成%25（例如：%25E2%25A7）\r//后台在执行request.getParameter()的时候会自动解码，不管当前容器的编码是什么得到的是正确的UTF-8编码（例如：%E2%A7）\r 五、其他需要编码的地方 1.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r 2.Velocity services.VelocityService.input.encoding=UTF-8\r 3.JSP \u0026lt;%@page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot;%\u0026gt;\r 注：本文是对“《深入分析Java Web技术内幕》许令波 著” 一书的相关内容的总结\n","id":74,"section":"posts","summary":"一、常见的编码格式 1.ASCII 基础编码，英文和西欧字符。 用一个字节的低7位表示，一共128个。 0~13是控制字符如换行、回车、删除等，32~126是打","tags":["java"],"title":"Java编码,乱码问题详解","uri":"http://www.mingaccount.com/2017/10/java%E7%BC%96%E7%A0%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/","year":"2017"},{"content":"QPS：Query Per Second\nTPS：Transaction Per Second\nPV：Page View\nRT：Response Time\nUV：Unique Visitor\nDAU：Daily Actived Users\nMAU：Monthly Actived Users\n","id":75,"section":"posts","summary":"QPS：Query Per Second TPS：Transaction Per Second PV：Page View RT：Response Time UV：Unique Visitor DAU：Daily Actived Users M","tags":["website build"],"title":"QPS、TPS、PV等网站业务关键字释义","uri":"http://www.mingaccount.com/2017/09/qpstpspv%E7%AD%89%E7%BD%91%E7%AB%99%E4%B8%9A%E5%8A%A1%E5%85%B3%E9%94%AE%E5%AD%97%E9%87%8A%E4%B9%89/","year":"2017"},{"content":"跟参数lower_case_table_names相关\n执行语句，查询该参数值\nSHOW VARIABLES LIKE ‘%case%’  lower_case_table_names参数值为0代表大小写敏感\n需要将lower_case_table_names的值改为1\n编辑/etc下的my.cnf文件，可能在根目录下，或者在mysql目录下\n添加如下配置，然后重启mysql\n[mysqld] lower_case_table_names=1  ","id":76,"section":"posts","summary":"跟参数lower_case_table_names相关 执行语句，查询该参数值 SHOW VARIABLES LIKE ‘%case%’ lower_case_table_name","tags":["mysql"],"title":"Mysql表名忽略大小写","uri":"http://www.mingaccount.com/2017/08/mysql%E8%A1%A8%E5%90%8D%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99/","year":"2017"},{"content":"请求头枚举类  public enum HttpHeader {\rAUTHORIZATION(\u0026quot;Authorization\u0026quot;),\rAUTHENTICATION_TYPE_BASIC(\u0026quot;Basic\u0026quot;),\rX_AUTH_TOKEN(\u0026quot;X-AUTH-TOKEN\u0026quot;),\rWWW_Authenticate(\u0026quot;WWW-Authenticate\u0026quot;),\rX_FORWARDED_FOR(\u0026quot;X-Forwarded-For\u0026quot;),\rPROXY_CLIENT_IP(\u0026quot;Proxy-Client-IP\u0026quot;),\rWL_PROXY_CLIENT_IP(\u0026quot;WL-Proxy-Client-IP\u0026quot;),\rHTTP_CLIENT_IP(\u0026quot;HTTP_CLIENT_IP\u0026quot;),\rHTTP_X_FORWARDED_FOR(\u0026quot;HTTP_X_FORWARDED_FOR\u0026quot;);\rprivate String key;\rprivate HttpHeader(String key) {\rthis.key = key;\r}\rpublic String key() {\rreturn this.key;\r}\r}\r 工具类  public class RemoteIpHelper {\rprivate static final String UNKNOWN = \u0026quot;unknown\u0026quot;;\rpublic static String getRemoteIpFrom(HttpServletRequest request) {\rString ip = null;\rint tryCount = 1;\rwhile (!isIpFound(ip) \u0026amp;\u0026amp; tryCount \u0026lt;= 6) {\rswitch (tryCount) {\rcase 1:\rip = request.getHeader(X_FORWARDED_FOR.key());\r//get first ip\rif (ip != null \u0026amp;\u0026amp; ip.indexOf(\u0026quot;,\u0026quot;) != -1) {\rip = ip.substring(0, ip.indexOf(\u0026quot;,\u0026quot;));\r}\rbreak;\rcase 2:\rip = request.getHeader(PROXY_CLIENT_IP.key());\rbreak;\rcase 3:\rip = request.getHeader(WL_PROXY_CLIENT_IP.key());\rbreak;\rcase 4:\rip = request.getHeader(HTTP_CLIENT_IP.key());\rbreak;\rcase 5:\rip = request.getHeader(HTTP_X_FORWARDED_FOR.key());\rbreak;\rdefault:\rip = request.getRemoteAddr();\r}\rtryCount++;\r}\rreturn ip;\r}\rprivate static boolean isIpFound(String ip) {\rreturn ip != null \u0026amp;\u0026amp; ip.length() \u0026gt; 0 \u0026amp;\u0026amp; !UNKNOWN.equalsIgnoreCase(ip);\r}\r}\r ","id":77,"section":"posts","summary":"请求头枚举类 public enum HttpHeader { AUTHORIZATION(\u0026quot;Authorization\u0026quot;), AUTHENTICATION_TYPE_BASIC(\u0026quot;Basic\u0026quot;), X_AUTH_TOKEN(\u0026quot;X-AUTH-TOKEN\u0026quot;), WWW_Authenticate(\u0026quot;WWW-Authenticate\u0026quot;), X_FORWARDED_FOR(\u0026quot;X-Forwarded-For\u0026quot;), PROXY_CLIENT_IP(\u0026quot;Proxy-Client-IP\u0026quot;), WL_PROXY_CLIENT_IP(\u0026quot;WL-Proxy-Client-IP\u0026quot;), HTTP_CLIENT_IP(\u0026quot;HTTP_CLIENT_IP\u0026quot;), HTTP_X_FORWARDED_FOR(\u0026quot;HTTP_X_FORWARDED_FOR\u0026quot;); private String key; private HttpHeader(String key) { this.key = key; } public String key() { return this.key; } } 工具类 public class RemoteIpHelper { private static final String UNKNOWN = \u0026quot;unknown\u0026quot;; public static String getRemoteIpFrom(HttpServletRequest request) { String ip = null; int tryCount = 1; while (!isIpFound(ip) \u0026amp;\u0026amp; tryCount","tags":["java"],"title":"通过request获取客户端IP","uri":"http://www.mingaccount.com/2017/08/%E9%80%9A%E8%BF%87request%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFip/","year":"2017"},{"content":"usermod -d /var/lib/mysql/ mysql ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock chown -R mysql:mysql /var/lib/mysql  ","id":78,"section":"posts","summary":"usermod -d /var/lib/mysql/ mysql ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock chown -R mysql:mysql /var/lib/mysql","tags":["mysql"],"title":"Mysql启动报错mkdir: cannot create directory ‘//.cache’: Permission denied","uri":"http://www.mingaccount.com/2017/07/mysql%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/","year":"2017"},{"content":"1.切面编程核心概念  切面编程Aspect-oriented Programming (AOP)\n AOP只是一个概念，跟Spring是独立关系\n最典型的AOP实现框架AspectJ，是一个十分成熟的框架，Spring AOP相比只是基于它做了一些功能的强化，是互补关系\n几个核心的参数概念（基于AspectJ）\n Aspect: 切面编程的核心是切面，因此首先需要一个切面类(@Aspect注解修饰的类) Join point: 代表需要切面处理的方法（Spring AOP只针对方法，因此以下简称目标方法） Advice: 切面类需要在目标方法运行的哪个阶段进行处理，比如before(调用之前)，after(调用之后)，around(前后都进行处理) Pointcut: 当前的切面类需要监听的目标方法有什么特征，或者说切面类要怎样找到需要处理的目标方法，比如被注解@Log修饰的方法 Introduction: 申明一个额外的方法或者字段去代表目标方法的对象，意思就是你可以给目标方法所在类追加一个父类（接口），并指定一个实现去代表它（AspectJ称为inter-type declaration） Target object: 目标方法所在的对象，也叫作advised object。但是Spring AOP是通过运行时代理实现的，意思就是这个对象是一个代理类的对象  完整的Advice类型包括：\n Before advice: 在目标方法之前 After returning advice: 在目标方法return之后，如果目标方法没有抛异常的话 After throwing advice: 在目标方法抛完异常之后 After (finally) advice: 相当于finally Around advice: 在方法执行前后做处理，可以处理参数，捕获异常，修改返回结果  建议使用最小范围的Advice，比如说仅需要处理返回结果，只需要设定类型为After returning advice即可\n能不使用Around advice的时候尽量不使用，因为它需要你手动去调用目标方法(通过动态代理)，尽可能地减少出错\nSpring AOP默认使用标准的JDK dynamic proxies作为AOP的代理，就是切面类中调用目标方法的过程。\n2.基于AspectJ的Spring AOP实例 2.1 配置类 注解EnableAspectJAutoProxy，让Spring在目标方法被执行时，自动拦截方法调用并生成代理类\n@Configuration\r@EnableAspectJAutoProxy\rpublic class AppConfig {\r}\r 2.2 切面类声明 注意切面类的方法不能作为目标方法被拦截\npackage org.xyz;\rimport org.aspectj.lang.annotation.Aspect;\r@Component\r@Aspect\rpublic class NotVeryUsefulAspect {\r}\r 2.3 切面方法特征申明(Pointcut) Spring AOP只支持方法执行的切入点，所以Pointcut就是在申明怎么匹配目标目标方法\n一个Pointcut的声明有两个部分\n 新建一个方法，任意参数，任意名称，返回值必须是void 新建的方法需要一个@Pointcut注解，这个注解和他的参数叫做pointcut表达式  下面是一个例子，代表pointcut的名字是anyOldTransfer，匹配的目标方法是任何方法名叫做transfer的\n@Pointcut(\u0026quot;execution(* transfer(..))\u0026quot;)\rprivate void andOldTransfer(){}\r 注解Pointcut的value就是AspectJ5的pointcut表达式\n2.3.1 支持的Pointcut标识符 在pointcut表达式中，Spring AOP支持下列的AspectJ pointcut 标识符(PCD)：\n execution: 用于直接匹配目标方法。对Spring AOP来说，这是主要的pointcut指示符 within: 限制目标方法是在匹配的类型中申明 this: 限制目标方法，其bean引用(Spring AOP代理)是给定类型的实例 target: 限制目标方法，其目标对象(正在代理的应用程序对象)是给定类型的实例 args: 限制目标方法，其参数是给定类型的实例 @target: 限制目标方法，其类有指定类型的注解 @args: 限制目标方法，其实际传输的参数，每个参数的类型都有给定的注解 @within: 限制目标方法，其所在类型有给定的注解 @annotation: 限制目标方法有给定注解  在AspectJ中，因为Aspect是一个基于类型的语法，this和target都指向同一个对象。\n但在SpringAOP中，this和target是有区别的，Spring AOP是基于代理的系统，this代表的是代理对象，target代表的才是目标方法所在的对象\n Spring不支持以下AspectJ的pointcut标识符：\ncall, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this, and @withincode\n如果使用这些pointcut标识符会抛出IllegalArgumentException\n  因为Spring AOP以代理为基础的特性，是不会拦截在目标方法所在类中的调用的，换句话说目标方法所在类的其他方法中调用了目标方法是不会触发拦截的 这个特性是由Spring AOP默认使用的JDK proxies造成的，可以通过替换Spring's proxy-based AOP framework为Spring-driven native AspectJ weaving 来解决，但是需要对waving有一定熟练度\n Spring AOP支持一个额外的PCD，叫做bean。这个标识符可以让你限制目标方法去匹配一个或多个指定的Spring bean(多个通过通配符)\nbean(idOrNameOfBean)\r idOrNameOfBean可以是任何Spring bean的名称。如果你确定了多个bean名称的规则，可以也只能用*号去写PCD表达式来选择他们\n当bean需要和其他的PCD一起使用的时候，同样可以使用\u0026amp;\u0026amp;(and)，!(negation),||(or)来连接\n2.3.2 组合pointcut表达式 你可以组合pointcut表达式通过使用\u0026amp;\u0026amp;，||和!\n@Pointcut(\u0026quot;execution(public * *(..))\u0026quot;)\rprivate void anyPublicOperation(){}\r@Pointcut(\u0026quot;within(com.xyz.myapp.trading..*)\u0026quot;)\rprivate void inTrading(){}\r@Pointcut(\u0026quot;anyPublicOperation() \u0026amp;\u0026amp; inTrading()\u0026quot;)\rprivate void tradingOperation(){}\r 对上面的三个pointcut逐个解析\n anyPublicOperation 匹配任何目标方法是public的 inTrading 匹配任何目标方法在trading模块路径下 tradingOperation 任何目标方法是public，并且在trading模块下  从小的命名组件完成了一个复杂的pointcut表达式的构建，这是一个最好的实现方式，正如上面的实例。\n当通过名字引用pointcut，跟一般java的可见规则一样(private,protected,public)，意味着你可以引用其他类的pointcut，只要对应pointcut的类修饰符可见。 pointcut的可见性不影响切面的匹配，只影响pointcut表达式的引用\n2.3.3 分享共用的Pointcut定义 在开发中有很多切面是经常使用到的，推荐定义一个CommonPointcuts切面类来定义共用的pointcut表达式\n典型的类似下边的这个例子：\npackage com.xyz.myapp;\rimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Pointcut;\r@Aspect\rpublic class CommonPointcuts {\r/**\r* 在web层的切面，任何在web目录以及子目录类中定义的方法\r*/\r@Pointcut(\u0026quot;within(com.xyz.myapp.web..*)\u0026quot;)\rpublic void inWebLayer() {}\r/**\r* service层的切面，任何在service目录以及子目录类中定义的方法\r*/\r@Pointcut(\u0026quot;within(com.xyz.myapp.service..*)\u0026quot;)\rpublic void inServiceLayer() {}\r/**\r* dao层的切面，任何在dao目录以及子目录类中定义的方法\r*/\r@Pointcut(\u0026quot;within(com.xyz.myapp.dao..*)\u0026quot;)\rpublic void inDataAccessLayer() {}\r/**\r* 业务Service切面，任何在service接口中定义的方法,假定接口在\u0026quot;service\u0026quot;package中，并且子包中有其实现类\r*\r* 也可以使用bean(*Service)，但是要确保Service的命名规则\r*/\r@Pointcut(\u0026quot;execution(* com.xyz.myapp..service.*.*(..))\u0026quot;)\rpublic void businessService() {}\r/**\r* 任何在dao接口中定义的方法，假定接口在\u0026quot;dao\u0026quot;package中，并且子包有其实现类\r*/\r@Pointcut(\u0026quot;execution(* com.xyz.myapp.dao.*.*(..))\u0026quot;)\rpublic void dataAccessOperation() {}\r}\r 你可以引用这些pointcut定义，在任何你需要他们的地方。举个例子，给所有service层都加上事务，你可以这样写：\n\u0026lt;aop:config\u0026gt;\r\u0026lt;aop:advisor\rpointcut=\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;\radvice-ref=\u0026quot;tx-advice\u0026quot;/\u0026gt;\r\u0026lt;/aop:config\u0026gt;\r\u0026lt;tx:advice id=\u0026quot;tx-advice\u0026quot;\u0026gt;\r\u0026lt;tx:attributes\u0026gt;\r\u0026lt;tx:method name=\u0026quot;*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt;\r\u0026lt;/tx:attributes\u0026gt;\r\u0026lt;/tx:advice\u0026gt;\r 关于具体的\u0026lt;aop:config\u0026gt;和\u0026lt;aop:advisor\u0026gt;元素使用方式可以参考 Schema-based AOP Support\n关于事务元素的使用可以参考 Transaction Management\n2.3.4 实例 Spring AOP 的用户最经常使用的pointcut标识符是execution，execution表达式的格式如下：\n execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)\rthrows-pattern?)\r   以上表达式中，除了ret-type-pattern，name-pattern和param-pattern是必须的，其他的都是可选参数\n  ret-type-pattern指代返回类型\n *号是最常用到的，代表可以返回任何类型 一个完全限定的类型名称，只有在方法返回指定类型的时候才会匹配    name-pattern 指代方法名称\n 你可以使用*号来代替部分或者全部方法名 如果你指定了declaring-type-pattern，用.号连接name-component    param-pattern 指代方法参数\n ()代表方法没有任何参数 (..)代表方法可能没有参数，也可能有任意数量任意类型的参数 (*) 代表方法有一个任意类型的参数 (*,String) 代表方法有两个参数，一个是任意类型，一个必须是String    完整的AspectJ pointcut表达式语法结构可以参考Language Semantics\n一下的实例展示了经常使用到的pointcut表达式：\n 任何执行的public方法   execution(public * *(..))\n  任何执行的方法是以set开头的   execution(* set*(..))\n  任何执行的方法是AccountService中定义的   execution(* com.xyz.service.AccountService.*(..))\n  任何执行的方法是定义在service包中的   execution(* com.xyz.service.*.*(..))\n  任何执行的方法是定义在service包或者其子包中的   execution(* com.xyz.service..*.*(..))\n  任何在service包下的方法   within(com.xyz.service.*)\n  任何在service包或其子包下的方法   within(com.xyz.service..*)\n  任何方法的代理是实现AccountService接口的   this(com.xyz.service.AccountService)\n一般用于绑定结构，具体用法在后面会提到\n  任何方法的目标对象是实现AccountService接口的   target(com.xyz.service.AccountService)\n一般用于绑定结构，具体用法在后面会提到\n  任何执行的方法有一个参数，并且这个参数在运行时是通过Serializable传递的   args(java.io.Serializable)\n一般用于绑定接口，具体用法在后面会提到\n注意这里的参数匹配跟execution(* *(java.io.Serializable))是不同的\nargs代表参数在运行时是以Serializable传递的\nexecution代表参数必须是Serializable类型\n  任何方法的目标对象有@Transactional注解   @target(org.springframework.transaction.annotation.Transactional)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法的目标对象的申明类型有@Transactional注解   @within(org.springframework.transaction.annotation.Transactional)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法上有@Transactional注解   @annotation(org.springframework.transaction.annotation.Transactional)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法只有一个参数，并且该参数在运行时传递有@Classified注解   @args(com.xyz.security.Classified)\n你同样可以把他用在绑定结构，具体用法在后面会提到\n  任何方法所属的Spring bean的名称是tradeService   bean(tradeService)\n  任何方法所属的Spring bean的名称是以Service结尾   bean(*Service)\n 2.3.5 写好pointcuts表达式 AspectJ不会直接采用你写的pointcut表达式，进行分析校验后，你的表达式会被重写\n关于表达式的顺序，AspectJ也会重排，意味着不需要担心你的表达式写法会影响匹配效率\n但是你直接选用的pointcut标识符还是会对匹配效率造成影响，原则上应该选用搜索范围更小的定义 AspectJ的标识符可以分为三类：类型，范围，和上下文：(以下标识符包括Spring不支持的)\n 类型：指定类型的连接点：execution,get,set,call,和withcode 范围：指定范围内的连接点：within和withcode 上下文：指定上下文：this,target,和@annotation  一个好的pointcut表达式至少要包含类型和范围两个类型\n如果只有类型和上下文，会影响性能，因为需要一些额外的处理和分析\n但是范围不同，他的匹配速度非常快，一个好的pointcut表达式应该尽可能的包含一个\n2.4 申明Advice Advice需要关联一个pointcut表达式，并申明在匹配的pointcut之前(before)，之后(after)，或者前后(around)运行\n引用pointcut表达式可简单引用已命名的pointcut表达式，或者就地申明pointcut表达式\n2.4.1 Before Advice 你可以在一个切面类中申明before advice通过使用@Before注解:\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Before;\r@Aspect\rpublic class BeforeExample {\r@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doAccessCheck() {\r// ...\r}\r}\r 如果我们不引用已声明的pointcut，可以直接就地申明：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Before;\r@Aspect\rpublic class BeforeExample {\r@Before(\u0026quot;execution(* com.xyz.myapp.dao.*.*(..))\u0026quot;)\rpublic void doAccessCheck() {\r// ...\r}\r}\r 2.4.2 After Returning Advice After Returning Advice在方法正常return后运行。\n你可以申明它通过使用@AfterReturning注解：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterReturning;\r@Aspect\rpublic class AfterReturningExample {\r@AfterReturning(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doAccessCheck() {\r// ...\r}\r}\r  你可以拥有多个advice，在同一个切面类中\n 有些时候，你需要在advice方法中访问目标方法的返回值。你可以使用@AfterReturning的参数结构去绑定返回参数：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterReturning;\r@Aspect\rpublic class AfterReturningExample {\r@AfterReturning(\rpointcut=\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;,\rreturning=\u0026quot;retVal\u0026quot;)\rpublic void doAccessCheck(Object retVal) {\r// ...\r}\r}\r returning参数所用的名字，必须跟advice方法的参数名相同\n并且返回值的类型也必须匹配(这里用的Object，可匹配所有返回值)\n注意想通过after returning advice返回一个完全不同的引用是不可能的\n2.4.3 After Throwing Advice After Throwing Advice当目标方法是因为抛出异常退出的时候执行。 可以通过@AfterThrowing注解来实现：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterThrowing;\r@Aspect\rpublic class AfterThrowingExample {\r@AfterThrowing(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doRecoveryActions() {\r// ...\r}\r}\r 在通常使用情况下，你可能需要在指定异常的时候运行Advice，或者获取方法抛出的异常（想获得异常，又不想限制，使用Throwable）\n你可以使用@AfterThrowing的属性throwing来实现：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.AfterThrowing;\r@Aspect\rpublic class AfterThrowingExample {\r@AfterThrowing(\rpointcut=\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;,\rthrowing=\u0026quot;ex\u0026quot;)\rpublic void doRecoveryActions(DataAccessException ex) {\r// ...\r}\r}\r 同样throwing中的名字必须跟advice方法的参数名称相同\n当然也有类型限制，advice方法的参数类型，必须跟目标方法抛出的异常类型相同\n2.4.4 After (Finally) Advice After (Finally) Advice是在目标方法执行退出后运行\n它通过注解@After来实现，用该注解的时候，你需要同时处理正常返回现象和异常退出现象\n这个Advice通常用来处理资源释放问题或者其他相似的情形：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.After;\r@Aspect\rpublic class AfterFinallyExample {\r@After(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()\u0026quot;)\rpublic void doReleaseLock() {\r// ...\r}\r}\r 2.4.5 Around Advice Around Advice是最后一个advice，也是最强大的一个。你可以在方法执行前，执行后做处理，甚至可以决定什么时候运行，怎样运行，是否运行目标方法\n它经常使用的场景是在方法运行前后有状态信息需要分享的，比如方法的运行时间等等\n在选择Advice的时候，始终使用功能最弱的那个，比如能用Before，就不用Around\nAround Advice通过注解@Around来申明。advice方法的第一个参数类型必须是ProceedingJoinPoint\n在advice方法中，通过调用第一个参数的proceed()方法，可以执行目标方法\nproceed可以传递一个Object[]参数，这个数组，是目标方法所需要的所有参数 如何使用Around Advice？下面是一个例子：\nimport org.aspectj.lang.annotation.Aspect;\rimport org.aspectj.lang.annotation.Around;\rimport org.aspectj.lang.ProceedingJoinPoint;\r@Aspect\rpublic class AroundExample {\r@Around(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;)\rpublic Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {\r// start stopwatch\rObject retVal = pjp.proceed();\r// stop stopwatch\rreturn retVal;\r}\r}\r around advice 的返回值就是方法调用者看到的返回值。举个例子，一个简单的缓存切面，如果缓存里面有直接从缓存返回，如果缓存里面没有再调用proceed()方法。\n注意proceed有可能调用一次，或者多次，甚至不调用，这都是合法的\n2.4.6 advice参数 访问当前的 JoinPoint 任何的advice方法都可以申明JoinPoint作为第一个参数（除了around例外，不过它的第一个参数ProceedingJoinPoint，也是JoinPoint的子类)\nJoinPoint提供了一些很有用的方法：\n getArgs()：返回方法参数 getThis()：返回代理对象 getTarget()：返回目标对象 getSignature()：返回方法的描述 toString()：打印方法有用的描述  完整API参考javadoc\n给Advice传递参数 我们已经看过怎样绑定返回值和异常值（通过使用after returning和after throwingadvice)。那么参数值怎么绑定了，可以使用args表达式\n如果在args表达式里使用对应的advice方法的参数名代替类型名，当advice被调用时对应的参数就会被指定类型的原方法参数替换。\n举个例子，假如你的目标方法第一个参数是一个类型为Account的对象，你需要访问这个account参数在advice的方法体中，你可以像下面这样写：\n@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation() \u0026amp;\u0026amp; args(account,..)\u0026quot;)\rpublic void validateAccount(Account account) {\r// ...\r}\r args(account,..)这个pointcut表达式有两个目的\n 限制目标方法至少有一个参数，并且这个参数是Account类的实例 通过advice参数传递参数的值  传递参数的另外一个方法是在一个pointcut表达式里面申明好，advice直接引用：\n@Pointcut(\u0026quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation() \u0026amp;\u0026amp; args(account,..)\u0026quot;)\rprivate void accountDataAccessOperation(Account account) {}\r@Before(\u0026quot;accountDataAccessOperation(account)\u0026quot;)\rpublic void validateAccount(Account account) {\r// ...\r}\r this、target、@within、@target、@annotation，和@args都可以用同样的方式绑定\n下面的两个例子展示了如何匹配有注解@Auditable的方法和如何提取注解的AuditCode参数\n第一个例子展示了@Auditable注解：\n@Retention(RetentionPolicy.RUNTIME)\r@Target(ElementType.METHOD)\rpublic @interface Auditable {\rAuditCode value();\r}\r 第二个例子是对应的advice：\n@Before(\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod() \u0026amp;\u0026amp; @annotation(auditable)\u0026quot;)\rpublic void audit(Auditable auditable) {\rAuditCode code = auditable.value();\r// ...\r}\r Advice参数和泛型 Spring AOP可以处理类泛型和方法泛型\n假如你有一个接口如下所示：\npublic interface Sample\u0026lt;T\u0026gt; {\rvoid sampleGenericMethod(T param);\rvoid sampleGenericCollectionMethod(Collection\u0026lt;T\u0026gt; param);\r}\r 你可以指定泛型为什么类型时才拦截方法：\n@Before(\u0026quot;execution(* ..Sample+.sampleGenericMethod(*)) \u0026amp;\u0026amp; args(param)\u0026quot;)\rpublic void beforeSampleMethod(MyType param) {\r// Advice implementation\r}\r 这个方法在泛型指向集合的时候是不生效的。所以你不能像下边那样定义pointcut：\n@Before(\u0026quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) \u0026amp;\u0026amp; args(param)\u0026quot;)\rpublic void beforeSampleMethod(Collection\u0026lt;MyType\u0026gt; param) {\r// Advice implementation\r}\r 要实现这种情况，你需要改变参数类型为Collection\u0026lt;?\u0026gt;，并且你需要手动校验集合中的每一个元素，这是不合理的，因为null值无法处理。\n确定参数名称 advice调用时的参数绑定是依赖于pointcut表达式里面的名称（用于申明advice参数名）和pointcut方法签名的名字相匹配，但是在java反射里边，参数名称是不可用的\n所以Spring AOP采用了以下策略却决定参数名称:\n 如果参数名已经被用户明确指定，那么指定的参数名会被使用。advice和pointcut注解都有一个可选属性argNames，你可以用它指定注解方法的参数名称 这些参数名称在运行时也是可用的。下面这个例子展示了如何使用argNames属性：  @Before(value=\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod() \u0026amp;\u0026amp; target(bean) \u0026amp;\u0026amp; @annotation(auditable)\u0026quot;,\rargNames=\u0026quot;bean,auditable\u0026quot;)\rpublic void audit(Object bean, Auditable auditable){\rAuditCode code = auditable.value();\r}\r 如果第一个参数是默认参数JoinPoint，ProceedingJoinPoint,或者JoinPoint.StaticPart，在配置argNames时你可以直接忽略这些默认参数\n举个例子，如果你修改上面的advice新增一个JoinPoint参数，argNames不需要涵盖它：\n@Before(value=\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod() \u0026amp;\u0026amp; target(bean) \u0026amp;\u0026amp; @annotation(auditable)\u0026quot;,\rargNames=\u0026quot;bean,auditable\u0026quot;)\rpublic void audit(JoinPoint joinPoint, Object bean, Auditable auditable){\rAuditCode code = auditable.value();\r}\r 当advice方法只有默认参数JoinPoint，PorceedingJoinPoint，和Joint.StaticPart时，可以不写argNames\n@Before(\u0026quot;com.xyz.lib.Pointcuts.anyPublicMethod()\u0026quot;)\rpublic void audit(JoinPoint jp) {\r// ... use jp\r}\r   使用argNames属性显得稍微有些笨拙，所以当argNames没有被指定时，Spring AOP将会在类的debug信息中查找，并从本地变量表中决定参数名称\n只要类编译时有debug信息(至少是-g:vars)就能得到这个信息。\n启用此标志进行编译的结果是：\n 你的代码会更容易理解（反向工程） class文件的大小会有轻微增大（一般可以忽略不计） 会移除编译器没有用到的本地变量  换句话说，使用这个标志你不会碰见任何困难\n  如果代码被编译的时候没有必须的debug信息，Spring AOP会尝试推断参数的配对关系（举个例子，如果pointcut表达式里面只有一个参数绑定，而且advice也只有一个参数，那么这个配对关系就很明显）\n如果在可用的信息里面绑定参数是不确定的，那么AmbiguousBindingException异常将会抛出\n  如果上面的所有策略都失败了，那么IllegalArgumentException异常将会抛出\n  proceed方法如果带参数 之前提过如何写一个带参数的proceed调用。这个解决方法需要确保advice的签名按顺序绑定了目标方法的每一个参数\n@Around(\u0026quot;execution(List\u0026lt;Account\u0026gt; find*(..)) \u0026amp;\u0026amp; \u0026quot; +\r\u0026quot;com.xyz.myapp.CommonPointcuts.inDataAccessLayer() \u0026amp;\u0026amp; \u0026quot; +\r\u0026quot;args(accountHolderNamePattern)\u0026quot;)\rpublic Object preProcessQueryPattern(ProceedingJoinPoint pjp,\rString accountHolderNamePattern) throws Throwable {\rString newPattern = preProcess(accountHolderNamePattern);\rreturn pjp.proceed(new Object[] {newPattern});\r}\r 无论如何都要像上面的例子一样绑定\n2.4.7 advice顺序 当多个advice同时指向一个目标方法时，Spring AOP和AspectJ遵循同样的优先级规则：\n 进入方法：优先级高的先执行（比如两个给定的beforeadvice，优先级高的先执行） 离开方法：优先级高的后执行（比如两个给定的afteradvice，优先级高的后执行）  当两个advice定义在不同的aspect类但指向同一个目标方法时，除非你在其他地方指定了，不然执行顺序是没有定义的。\n你可以直接控制执行的优先级顺序,有两个方式：\n aspect类实现org.springframework.core.Ordered接口 aspect类加注解@Order\n两个切面Ordered.getValue()(或者注解的value)，谁的值更小，睡的优先级更高   从Spring Framework 5.2.7开始，如果advice方法都定义在同一个aspect类中并且都指向同一个目标方法，那么他们的优先级是基于他们的advice类型的\n按照如下的顺序，从高到低：\n@Around,@Before,@After,@AfterReturning,@AfterThrowing\n但请注意因为Spring的AspectJAfterAdvice实现方式，任何在同一个切面类中的@AfterReturning或者AfterThrowingadvice方法执行过后都会去执行@Afteradvice方法\n当两个同样类型的advice(比如，两个@Afteradvice方法)定义在同一个切面类中时，并且都指向同一个目标方法，这种情况下顺序是无法定义的\n因为没有办法从javac已经编译过的类反射中获取源码的申明顺序\n所以当遇到这种情况时，请考虑合并这两个advice方法，或者把重复advice方法提取到另外一个切面类中\n 2.5 Introductions Introductions(在AspectJ中叫做类型间声明) 让切面类可以申明目标方法所在对象实现指定接口，而且提供一个接口的实现类去代表那些对象\n你可以创建一个introduction通过使用@DeclareParents注解。这个注解被用来申明匹配的类型有一个新的父类\n举个例子，给定接口叫做UsageTracked然后这个接口的实现类叫做DefaultUsageTracked\n下面的切面申明了所有实现service的实现类也实现了UsageTracked接口（例如通过JMX公开统计信息）：\n@Aspect\rpublic class UsageTracking {\r@DeclareParents(value=\u0026quot;com.xzy.myapp.service.*+\u0026quot;, defaultImpl=DefaultUsageTracked.class)\rpublic static UsageTracked mixin;\r@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService() \u0026amp;\u0026amp; this(usageTracked)\u0026quot;)\rpublic void recordUsage(UsageTracked usageTracked) {\rusageTracked.incrementUseCount();\r}\r}\r 2.6 切面类实例化模型 默认情况下，对application context来说每个切面类都是单例的。AspectJ将其称作单实例模型。可以使用备用的生命周期来定义Aspect\nSpring 支持AspectJ的perthis和pertarget实例化模型\n暂不支持percflow,percflowbelow，和pertypewithin\n你可以申明一个perthis切面通过制定perthis语句在注解@Aspect中：\n@Aspect(\u0026quot;perthis(com.xyz.myapp.CommonPointcuts.businessService())\u0026quot;)\rpublic class MyAspect{\rprivate int someState;\r@Before(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;)\rpublic void recordServiceUsage(){\r// ...\r}\r}\r 在上面的例子中，perthis语句的作用就是每匹配一个service对象就创建一个切面实例。当一个service对象的方法被调用时，切面实例被第一次创建\n当service对象超出范围时，切面对象也会超出范围（暂不明白这里的超出范围指的是什么）\n在切面实例被创建之前，里面的advice方法不会被调用。只要切面实例被创建，并且service对象与一个切面关联的时候，advice才会在匹配的时候运行\npertarget实例化模型的工作方式跟perthis完全相同\n2.7 一个完整的AOP实例 当执行业务service的时候，有时候会因为并发原因失败（例如，一个因为获取悲观锁失败的操作）。如果重新尝试，很可能在下次尝试的时候成功\n当这种情况出现时，我们应该有一个明显的重试操作以避免向客户端发送PessimisticLockingFailureException。这个需求很明显跨越了多个service，很明显可以用切面来实现\n因为我们需要多次执行proceed方法，所以我们肯定需要around advice：\n@Aspect\rpublic class ConcurrentOperationExecutor implements Ordered {\rprivate static final int DEFAULT_MAX_RETRIES = 2;\rprivate int maxRetries = DEFAULT_MAX_RETRIES;\rprivate int order = 1;\rpublic void setMaxRetries(int maxRetries) {\rthis.maxRetries = maxRetries;\r}\rpublic int getOrder() {\rreturn this.order;\r}\rpublic void setOrder(int order) {\rthis.order = order;\r}\r@Around(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService()\u0026quot;)\rpublic Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\rint numAttempts = 0;\rPessimisticLockingFailureException lockFailureException;\rdo {\rnumAttempts++;\rtry {\rreturn pjp.proceed();\r}\rcatch(PessimisticLockingFailureException ex) {\rlockFailureException = ex;\r}\r} while(numAttempts \u0026lt;= this.maxRetries);\rthrow lockFailureException;\r}\r}\r 注意上面的切面类实现了Ordered接口，所以我们设置切面类的优先级是高于事务的（我们想每次尝试都是一个新事务）\nmaxRetries和order属性都由Spring配置\n主要的操作都发生在doConcurrentOperationaround advice。注意，在当前情况，我们应用了重试逻辑在每个businessService()。如果运行抛出PessimisticLockingFailureException异常，就会进行重试操作，除非重新操作次数已经耗尽。\n对应的Spring配置如下：\n\u0026lt;aop:aspectj-autoproxy/\u0026gt;\r\u0026lt;bean id=\u0026quot;concurrentOperationExecutor\u0026quot; class=\u0026quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;maxRetries\u0026quot; value=\u0026quot;3\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;order\u0026quot; value=\u0026quot;100\u0026quot;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r 提炼aspect让他只有在幂等操作的时候才重试（幂等：函数多次运行结果与一次运行结果相同），我们可以定义Idempotent注解：\nimport java.lang.annotation.ElementType;\rimport java.lang.annotation.Retention;\rimport java.lang.annotation.RetentionPolicy;\rimport java.lang.annotation.Target;\r@Target(ElementType.METHOD)\r@Retention(RetentionPolicy.RUNTIME)\rpublic @interface Idempotent{}\r 现在可以使用Idempotent注解去标注需要重试的service 方法，同时我们的pointcut表达式也需要修改：\n@Around(\u0026quot;com.xyz.myapp.CommonPointcuts.businessService() \u0026amp;\u0026amp; \u0026quot; +\r\u0026quot;@annotation(com.xyz.myapp.service.Idempotent)\u0026quot;)\rpublic Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\r// ...\r}\r 3. 基于架构的AOP支持（xml配置形式的） xml配置形式的AOP跟基于AspectJ的形，只是方式不一样，用的pointcut表达式都是一样的，这里不细讲，详细参考文末的官方文档\n 详情参考 Spring官方文档\n ","id":79,"section":"posts","summary":"1.切面编程核心概念 切面编程Aspect-oriented Programming (AOP) AOP只是一个概念，跟Spring是独立关系 最典型的AOP实现框架Aspect","tags":["spring"],"title":"Spring切面编程","uri":"http://www.mingaccount.com/2017/06/spring%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/","year":"2017"},{"content":"1.什么叫依赖倒转，里氏替换？  所谓依赖倒转就是抽象类不应该依赖于子类，子类应该依赖于抽象类，并且子类之间不应该互相依赖。依赖倒转是面对对象的标志，程序中所有的依赖关系都应该终止于抽象类或者接口中。 里氏代换指的是子类能够完全的替换掉父类，代表着子类拥有父类所有的非private属性和行为，正因为里氏代换使得开放和封闭原则成为了可能。   依赖倒转和里氏代换的存在，使得对任何子类的修改都不会影响到其他子类以及父类成为了可能，降低了代码的耦合，提高了可复用性。\n","id":80,"section":"posts","summary":"1.什么叫依赖倒转，里氏替换？ 所谓依赖倒转就是抽象类不应该依赖于子类，子类应该依赖于抽象类，并且子类之间不应该互相依赖。依赖倒转是面对对象的","tags":["design pattern"],"title":"设计模式总览","uri":"http://www.mingaccount.com/2017/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88/","year":"2017"},{"content":"Java, Java Script, HTML, JSON, CSV and XML org.apache.commons.lang3.StringEscapeUtils\n//使用示例\rStringEscapeUtils.escapeCsv(\u0026quot;\u0026quot;);\rSqtringEscapeUtils.escapeXml(\u0026quot;\u0026quot;);\r  api文档\n Regexp  正则表达式转义所有特殊符号\n 其他 com.google.common.escape.Escapers\nEscaper build = Escapers.builder().addEscape('$', \u0026quot; \u0026quot;).build();\rString str = build.escape(\u0026quot;$$$$\u0026quot;);\r  api文档\n ","id":81,"section":"posts","summary":"Java, Java Script, HTML, JSON, CSV and XML org.apache.commons.lang3.StringEscapeUtils //使用示例 StringEscapeUtils.escapeCsv(\u0026quot;\u0026quot;); SqtringEscapeUtils.escapeXml(\u0026quot;\u0026quot;); api文档 Regexp 正则表达式转义所有特殊符号 其他 com.google.common.escape.Escapers Escaper build = Escapers.builder().addEscape('$', \u0026quot; \u0026quot;).build(); String str = build.escape(\u0026quot;$$$$\u0026quot;); api文档","tags":["java"],"title":"JavaString 特殊符号处理工具类","uri":"http://www.mingaccount.com/2017/05/javastring%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E7%B1%BB/","year":"2017"},{"content":"正则表达式的特殊符号包括\n\\ $ ( ) * + . [ ] ? ^ { } | -\n实现代码(java)\npublic class RegexUtils {\rprivate static final String[] SPECIAL_SYMBOLS =\rnew String[]{\u0026quot;\\\\\u0026quot;, \u0026quot;$\u0026quot;, \u0026quot;(\u0026quot;, \u0026quot;)\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;[\u0026quot;, \u0026quot;]\u0026quot;, \u0026quot;?\u0026quot;, \u0026quot;^\u0026quot;, \u0026quot;{\u0026quot;, \u0026quot;}\u0026quot;, \u0026quot;|\u0026quot;, \u0026quot;-\u0026quot;};\r/**\r* 转义目标正则表达式中的所有特殊字符\r* @param regex\r* @return\r*/\rpublic static String escapeSpecialSymbols(String regex) {\rfor (String specSymbol : SPECIAL_SYMBOLS) {\rString escapeSymbol = \u0026quot;\\\\\u0026quot; + specSymbol;\rregex = regex.replace(specSymbol, escapeSymbol);\r}\rreturn regex;\r}\r}\r ","id":82,"section":"posts","summary":"正则表达式的特殊符号包括 \\ $ ( ) * + . [ ] ? ^ { } | - 实现代码(java) public class RegexUtils { private static final String[] SPECIAL_SYMBOLS = new String[]{\u0026quot;\\\\\u0026quot;, \u0026quot;$\u0026quot;, \u0026quot;(\u0026quot;, \u0026quot;)\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;[\u0026quot;, \u0026quot;]\u0026quot;, \u0026quot;?\u0026quot;, \u0026quot;^\u0026quot;, \u0026quot;{\u0026quot;, \u0026quot;}\u0026quot;, \u0026quot;|\u0026quot;, \u0026quot;-\u0026quot;}; /** * 转义目标正","tags":["regexp"],"title":"正则表达式转义所有特殊符号","uri":"http://www.mingaccount.com/2017/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B9%89%E6%89%80%E6%9C%89%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/","year":"2017"},{"content":"表名  mysql 每一个表至少对应一个服务器文件，而且名字对应，因此表名的大小写敏感跟系统有关系，windows不区分，linux区分 oracle 所有不在双引号里的内容都会被转为大写，想要区分大小写，就用双引号括起来  字段名  mysql 不区分大小写 oracle 跟表名一样，默认会被转为大写，想要区分，需要双引号   mysql可以通过修改lower_case_table_names属性来忽略表名的大小写区分，参考Mysql表名忽略大小写\n 但有个问题需要注意，mysql的大小写忽略，会把所有字符转为小写，而oracle的，像前边所说的会把所有字符转为大写\n","id":83,"section":"posts","summary":"表名 mysql 每一个表至少对应一个服务器文件，而且名字对应，因此表名的大小写敏感跟系统有关系，windows不区分，linux区分 oracle 所有不在双引号里","tags":["mysql","oracle"],"title":"关于mysql和oracle的大小写敏感","uri":"http://www.mingaccount.com/2017/05/%E5%85%B3%E4%BA%8Emysql%E5%92%8Coracle%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/","year":"2017"},{"content":"@SpringBootApplication(scanBasePackages=\u0026quot;com.*.*\u0026quot;)\r@EnableScheduling\r@EnableTransactionManagement\r@MapperScan(\u0026quot;com.*.**.*mapper\u0026quot;)\r@EnableConfigurationProperties({CustomConfiguration.class})\rpublic class Application {}\r  SpringBootApplication Spring注解的扫描路径 EnableScheduling 开启Spring的定时任务 EnableTransactionManagement 开始Spring的事务管理 MapperScan 扫描MyBatis Mapper类的路径 EnableConfigurationProperties 自定义配置文件映射类  ","id":84,"section":"posts","summary":"@SpringBootApplication(scanBasePackages=\u0026quot;com.*.*\u0026quot;) @EnableScheduling @EnableTransactionManagement @MapperScan(\u0026quot;com.*.**.*mapper\u0026quot;) @EnableConfigurationProperties({CustomConfiguration.class}) public class Application {} SpringBootApplication Spring注解的扫描路径 EnableScheduling 开启Spring的定时任务 EnableTransactionManagement 开始Spring的事务管理 MapperScan 扫描MyBatis Mapper类的路","tags":["spring"],"title":"SpringBoot入口类常用注解","uri":"http://www.mingaccount.com/2017/05/springboot%E5%85%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%B3%A8%E8%A7%A3/","year":"2017"},{"content":"新建指定配置类TestConfiguration\n该类需要的注解：\n@Configuration @ConfigurationProperties(prefix=\u0026quot;test\u0026quot;) @PropertySource(\u0026quot;classpath:test.properties\u0026quot;)  同时启动类上需要增加注解：\n@EnableConfigurationProperties({TestConfiguration.class})  ","id":85,"section":"posts","summary":"新建指定配置类TestConfiguration 该类需要的注解： @Configuration @ConfigurationProperties(prefix=\u0026quot;test\u0026quot;) @PropertySource(\u0026quot;classpath:test.properties\u0026quot;) 同时启动类上需要增加注解： @EnableConfigurationProperties({TestConfiguration.class})","tags":["spring"],"title":"Spring自定义配置文件并映射到指定类中","uri":"http://www.mingaccount.com/2017/01/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B9%B6%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E7%B1%BB%E4%B8%AD/","year":"2017"},{"content":" 测试数据     random     24   24uixcvkjklwer     查询sql1  SELECT random FROM table WHERE random = 24\r 该sql会把两条记录都查出来\n 查询sql2  SELECT random FROM table WHERE random = '24'\r 该sql只会匹配第一条记录\n 总结\n条件列为字符串的时候，保证用来判断的常量也是字符类型  ","id":86,"section":"posts","summary":"测试数据 random 24 24uixcvkjklwer 查询sql1 SELECT random FROM table WHERE random = 24 该sql会把两条记录都查出来 查询sql2 SELECT random FROM table WHERE random = '24' 该sql只会匹配第一条记录 总结 条件列为字符","tags":["mysql"],"title":"Mysql Where条件判断 字符串和数字 是否相等时存在的问题","uri":"http://www.mingaccount.com/2016/07/mysqlwhere%E6%AF%94%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E9%97%AE%E9%A2%98/","year":"2016"},{"content":"现在可以通过lombok注解@Builder一步实现\n 1.调用效果 public class Test{\rpublic static void main(String[] args){\rStudent student = Student.builder().name(\u0026quot;小明\u0026quot;).age(15).sex(\u0026quot;男\u0026quot;).build();\r}\r}\r 2.实现原理 public class Student {\rprivate String name;\rprivate Integer age;\rprivate String sex;\rpublic static Builder builder() {\rreturn new Builder();\r}\rpublic Student(Builder builder) {\rthis.name = builder.name;\rthis.age = builder.age;\rthis.sex = builder.sex;\r}\rpublic static class Builder{\rprivate String name ;\rprivate Integer age ;\rprivate String sex;\rpublic Builder name(String name) {\rthis.name = name;\rreturn this;\r}\rpublic Builder age(Integer age) {\rthis.age = age;\rreturn this;\r}\rpublic Builder sex(String sex) {\rthis.sex = sex;\rreturn this;\r}\rpublic Student build() {\rreturn new Student(this);\r}\r}\r}\r 3.静态内部类  静态内部类无需依赖外部类，可以独立存在 多个外部类可以共享一个静态内部类 普通内部类不能申明静态的方法和变量，但是静态内部类无限制  ","id":87,"section":"posts","summary":"现在可以通过lombok注解@Builder一步实现 1.调用效果 public class Test{ public static void main(String[] args){ Student student = Student.builder().name(\u0026quo","tags":["java","design pattern"],"title":"实体类通过建造者模式创建","uri":"http://www.mingaccount.com/2016/06/%E5%AE%9E%E4%BD%93%E7%B1%BBbuild/","year":"2016"},{"content":"注释中如果要指向一个类或者其成员，直接写名字容易出错，且ide无法跳转。可以使用{@link}来引用\n /**\r* {@link String#toString()} }\r* 在类后面追加#号，可以指向类的成员方法或者变量\r**/\rpublic class Test{\r}\r ","id":88,"section":"posts","summary":"注释中如果要指向一个类或者其成员，直接写名字容易出错，且ide无法跳转。可以使用{@link}来引用 /** * {@link String#toString()} } * 在类后面追加#号，可以指向类","tags":["java"],"title":"Java注释引用类和其成员","uri":"http://www.mingaccount.com/2016/04/java%E6%B3%A8%E9%87%8A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%92%8C%E5%85%B6%E6%88%90%E5%91%98/","year":"2016"},{"content":"public class Test{\r/**\r** 一种是直接指定初始值\r**/\rfinal String msg = \u0026quot;\u0026quot;;\r/**\r** 另一种是不指定初始值，在构造方法里面指定\r** 但不允许无参构造的存在，并且每一个构造方法都要对该变量赋值\r**/\rfinal String msg1;\rpublic Test(String msg1){\rthis.msg1 = msg1; }\r}\r ","id":89,"section":"posts","summary":"public class Test{ /** ** 一种是直接指定初始值 **/ final String msg = \u0026quot;\u0026quot;; /** ** 另一种是不指定初始值，在构造方法里面指定 ** 但不允许无参构造的存在，并且每一个构造方法都要对该变","tags":["java"],"title":"Java final成员变量初始化","uri":"http://www.mingaccount.com/2016/01/javafinal%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/","year":"2016"},{"content":"1.Oracle 12c R1 (12.1)支持limit语句 从Oracle 12c R1 (12.1)版本开始，oracle开始支持limit语句，但是跟熟悉的limit(1, 10)语句还是有区别的\noracle的语句更复杂，但是有更多选项能做更多的事。参考oracle limit完整的语法 (关于oracle内部是如何实现limit的可以参考这个回答)\n那么一个oracle limit语句到底应该怎么写了，比如要取21-30行的数据：\nSELECT * FROM sometable\rORDER BY name\rOFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;\r 上面是一个简单直接的例子，下面是引用自官方说明的更多实例:\n1.1 初始化 DROP TABLE rownum_order_test;\rCREATE TABLE rownum_order_test (\rval NUMBER\r);\rINSERT ALL\rINTO rownum_order_test\rINTO rownum_order_test\rSELECT level\rFROM dual\rCONNECT BY level \u0026lt;= 10;\rCOMMIT;\r 表rownum_order_test里的内容：\nSELECT val\rFROM rownum_order_test\rORDER BY val;\rVAL\r----------\r1\r1\r2\r2\r3\r3\r4\r4\r5\r5\r6\r6\r7\r7\r8\r8\r9\r9\r10\r10\r20 rows selected.\r 1.2 Top-N 查询 SELECT val\rFROM rownum_order_test\rORDER BY val DESC FETCH FIRST 10 ROWS ONLY;\rVAL\r----------\r10\r10\r9\r9\r8\r5 rows selected.\r 1.3 WITH TIES 使用WITH TIES语句，在最后一行有重复值存在时，将会把最后一行的重复值都返回。在这个例子中第五行的值是8，但是根据排序，有两个行数值都为8的，所以这两个都保留\nSELECT val\rFROM rownum_order_test\rORDER BY val DESC\rFETCH FIRST 5 ROWS WITH TIES;\rVAL\r----------\r10\r10\r9\r9\r8\r8\r6 rows selected.\r 1.4 前百分比数据量限制 SELECT val\rFROM rownum_order_test\rORDER BY val\rFETCH FIRST 20 PERCENT ROWS ONLY;\rVAL\r----------\r1\r1\r2\r2\r4 rows selected.\r 1.5 分页 ELECT val\rFROM rownum_order_test\rORDER BY val\rOFFSET 4 ROWS FETCH NEXT 4 ROWS ONLY;\rVAL\r----------\r3\r3\r4\r4\r4 rows selected.\r 代表从OFFSET+1开始取4行\n1.6 offset和百分比结合 SELECT val\rFROM rownum_order_test\rORDER BY val\rOFFSET 4 ROWS FETCH NEXT 20 PERCENT ROWS ONLY;\rVAL\r----------\r3\r3\r4\r4\r4 rows selected.\r 2.旧版本不支持limit语句 旧版本的oracle不支持limit语句，需要通过子查询来实现，原因可参考On ROWNUM and limiting results\n2.1 Top-N select *\rfrom ( select * from emp order by sal desc ) where ROWNUM \u0026lt;= 5;\r 2.2 区间 select * from ( select a.*, ROWNUM rnum from ( \u0026lt;your_query_goes_here, with order by\u0026gt; ) a where ROWNUM \u0026lt;= :MAX_ROW_TO_FETCH )\rwhere rnum \u0026gt;= :MIN_ROW_TO_FETCH;\r 2.3 原因 oracle分页的写法显得特别臃肿和多余，但是对于旧版本来说没得选择，这个写法规避了很多排序的问题并且高效\n首先要明白一个概念，ROWNUM并不是跟行绑定的，他是sql执行完from where后，并在排序和聚合前，每得到一个结果就分配一个ROWNUM\n所以像下面这种写法肯定得不到任何结果\nSELECT * FROM t\rWHERE ROWNUM \u0026gt; 1\r 当from获取到第一行，因为还没有经过where判断，所以没有分配ROWNUM，只能读取到ROWNUM的默认值1，然而这个where条件肯定不能成立，也就是说ROWNUM没有分配到第一行（分配逻辑包含自增），永远到不了2，该查询肯定没有结果\n2.3.1 为什么要用子查询 当使用排序时，因为ROWNUM的分配是在排序之前的，所以是先得到10条数据然后排序，而不是先排序后取10条\nSELECT *\rFROM t WHERE ROWNUM \u0026lt;= 10\rORDER BY col DESC  需要封装一个子查询后再限制ROWNUM\nSELECT * FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC )\rWHERE ROWNUM \u0026lt;= 10\r 2.3.2 对Top-N的优化 使用子查询ROWNUM的方式，另外一个原因是oracle对他进行了优化\n如果直接进行查询，再对结果进行筛选，像下面的例子\nSELECT *\rFROM t\rORDER BY col DESC  当表的数据有百万甚至千万行的时候，这个表的所有数据都要放到内存中进行排序，如果用于排序的内存满了，还需要暂存到磁盘上。 大量io和磁盘读写，耗费时间，并且占用资源，仅仅只是为了获取10行数据\n使用子查询ROWNUM的方式，如下\nSELECT * FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC )\rWHERE ROWNUM \u0026lt;= 10\r ORACLE对他进行了优化，像上面的例子，当查询一开始，会将最开始的10个col值保存到内存中排序，然后获取第11个跟内存中的第10个进行比较\n如果在区间外，那么直接忽略这个值。如果在区间内，那么删除原本第10个值，追加第11个，重新进行排序\n按照这个逻辑，遍历时只需要对内存中的10个值进行排序，节省大量资源和时间\n2.3.3 分页注意事项 与top-n的随机性不一样，分页需要同样条件下每次的查询结果都是一致的，但如果排序列有大量的重复值，一致性无法保证\nSELECT *\rFROM (\rSELECT a.*,ROWNUM rn FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC ) a\rWHERE ROWNUM \u0026lt;= 10\r)\rHWERE rn \u0026gt;=6\r 上面的例子中如果col列有大量重复值，每次查询的结果都会不一样\n解决方案是在order by语句中追加ROWID，因为ROWID在表中是唯一的\nSELECT *\rFROM (\rSELECT a.*,ROWNUM rn FROM\r(\rSELECT *\rFROM\rt ORDER BY col DESC ,ROWID\r) a\rWHERE ROWNUM \u0026lt;= 10\r)\rHWERE rn \u0026gt;=6\r ","id":90,"section":"posts","summary":"1.Oracle 12c R1 (12.1)支持limit语句 从Oracle 12c R1 (12.1)版本开始，oracle开始支持limit语句，但是跟熟悉的limit(1,","tags":["oracle"],"title":"Oracle limit 问题","uri":"http://www.mingaccount.com/2016/01/oraclelimit/","year":"2016"},{"content":"@Configuration\r@MapperScan(basePackages = MysqlDatasourceConfig.PACKAGE, sqlSessionFactoryRef = \u0026quot;mysqlSessionFactory\u0026quot;)\rpublic class MysqlDatasourceConfig {\rpublic static final String PACKAGE = \u0026quot;com.ming.mapper.mysql1\u0026quot;;\rpublic static final String MAPPER_LOCATION = \u0026quot;classpath:mapper/mysql1/*.xml\u0026quot;;\r@Primary\r@Bean(name = \u0026quot;mysqlDatasource\u0026quot;)\r@ConfigurationProperties(\u0026quot;spring.datasource.druid.mysql1\u0026quot;)\rpublic DataSource mysqlDataSource(){\rreturn DruidDataSourceBuilder.create().build();\r}\r@Bean(name = \u0026quot;mysqlTransactionManager\u0026quot;)\r@Primary\rpublic DataSourceTransactionManager mysqlTransactionManager() {\rreturn new DataSourceTransactionManager(mysqlDataSource());\r}\r@Bean(name = \u0026quot;mysqlSessionFactory\u0026quot;)\r@Primary\rpublic SqlSessionFactory mysqlSessionFactory(@Qualifier(\u0026quot;mysqlDatasource\u0026quot;) DataSource dataSource) throws Exception {\rfinal SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();\rsessionFactory.setDataSource(dataSource);\rsessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MysqlDatasourceConfig.MAPPER_LOCATION));\rreturn sessionFactory.getObject();\r}\r}\r 配置文件中有多少个数据源就新建多少个上面的配置类 配置类中设置了当前数据源对应的mapper路径和xml路径 在service中使用时，只需要调用对应的mapper即可 ","id":91,"section":"posts","summary":"@Configuration @MapperScan(basePackages = MysqlDatasourceConfig.PACKAGE, sqlSessionFactoryRef = \u0026quot;mysqlSessionFactory\u0026quot;) public class MysqlDatasourceConfig { public static final String PACKAGE = \u0026quot;com.ming.mapper.mysql1\u0026quot;; public static final String MAPPER_LOCATION = \u0026quot;classpath:mapper/mysql1/*.xml\u0026quot;; @Primary @Bean(name = \u0026quot;mysqlDatasource\u0026quot;) @ConfigurationProperties(\u0026quot;spring.datasource.druid.mysql1\u0026quot;) public DataSource mysqlDataSource(){ return DruidDataSourceBuilder.create().build(); } @Bean(name = \u0026quot;mysqlTransactionManager\u0026quot;) @Primary public DataSourceTransactionManager mysqlTransactionManager() { return new DataSourceTransactionManager(mysqlDataSource()); } @Bean(name = \u0026quot;mysqlSessionFactory\u0026quot;) @Primary public SqlSessionFactory mysqlSessionFactory(@Qualifier(\u0026quot;mysqlDatasource\u0026quot;) DataSource dataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MysqlDatasourceConfig.MAPPER_LOCATION)); return","tags":["spring"],"title":"SpringBoot Mybatis配置多数据源","uri":"http://www.mingaccount.com/1/01/springbootmybatis%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/","year":"0001"}],"tags":[{"title":"design pattern","uri":"http://www.mingaccount.com/tags/design-pattern/"},{"title":"druid","uri":"http://www.mingaccount.com/tags/druid/"},{"title":"git","uri":"http://www.mingaccount.com/tags/git/"},{"title":"hadoop","uri":"http://www.mingaccount.com/tags/hadoop/"},{"title":"hive","uri":"http://www.mingaccount.com/tags/hive/"},{"title":"java","uri":"http://www.mingaccount.com/tags/java/"},{"title":"jooq","uri":"http://www.mingaccount.com/tags/jooq/"},{"title":"linux","uri":"http://www.mingaccount.com/tags/linux/"},{"title":"lombok","uri":"http://www.mingaccount.com/tags/lombok/"},{"title":"markdown","uri":"http://www.mingaccount.com/tags/markdown/"},{"title":"maven","uri":"http://www.mingaccount.com/tags/maven/"},{"title":"mybatis","uri":"http://www.mingaccount.com/tags/mybatis/"},{"title":"mysql","uri":"http://www.mingaccount.com/tags/mysql/"},{"title":"npm","uri":"http://www.mingaccount.com/tags/npm/"},{"title":"oracle","uri":"http://www.mingaccount.com/tags/oracle/"},{"title":"regexp","uri":"http://www.mingaccount.com/tags/regexp/"},{"title":"scala","uri":"http://www.mingaccount.com/tags/scala/"},{"title":"spark","uri":"http://www.mingaccount.com/tags/spark/"},{"title":"spring","uri":"http://www.mingaccount.com/tags/spring/"},{"title":"website build","uri":"http://www.mingaccount.com/tags/website-build/"},{"title":"windows","uri":"http://www.mingaccount.com/tags/windows/"}]}